[{"path":"https://smorabit.github.io/hdWGCNA/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"GNU GENERAL PUBLIC LICENSE","title":"GNU GENERAL PUBLIC LICENSE","text":"Version 3, 29 June 2007 Copyright (C) 2007 Free Software Foundation, Inc. https://fsf.org/ Everyone permitted copy distribute verbatim copies license document, changing allowed.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/LICENSE.html","id":"preamble","dir":"","previous_headings":"","what":"Preamble","title":"GNU GENERAL PUBLIC LICENSE","text":"GNU General Public License free, copyleft license software kinds works. licenses software practical works designed take away freedom share change works. contrast, GNU General Public License intended guarantee freedom share change versions program–make sure remains free software users. , Free Software Foundation, use GNU General Public License software; applies also work released way authors. can apply programs, . speak free software, referring freedom, price. General Public Licenses designed make sure freedom distribute copies free software (charge wish), receive source code can get want , can change software use pieces new free programs, know can things. protect rights, need prevent others denying rights asking surrender rights. Therefore, certain responsibilities distribute copies software, modify : responsibilities respect freedom others. example, distribute copies program, whether gratis fee, must pass recipients freedoms received. must make sure , , receive can get source code. must show terms know rights. Developers use GNU GPL protect rights two steps: (1) assert copyright software, (2) offer License giving legal permission copy, distribute /modify . developers’ authors’ protection, GPL clearly explains warranty free software. users’ authors’ sake, GPL requires modified versions marked changed, problems attributed erroneously authors previous versions. devices designed deny users access install run modified versions software inside , although manufacturer can . fundamentally incompatible aim protecting users’ freedom change software. systematic pattern abuse occurs area products individuals use, precisely unacceptable. Therefore, designed version GPL prohibit practice products. problems arise substantially domains, stand ready extend provision domains future versions GPL, needed protect freedom users. Finally, every program threatened constantly software patents. States allow patents restrict development use software general-purpose computers, , wish avoid special danger patents applied free program make effectively proprietary. prevent , GPL assures patents used render program non-free. precise terms conditions copying, distribution modification follow.","code":""},{"path":[]},{"path":"https://smorabit.github.io/hdWGCNA/LICENSE.html","id":"0-definitions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"0. Definitions.","title":"GNU GENERAL PUBLIC LICENSE","text":"“License” refers version 3 GNU General Public License. “Copyright” also means copyright-like laws apply kinds works, semiconductor masks. “Program” refers copyrightable work licensed License. licensee addressed “”. “Licensees” “recipients” may individuals organizations. “modify” work means copy adapt part work fashion requiring copyright permission, making exact copy. resulting work called “modified version” earlier work work “based ” earlier work. “covered work” means either unmodified Program work based Program. “propagate” work means anything , without permission, make directly secondarily liable infringement applicable copyright law, except executing computer modifying private copy. Propagation includes copying, distribution (without modification), making available public, countries activities well. “convey” work means kind propagation enables parties make receive copies. Mere interaction user computer network, transfer copy, conveying. interactive user interface displays “Appropriate Legal Notices” extent includes convenient prominently visible feature (1) displays appropriate copyright notice, (2) tells user warranty work (except extent warranties provided), licensees may convey work License, view copy License. interface presents list user commands options, menu, prominent item list meets criterion.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/LICENSE.html","id":"1-source-code","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"1. Source Code.","title":"GNU GENERAL PUBLIC LICENSE","text":"“source code” work means preferred form work making modifications . “Object code” means non-source form work. “Standard Interface” means interface either official standard defined recognized standards body, , case interfaces specified particular programming language, one widely used among developers working language. “System Libraries” executable work include anything, work whole, () included normal form packaging Major Component, part Major Component, (b) serves enable use work Major Component, implement Standard Interface implementation available public source code form. “Major Component”, context, means major essential component (kernel, window system, ) specific operating system () executable work runs, compiler used produce work, object code interpreter used run . “Corresponding Source” work object code form means source code needed generate, install, (executable work) run object code modify work, including scripts control activities. However, include work’s System Libraries, general-purpose tools generally available free programs used unmodified performing activities part work. example, Corresponding Source includes interface definition files associated source files work, source code shared libraries dynamically linked subprograms work specifically designed require, intimate data communication control flow subprograms parts work. Corresponding Source need include anything users can regenerate automatically parts Corresponding Source. Corresponding Source work source code form work.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/LICENSE.html","id":"2-basic-permissions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"2. Basic Permissions.","title":"GNU GENERAL PUBLIC LICENSE","text":"rights granted License granted term copyright Program, irrevocable provided stated conditions met. License explicitly affirms unlimited permission run unmodified Program. output running covered work covered License output, given content, constitutes covered work. License acknowledges rights fair use equivalent, provided copyright law. may make, run propagate covered works convey, without conditions long license otherwise remains force. may convey covered works others sole purpose make modifications exclusively , provide facilities running works, provided comply terms License conveying material control copyright. thus making running covered works must exclusively behalf, direction control, terms prohibit making copies copyrighted material outside relationship . Conveying circumstances permitted solely conditions stated . Sublicensing allowed; section 10 makes unnecessary.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/LICENSE.html","id":"3-protecting-users-legal-rights-from-anti-circumvention-law","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"3. Protecting Users’ Legal Rights From Anti-Circumvention Law.","title":"GNU GENERAL PUBLIC LICENSE","text":"covered work shall deemed part effective technological measure applicable law fulfilling obligations article 11 WIPO copyright treaty adopted 20 December 1996, similar laws prohibiting restricting circumvention measures. convey covered work, waive legal power forbid circumvention technological measures extent circumvention effected exercising rights License respect covered work, disclaim intention limit operation modification work means enforcing, work’s users, third parties’ legal rights forbid circumvention technological measures.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/LICENSE.html","id":"4-conveying-verbatim-copies","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"4. Conveying Verbatim Copies.","title":"GNU GENERAL PUBLIC LICENSE","text":"may convey verbatim copies Program’s source code receive , medium, provided conspicuously appropriately publish copy appropriate copyright notice; keep intact notices stating License non-permissive terms added accord section 7 apply code; keep intact notices absence warranty; give recipients copy License along Program. may charge price price copy convey, may offer support warranty protection fee.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/LICENSE.html","id":"5-conveying-modified-source-versions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"5. Conveying Modified Source Versions.","title":"GNU GENERAL PUBLIC LICENSE","text":"may convey work based Program, modifications produce Program, form source code terms section 4, provided also meet conditions: work must carry prominent notices stating modified , giving relevant date. work must carry prominent notices stating released License conditions added section 7. requirement modifies requirement section 4 “keep intact notices”. must license entire work, whole, License anyone comes possession copy. License therefore apply, along applicable section 7 additional terms, whole work, parts, regardless packaged. License gives permission license work way, invalidate permission separately received . work interactive user interfaces, must display Appropriate Legal Notices; however, Program interactive interfaces display Appropriate Legal Notices, work need make . compilation covered work separate independent works, nature extensions covered work, combined form larger program, volume storage distribution medium, called “aggregate” compilation resulting copyright used limit access legal rights compilation’s users beyond individual works permit. Inclusion covered work aggregate cause License apply parts aggregate.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/LICENSE.html","id":"6-conveying-non-source-forms","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"6. Conveying Non-Source Forms.","title":"GNU GENERAL PUBLIC LICENSE","text":"may convey covered work object code form terms sections 4 5, provided also convey machine-readable Corresponding Source terms License, one ways: Convey object code , embodied , physical product (including physical distribution medium), accompanied Corresponding Source fixed durable physical medium customarily used software interchange. Convey object code , embodied , physical product (including physical distribution medium), accompanied written offer, valid least three years valid long offer spare parts customer support product model, give anyone possesses object code either (1) copy Corresponding Source software product covered License, durable physical medium customarily used software interchange, price reasonable cost physically performing conveying source, (2) access copy Corresponding Source network server charge. Convey individual copies object code copy written offer provide Corresponding Source. alternative allowed occasionally noncommercially, received object code offer, accord subsection 6b. Convey object code offering access designated place (gratis charge), offer equivalent access Corresponding Source way place charge. need require recipients copy Corresponding Source along object code. place copy object code network server, Corresponding Source may different server (operated third party) supports equivalent copying facilities, provided maintain clear directions next object code saying find Corresponding Source. Regardless server hosts Corresponding Source, remain obligated ensure available long needed satisfy requirements. Convey object code using peer--peer transmission, provided inform peers object code Corresponding Source work offered general public charge subsection 6d. separable portion object code, whose source code excluded Corresponding Source System Library, need included conveying object code work. “User Product” either (1) “consumer product”, means tangible personal property normally used personal, family, household purposes, (2) anything designed sold incorporation dwelling. determining whether product consumer product, doubtful cases shall resolved favor coverage. particular product received particular user, “normally used” refers typical common use class product, regardless status particular user way particular user actually uses, expects expected use, product. product consumer product regardless whether product substantial commercial, industrial non-consumer uses, unless uses represent significant mode use product. “Installation Information” User Product means methods, procedures, authorization keys, information required install execute modified versions covered work User Product modified version Corresponding Source. information must suffice ensure continued functioning modified object code case prevented interfered solely modification made. convey object code work section , , specifically use , User Product, conveying occurs part transaction right possession use User Product transferred recipient perpetuity fixed term (regardless transaction characterized), Corresponding Source conveyed section must accompanied Installation Information. requirement apply neither third party retains ability install modified object code User Product (example, work installed ROM). requirement provide Installation Information include requirement continue provide support service, warranty, updates work modified installed recipient, User Product modified installed. Access network may denied modification materially adversely affects operation network violates rules protocols communication across network. Corresponding Source conveyed, Installation Information provided, accord section must format publicly documented (implementation available public source code form), must require special password key unpacking, reading copying.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/LICENSE.html","id":"7-additional-terms","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"7. Additional Terms.","title":"GNU GENERAL PUBLIC LICENSE","text":"“Additional permissions” terms supplement terms License making exceptions one conditions. Additional permissions applicable entire Program shall treated though included License, extent valid applicable law. additional permissions apply part Program, part may used separately permissions, entire Program remains governed License without regard additional permissions. convey copy covered work, may option remove additional permissions copy, part . (Additional permissions may written require removal certain cases modify work.) may place additional permissions material, added covered work, can give appropriate copyright permission. Notwithstanding provision License, material add covered work, may (authorized copyright holders material) supplement terms License terms: Disclaiming warranty limiting liability differently terms sections 15 16 License; Requiring preservation specified reasonable legal notices author attributions material Appropriate Legal Notices displayed works containing ; Prohibiting misrepresentation origin material, requiring modified versions material marked reasonable ways different original version; Limiting use publicity purposes names licensors authors material; Declining grant rights trademark law use trade names, trademarks, service marks; Requiring indemnification licensors authors material anyone conveys material (modified versions ) contractual assumptions liability recipient, liability contractual assumptions directly impose licensors authors. non-permissive additional terms considered “restrictions” within meaning section 10. Program received , part , contains notice stating governed License along term restriction, may remove term. license document contains restriction permits relicensing conveying License, may add covered work material governed terms license document, provided restriction survive relicensing conveying. add terms covered work accord section, must place, relevant source files, statement additional terms apply files, notice indicating find applicable terms. Additional terms, permissive non-permissive, may stated form separately written license, stated exceptions; requirements apply either way.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/LICENSE.html","id":"8-termination","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"8. Termination.","title":"GNU GENERAL PUBLIC LICENSE","text":"may propagate modify covered work except expressly provided License. attempt otherwise propagate modify void, automatically terminate rights License (including patent licenses granted third paragraph section 11). However, cease violation License, license particular copyright holder reinstated () provisionally, unless copyright holder explicitly finally terminates license, (b) permanently, copyright holder fails notify violation reasonable means prior 60 days cessation. Moreover, license particular copyright holder reinstated permanently copyright holder notifies violation reasonable means, first time received notice violation License (work) copyright holder, cure violation prior 30 days receipt notice. Termination rights section terminate licenses parties received copies rights License. rights terminated permanently reinstated, qualify receive new licenses material section 10.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/LICENSE.html","id":"9-acceptance-not-required-for-having-copies","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"9. Acceptance Not Required for Having Copies.","title":"GNU GENERAL PUBLIC LICENSE","text":"required accept License order receive run copy Program. Ancillary propagation covered work occurring solely consequence using peer--peer transmission receive copy likewise require acceptance. However, nothing License grants permission propagate modify covered work. actions infringe copyright accept License. Therefore, modifying propagating covered work, indicate acceptance License .","code":""},{"path":"https://smorabit.github.io/hdWGCNA/LICENSE.html","id":"10-automatic-licensing-of-downstream-recipients","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"10. Automatic Licensing of Downstream Recipients.","title":"GNU GENERAL PUBLIC LICENSE","text":"time convey covered work, recipient automatically receives license original licensors, run, modify propagate work, subject License. responsible enforcing compliance third parties License. “entity transaction” transaction transferring control organization, substantially assets one, subdividing organization, merging organizations. propagation covered work results entity transaction, party transaction receives copy work also receives whatever licenses work party’s predecessor interest give previous paragraph, plus right possession Corresponding Source work predecessor interest, predecessor can get reasonable efforts. may impose restrictions exercise rights granted affirmed License. example, may impose license fee, royalty, charge exercise rights granted License, may initiate litigation (including cross-claim counterclaim lawsuit) alleging patent claim infringed making, using, selling, offering sale, importing Program portion .","code":""},{"path":"https://smorabit.github.io/hdWGCNA/LICENSE.html","id":"11-patents","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"11. Patents.","title":"GNU GENERAL PUBLIC LICENSE","text":"“contributor” copyright holder authorizes use License Program work Program based. work thus licensed called contributor’s “contributor version”. contributor’s “essential patent claims” patent claims owned controlled contributor, whether already acquired hereafter acquired, infringed manner, permitted License, making, using, selling contributor version, include claims infringed consequence modification contributor version. purposes definition, “control” includes right grant patent sublicenses manner consistent requirements License. contributor grants non-exclusive, worldwide, royalty-free patent license contributor’s essential patent claims, make, use, sell, offer sale, import otherwise run, modify propagate contents contributor version. following three paragraphs, “patent license” express agreement commitment, however denominated, enforce patent (express permission practice patent covenant sue patent infringement). “grant” patent license party means make agreement commitment enforce patent party. convey covered work, knowingly relying patent license, Corresponding Source work available anyone copy, free charge terms License, publicly available network server readily accessible means, must either (1) cause Corresponding Source available, (2) arrange deprive benefit patent license particular work, (3) arrange, manner consistent requirements License, extend patent license downstream recipients. “Knowingly relying” means actual knowledge , patent license, conveying covered work country, recipient’s use covered work country, infringe one identifiable patents country reason believe valid. , pursuant connection single transaction arrangement, convey, propagate procuring conveyance , covered work, grant patent license parties receiving covered work authorizing use, propagate, modify convey specific copy covered work, patent license grant automatically extended recipients covered work works based . patent license “discriminatory” include within scope coverage, prohibits exercise , conditioned non-exercise one rights specifically granted License. may convey covered work party arrangement third party business distributing software, make payment third party based extent activity conveying work, third party grants, parties receive covered work , discriminatory patent license () connection copies covered work conveyed (copies made copies), (b) primarily connection specific products compilations contain covered work, unless entered arrangement, patent license granted, prior 28 March 2007. Nothing License shall construed excluding limiting implied license defenses infringement may otherwise available applicable patent law.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/LICENSE.html","id":"12-no-surrender-of-others-freedom","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"12. No Surrender of Others’ Freedom.","title":"GNU GENERAL PUBLIC LICENSE","text":"conditions imposed (whether court order, agreement otherwise) contradict conditions License, excuse conditions License. convey covered work satisfy simultaneously obligations License pertinent obligations, consequence may convey . example, agree terms obligate collect royalty conveying convey Program, way satisfy terms License refrain entirely conveying Program.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/LICENSE.html","id":"13-use-with-the-gnu-affero-general-public-license","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"13. Use with the GNU Affero General Public License.","title":"GNU GENERAL PUBLIC LICENSE","text":"Notwithstanding provision License, permission link combine covered work work licensed version 3 GNU Affero General Public License single combined work, convey resulting work. terms License continue apply part covered work, special requirements GNU Affero General Public License, section 13, concerning interaction network apply combination .","code":""},{"path":"https://smorabit.github.io/hdWGCNA/LICENSE.html","id":"14-revised-versions-of-this-license","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"14. Revised Versions of this License.","title":"GNU GENERAL PUBLIC LICENSE","text":"Free Software Foundation may publish revised /new versions GNU General Public License time time. new versions similar spirit present version, may differ detail address new problems concerns. version given distinguishing version number. Program specifies certain numbered version GNU General Public License “later version” applies , option following terms conditions either numbered version later version published Free Software Foundation. Program specify version number GNU General Public License, may choose version ever published Free Software Foundation. Program specifies proxy can decide future versions GNU General Public License can used, proxy’s public statement acceptance version permanently authorizes choose version Program. Later license versions may give additional different permissions. However, additional obligations imposed author copyright holder result choosing follow later version.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/LICENSE.html","id":"15-disclaimer-of-warranty","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"15. Disclaimer of Warranty.","title":"GNU GENERAL PUBLIC LICENSE","text":"WARRANTY PROGRAM, EXTENT PERMITTED APPLICABLE LAW. EXCEPT OTHERWISE STATED WRITING COPYRIGHT HOLDERS /PARTIES PROVIDE PROGRAM “” WITHOUT WARRANTY KIND, EITHER EXPRESSED IMPLIED, INCLUDING, LIMITED , IMPLIED WARRANTIES MERCHANTABILITY FITNESS PARTICULAR PURPOSE. ENTIRE RISK QUALITY PERFORMANCE PROGRAM . PROGRAM PROVE DEFECTIVE, ASSUME COST NECESSARY SERVICING, REPAIR CORRECTION.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/LICENSE.html","id":"16-limitation-of-liability","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"16. Limitation of Liability.","title":"GNU GENERAL PUBLIC LICENSE","text":"EVENT UNLESS REQUIRED APPLICABLE LAW AGREED WRITING COPYRIGHT HOLDER, PARTY MODIFIES /CONVEYS PROGRAM PERMITTED , LIABLE DAMAGES, INCLUDING GENERAL, SPECIAL, INCIDENTAL CONSEQUENTIAL DAMAGES ARISING USE INABILITY USE PROGRAM (INCLUDING LIMITED LOSS DATA DATA RENDERED INACCURATE LOSSES SUSTAINED THIRD PARTIES FAILURE PROGRAM OPERATE PROGRAMS), EVEN HOLDER PARTY ADVISED POSSIBILITY DAMAGES.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/LICENSE.html","id":"17-interpretation-of-sections-15-and-16","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"17. Interpretation of Sections 15 and 16.","title":"GNU GENERAL PUBLIC LICENSE","text":"disclaimer warranty limitation liability provided given local legal effect according terms, reviewing courts shall apply local law closely approximates absolute waiver civil liability connection Program, unless warranty assumption liability accompanies copy Program return fee. END TERMS CONDITIONS","code":""},{"path":"https://smorabit.github.io/hdWGCNA/LICENSE.html","id":"how-to-apply-these-terms-to-your-new-programs","dir":"","previous_headings":"","what":"How to Apply These Terms to Your New Programs","title":"GNU GENERAL PUBLIC LICENSE","text":"develop new program, want greatest possible use public, best way achieve make free software everyone can redistribute change terms. , attach following notices program. safest attach start source file effectively state exclusion warranty; file least “copyright” line pointer full notice found. Also add information contact electronic paper mail. program terminal interaction, make output short notice like starts interactive mode: hypothetical commands `show w’ `show c’ show appropriate parts General Public License. course, program’s commands might different; GUI interface, use “box”. also get employer (work programmer) school, , sign “copyright disclaimer” program, necessary. information , apply follow GNU GPL, see https://www.gnu.org/licenses/. GNU General Public License permit incorporating program proprietary programs. program subroutine library, may consider useful permit linking proprietary applications library. want , use GNU Lesser General Public License instead License. first, please read https://www.gnu.org/licenses/--lgpl.html.","code":"<one line to give the program's name and a brief idea of what it does.>     Copyright (C) <year>  <name of author>      This program is free software: you can redistribute it and/or modify     it under the terms of the GNU General Public License as published by     the Free Software Foundation, either version 3 of the License, or     (at your option) any later version.      This program is distributed in the hope that it will be useful,     but WITHOUT ANY WARRANTY; without even the implied warranty of     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the     GNU General Public License for more details.      You should have received a copy of the GNU General Public License     along with this program.  If not, see <https://www.gnu.org/licenses/>. <program>  Copyright (C) <year>  <name of author>     This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.     This is free software, and you are welcome to redistribute it     under certain conditions; type `show c' for details."},{"path":"https://smorabit.github.io/hdWGCNA/articles/ST_basics.html","id":"load-required-libraries","dir":"Articles","previous_headings":"","what":"Load required libraries","title":"hdWGCNA in spatial transcriptomics","text":"First load required R libraries tutorial.","code":"# single-cell analysis package library(Seurat)  # plotting and data science packages library(tidyverse) library(cowplot) library(patchwork)  # co-expression network analysis packages: library(WGCNA) library(hdWGCNA)  # enable parallel processing for network analysis (optional) enableWGCNAThreads(nThreads = 8)  # using the cowplot theme for ggplot theme_set(theme_cowplot())  # set random seed for reproducibility set.seed(12345)"},{"path":"https://smorabit.github.io/hdWGCNA/articles/ST_basics.html","id":"x-visium-dataset","dir":"Articles","previous_headings":"","what":"10X Visium Dataset","title":"hdWGCNA in spatial transcriptomics","text":"section demonstrate hdWGCNA ST datasets using publicly available Visium dataset mouse brain.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/articles/ST_basics.html","id":"load-data","dir":"Articles","previous_headings":"10X Visium Dataset","what":"Load data","title":"hdWGCNA in spatial transcriptomics","text":"use SeuratData download mouse brain ST dataset, process dataset using Seurat. testing, difficulty running InstallData institution’s compute cluster, ran commands locally copied .rds file containing Seurat seurat_vhd cluster subsequent analysis. hdWGCNA requires spatial coordinates stored seurat_obj@meta.data slot. extract image coordinates two samples, merge dataframe, add seurat_obj@meta.data. Specifically, seurat_obj@meta.data must columns named row, col, imagerow, imagecol (shown ), otherwise downstream steps work. IMPORTANT NOTE Seurat version 5.1, image class updated VisiumV1 VisiumV2. changes Seurat loads Visium data spaceranger outputs. hdWGCNA requires spot coorinates array, unfortunately Seurat version 5.1 longer loaded default Load10X_Spatial. spaceranger count outputs file called tissue_positions.csv, contains coordinates. following tutorial dataset, time recommend using Seurat version v5.1. Please see GitHub issue information. using Seurat version older v5.1, coordinates already loaded Seurat seurat_vhd, can use following code add coordinates Seurat metadata slot. using Seurat version v5.1 newer, coordinates loaded Seurat seurat_vhd default. need load tissue_positions.csv file spaceranger output add Seurat seurat_vhd. section example need change code use file path. Seurat seurat_vhd contains one sample, need repeat since sample tissue_positions.csv file. Now perform clustering analysis using Seurat.","code":"# package to install the mouse brain dataset library(SeuratData)  # download the mouse brain ST dataset (stxBrain) SeuratData::InstallData(\"stxBrain\")  # load the anterior and posterior samples brain <- LoadData(\"stxBrain\", type = \"anterior1\") brain$region <- 'anterior' brain2 <- LoadData(\"stxBrain\", type = \"posterior1\") brain2$region <- 'posterior'  # merge into one seurat seurat_vhd seurat_obj <- merge(brain, brain2) seurat_obj$region <- factor(as.character(seurat_obj$region), levels=c('anterior', 'posterior'))  # save unprocessed seurat_vhd saveRDS(seurat_obj, file='mouse_brain_ST_unprocessed.rds') # make a dataframe containing the image coordinates for each sample image_df <- do.call(rbind, lapply(names(seurat_obj@images), function(x){   seurat_obj@images[[x]]@coordinates }))  # merge the image_df with the Seurat metadata new_meta <- merge(seurat_obj@meta.data, image_df, by='row.names')  # fix the row ordering to match the original seurat seurat_vhd rownames(new_meta) <- new_meta$Row.names ix <- match(as.character(colnames(seurat_obj)), as.character(rownames(new_meta))) new_meta <- new_meta[ix,]  # add the new metadata to the seurat seurat_vhd seurat_obj@meta.data <- new_meta  head(image_df) tissue row col imagerow imagecol AAACAAGTATCTCCCA-1_1      1  50 102     7475     8501 AAACACCAATAACTGC-1_1      1  59  19     8553     2788 AAACAGAGCGACTCCT-1_1      1  14  94     3164     7950 AAACAGCTTTCAGAAG-1_1      1  43   9     6637     2099 AAACAGGGTCTATATT-1_1      1  47  13     7116     2375 AAACATGGTGAGAGGA-1_1      1  62   0     8913     1480 # add barcode column to Seurat obj  seurat_obj$barcode <- colnames(seurat_obj)  # update this with the path for your sample. tissue_positions <- read.csv('path/to/tissue_positions.csv') tissue_positions <- subset(tissue_positions, barcode %in% seurat_obj$barcode)  # join the image_df with the Seurat metadata new_meta <- dplyr::left_join(seurat_obj@meta.data, tissue_positions, by='barcode')  # add the new metadata to the seurat seurat_vhd seurat_obj$row <- new_meta$array_row  seurat_obj$imagerow <- new_meta$pxl_row_in_fullres seurat_obj$col <- new_meta$array_col seurat_obj$imagecol <- new_meta$pxl_col_in_fullres # normalization, feature selection, scaling, and PCA seurat_obj <- seurat_obj %>%   NormalizeData() %>%   FindVariableFeatures() %>%   ScaleData() %>%   RunPCA()  # Louvain clustering and umap seurat_obj <- FindNeighbors(seurat_obj, dims = 1:30) seurat_obj <- FindClusters(seurat_obj,verbose = TRUE) seurat_obj <- RunUMAP(seurat_obj, dims = 1:30)  # set factor level for anterior / posterior seurat_obj$region <- factor(as.character(seurat_obj$region), levels=c('anterior', 'posterior'))  # show the UMAP p1 <- DimPlot(seurat_obj, label=TRUE, reduction = \"umap\", group.by = \"seurat_clusters\") + NoLegend() p1 p2 <- SpatialDimPlot(seurat_obj, label = TRUE, label.size = 3) p2 # add annotations to Seurat seurat_vhd annotations <- read.csv('annotations.csv') ix <- match(seurat_obj$seurat_clusters, annotations$seurat_clusters) seurat_obj$annotation <- annotations$annotation[ix]  # set idents Idents(seurat_obj) <- seurat_obj$annotation  p3 <- SpatialDimPlot(seurat_obj, label = TRUE, label.size = 3) p3 + NoLegend()"},{"path":"https://smorabit.github.io/hdWGCNA/articles/ST_basics.html","id":"construct-metaspots","dir":"Articles","previous_headings":"10X Visium Dataset","what":"Construct metaspots","title":"hdWGCNA in spatial transcriptomics","text":"Visium ST generates sparse gene expression profiles spot, thus introducing potential pitfalls single-cell data co-expression network analysis. alleviate issues, hdWGCNA includes data aggregation approach produce spatial metaspots, similar metacell algorithm. approach aggregates neighboring spots based spatial coordinates rather transcriptomes. procedure performed hdWGCNA using MetaspotsByGroups function. set data hdWGCNA runMetaspotsByGroups. Similar MetacellsByGroups, group.parameter slices Seurat seurat_vhd construct metaspots separately group. just grouping ST slides perform step separately anterior posterior sample, specify cluster anatomical regions well suit analysis. metaspot seurat_vhd used everywhere metacell seurat_vhd used downstream analysis. example, extract metaspot seurat_vhd, can run GetMetacellseurat_vhd function.","code":"seurat_obj <- SetupForWGCNA(   seurat_obj,   gene_select = \"fraction\",   fraction = 0.05,   wgcna_name = \"vis\" )  seurat_obj <- MetaspotsByGroups(   seurat_obj,   group.by = c(\"region\"),   ident.group = \"region\",   assay = 'Spatial' ) seurat_obj  <- NormalizeMetacells(seurat_obj) m_obj <- GetMetacellseurat_vhd(seurat_obj) m_obj An seurat_vhd of class Seurat 31053 features across 1505 samples within 1 assay Active assay: Spatial (31053 features, 0 variable features)"},{"path":"https://smorabit.github.io/hdWGCNA/articles/ST_basics.html","id":"co-expression-network-analysis","dir":"Articles","previous_headings":"10X Visium Dataset","what":"Co-expression network analysis","title":"hdWGCNA in spatial transcriptomics","text":"Now ready perform co-expression network analysis using identical pipeline single-cell workflow. analysis, performing brain-wide network analysis using spots regions, analysis adjusted perform network analysis specific regions. Next, compute module eigengenes (MEs) eigengene-based connectivities (kMEs) using ModuleEigengenes ModuleConnectivity functions respectively. reset module names prefix “SM” (spatial modules). step optional.","code":"# set up the expression matrix, set group.by and group_name to NULL to include all spots seurat_obj  <- SetDatExpr(   seurat_obj,   group.by=NULL,   group_name = NULL )  # test different soft power thresholds seurat_obj <- TestSoftPowers(seurat_obj) plot_list <- PlotSoftPowers(seurat_obj)  wrap_plots(plot_list, ncol=2) # construct co-expression network: seurat_obj <- ConstructNetwork(   seurat_obj,   tom_name='test',   overwrite_tom=TRUE )  # plot the dendrogram PlotDendrogram(seurat_obj, main='Spatial hdWGCNA dendrogram') seurat_obj <- ModuleEigengenes(seurat_obj) seurat_obj <- ModuleConnectivity(seurat_obj) seurat_obj <- ResetModuleNames(   seurat_obj,   new_name = \"SM\" )"},{"path":"https://smorabit.github.io/hdWGCNA/articles/ST_basics.html","id":"data-visualization","dir":"Articles","previous_headings":"10X Visium Dataset","what":"Data visualization","title":"hdWGCNA in spatial transcriptomics","text":"visualize module eigengenes using Seurat functions DotPlot SpatialFeaturePlot. network visualization, please refer Network visualization tutorial. can visualize MEs directly spatial coordinates using SpatialFeaturePlot. Next visualize co-expression network using UMAP. Please refer network visualization tutorial details visualizing co-expression network.","code":"# get module eigengenes and gene-module assignment tables MEs <- GetMEs(seurat_obj) modules <- GetModules(seurat_obj) mods <- levels(modules$module); mods <- mods[mods != 'grey']  # add the MEs to the seurat metadata so we can plot it with Seurat functions seurat_obj@meta.data <- cbind(seurat_obj@meta.data, MEs)  # plot with Seurat's DotPlot function p <- DotPlot(seurat_obj, features=mods, group.by = 'annotation', dot.min=0.1)  # flip the x/y axes, rotate the axis labels, and change color scheme: p <- p +   coord_flip() +   RotatedAxis() +   scale_color_gradient2(high='red', mid='grey95', low='blue') +   xlab('') + ylab('')  p p <- SpatialFeaturePlot(   seurat_obj,   features = mods,   alpha = c(0.1, 1),   ncol = 8 )  p # perform UMAP embedding on the co-expression network seurat_obj <- RunModuleUMAP(   seurat_obj,   n_hubs = 5,   n_neighbors=15,   min_dist=0.3,   spread=1 )  # make the network plot ModuleUMAPPlot(   seurat_obj,   edge.alpha=0.5,   sample_edges=TRUE,   keep_grey_edges=FALSE,   edge_prop=0.075,    label_hubs=5  )"},{"path":"https://smorabit.github.io/hdWGCNA/articles/ST_basics.html","id":"curio-seeker-dataset","dir":"Articles","previous_headings":"","what":"Curio Seeker Dataset","title":"hdWGCNA in spatial transcriptomics","text":"section perform similar analysis using mouse hippocampus dataset Curio Bioscience. dataset publicly available, obtained dataset directly Curio filling form website. Curio provided fully processed Seurat seurat_vhd, tutorial simply using Seurat seurat_vhd clustering provided.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/articles/ST_basics.html","id":"load-dataset","dir":"Articles","previous_headings":"Curio Seeker Dataset","what":"Load dataset","title":"hdWGCNA in spatial transcriptomics","text":"First load Seurat seurat_vhd containing mouse hippocampus dataset provided Curio. also make plots show clustering transcriptome space (UMAP reduction) biological coordinates. Note dataset provides “dim reduction” called “SPATIAL” contains 2D biological coordinates. plot little crowded can make another DimPlot split cluster see cluster .","code":"# load the Seurat seurat_vhd seurat_curio <- readRDS(paste0(data_dir, 'curio_datasets/Mouse_hippocampus_v1pt1/Mouse_hippocampus_seurat.rds'))  # make a dimplot in transcriptome space p1 <- DimPlot(seurat_curio, label=TRUE, reduction = \"umap\") +   NoLegend() + umap_theme() + ggtitle('UMAP')  # make a dimplot in biological space p2 <- DimPlot(seurat_curio, reduction='SPATIAL', pt.size=0.5) +    umap_theme() + ggtitle('Spatial')  p1 | p2 p <- DimPlot(   seurat_curio,    split.by='seurat_clusters',   reduction = 'SPATIAL',   ncol=6 ) + NoLegend() + umap_theme()   p"},{"path":"https://smorabit.github.io/hdWGCNA/articles/ST_basics.html","id":"construct-metacells-with-metacellsbygroups","dir":"Articles","previous_headings":"Curio Seeker Dataset","what":"Construct Metacells with MetacellsByGroups","title":"hdWGCNA in spatial transcriptomics","text":"Visium ST uses grid spots assign molecular barcodes space, Curio Seeker uses small beads capture transcriptome information 10 microns. Importantly, beads regularly spaced like Visium. Therefore, MetaspotsByGroups function used Visium dataset appropriate Curio Seeker data. Instead, use MetacellsByGroups specify reduction spatial information, cells close together biological space aggregated metacells. can calculate average X Y coordinates metacell plot check aggregated based spatial proximityfor cluster expect.","code":"# Change the default assay to \"RNA\", SCTransform is generally not recommended for hdWGCNA. seurat_curio <- DefaultAssay(seurat_curio, 'RNA')  seurat_curio <- SetupForWGCNA(   seurat_curio,   gene_select = \"fraction\",    fraction = 0.01,    wgcna_name = \"curio\"  )  # construct metacells  in each group seurat_curio <- MetacellsByGroups(   seurat_obj = seurat_curio,   group.by = c(\"seurat_clusters\"),    ident.group = 'seurat_clusters',   reduction = 'SPATIAL',   k = 50,    max_shared = 15,    assay = 'RNA' )  # normalize metacell expression matrix: seurat_curio <- NormalizeMetacells(seurat_curio) # get the metacell seurat_vhd m_obj <- GetMetacellseurat_vhd(seurat_curio) m_obj$seurat_clusters <- factor(   m_obj$seurat_clusters,   levels = levels(seurat_curio$seurat_clusters) )  # get the image coordinates from the seurat obj and add to the metadata spatial_coords <- seurat_curio@images$slice1@coordinates seurat_curio@meta.data$spatial_x <- spatial_coords$x * -1 seurat_curio@meta.data$spatial_y <- spatial_coords$y seurat_curio$barcode <- colnames(seurat_curio)  # loop over each metacell and calculate the average X and Y meta_spatial_coords <- do.call(rbind, lapply(1:ncol(m_obj), function(i){   x <- m_obj@meta.data$cells_merged[i]   cur_bcs <- str_split(x, ',')[[1]]   cur_df <- subset(seurat_curio@meta.data, barcode %in% cur_bcs)   cur_x <- mean(cur_df$spatial_x)   cur_y <- mean(cur_df$spatial_y)   data.frame(spatial_1 = cur_y, spatial_2=cur_x) })) rownames(meta_spatial_coords) <- colnames(m_obj)  # add this as a dim reduct m_obj@reductions$spatial <- CreateDimReducseurat_vhd(   embeddings = as.matrix(meta_spatial_coords),   key = 'spatial' )  p <- DimPlot(   m_obj,    split.by='seurat_clusters',   reduction = 'spatial',   ncol=6 ) + NoLegend() + umap_theme()   p"},{"path":"https://smorabit.github.io/hdWGCNA/articles/ST_basics.html","id":"co-expression-network-analysis-1","dir":"Articles","previous_headings":"Curio Seeker Dataset","what":"Co-expression network analysis","title":"hdWGCNA in spatial transcriptomics","text":"Now metacells, next carry co-expression network analysis hdWGCNA, similar done . perform network analysis cluster 6, appears contain pyramidal layer hippocampus granular layer dentate gyrus. Next plot expression modules tissue coordinates. concludes part tutorial Curio dataset, proceed perform downstream analysis data visualization.","code":"# set up the expression matrix seurat_curio  <- SetDatExpr(   seurat_curio,   group.by='seurat_clusters',   group_name = '6' )  # test different soft power thresholds seurat_curio <- TestSoftPowers(seurat_curio)  # construct co-expression network: seurat_curio <- ConstructNetwork(   seurat_curio,   tom_name='curio',   overwrite_tom=TRUE )  # compute module eigengenes & connectivity seurat_curio <- ModuleEigengenes(seurat_curio) seurat_curio <- ModuleConnectivity(   seurat_curio,   group.by = 'seurat_clusters',    group_name = '6' )  # plot the dendrogram  PlotDendrogram(seurat_curio, main='Curio hdWGCNA dendrogram') plot_list <- ModuleFeaturePlot(   seurat_curio,   reduction = 'SPATIAL',   restrict_range=FALSE )  wrap_plots(plot_list, ncol=4)"},{"path":"https://smorabit.github.io/hdWGCNA/articles/ST_basics.html","id":"x-visium-hd-dataset","dir":"Articles","previous_headings":"","what":"10X Visium HD Dataset","title":"hdWGCNA in spatial transcriptomics","text":"perform similar analysis using Visium HD, second major version sequencing-based ST 10X Genomics. similar technology standard Visium, main difference “spots” much smaller gap . Visium HD spots closer single-cell resolution, however spots may still span one cell, furthermore one spot subcellular. Overall, workflow similar one shown Curio Seeker dataset.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/articles/ST_basics.html","id":"load-dataset-1","dir":"Articles","previous_headings":"10X Visium HD Dataset","what":"Load dataset","title":"hdWGCNA in spatial transcriptomics","text":"mouse brain Visium HD dataset can downloaded diectly 10X Genomics link.","code":"# use the 008um resolution for this tutorial seurat_vhd <- Load10X_Spatial(data.dir='path/to/dataset/square_008um/')"},{"path":"https://smorabit.github.io/hdWGCNA/articles/ST_basics.html","id":"clustering-analysis","dir":"Articles","previous_headings":"10X Visium HD Dataset","what":"Clustering analysis","title":"hdWGCNA in spatial transcriptomics","text":"follow Seurat Visium HD tutorial perform basic clustering analysis. practice, perform clustering analysis QC best suits dataset, simply use Seurat convenience demonstrate hdWGCNA.","code":"seurat_vhd <- NormalizeData(seurat_vhd) seurat_vhd <- FindVariableFeatures(seurat_vhd) seurat_vhd <- ScaleData(seurat_vhd) seurat_vhd <- RunPCA(seurat_vhd) seurat_vhd <- FindNeighbors(seurat_vhd, reduction = \"pca\", dims = 1:30) seurat_vhd <- FindClusters(seurat_vhd)  p <- DimPlot(   seurat_vhd,    split.by='seurat_clusters',   reduction = 'spatial',   ncol=9 ) + NoLegend() + umap_theme()   p"},{"path":"https://smorabit.github.io/hdWGCNA/articles/ST_basics.html","id":"construct-metacells-with-metacellsbygroups-1","dir":"Articles","previous_headings":"10X Visium HD Dataset","what":"Construct Metacells with MetacellsByGroups","title":"hdWGCNA in spatial transcriptomics","text":"set genes use co-expression network analysis (variable features), construct metacells. Visium HD, merge spatially proximal spots using MetacellsByGroups function instead MetaspotsByGroups, used standard Visium. order us use MetacellsByGroups spatial data, similar Curio dataset, need create “dimensionality reduction” Seurat object contains spatial coordinates. can calculate average X Y coordinates metacell plot check aggregated based spatial proximityfor cluster expect.","code":"# create the spatial reduction coords <- as.matrix(GetTissueCoordinates(seurat_vhd)[,c('x', 'y')]) colnames(coords) <- c('spatial_1', 'spatial_2') seurat_vhd@reductions$spatial <- CreateDimReducObject(   embeddings = coords,   assay = 'RNA',   key = 'spatial_' )  seurat_vhd <- SetupForWGCNA(   seurat_vhd,   gene_select = \"variable\",    wgcna_name = \"vhd\"  ) length(GetWGCNAGenes(seurat_vhd))  # construct metacells  in each group seurat_vhd <- MetacellsByGroups(   seurat_obj = seurat_vhd,   group.by = c(\"seurat_clusters\"),    ident.group = 'seurat_clusters',   reduction = 'spatial',   k = 50,    max_shared = 15 ) # get the metacell object m_obj <- GetMetacellObject(seurat_vhd) m_obj$seurat_clusters <- factor(   m_obj$seurat_clusters,   levels = levels(seurat_vhd$seurat_clusters) )  # get the image coordinates from the seurat obj and add to the metadata spatial_coords <- as.data.frame(seurat_vhd@reductions$spatial@cell.embeddings) seurat_vhd@meta.data$spatial_x <- spatial_coords$Spatial_1 * -1 seurat_vhd@meta.data$spatial_y <- spatial_coords$Spatial_2 seurat_vhd$barcode <- colnames(seurat_vhd)  # loop over each metacell and calculate the average X and Y meta_spatial_coords <- do.call(rbind, lapply(1:ncol(m_obj), function(i){   x <- m_obj@meta.data$cells_merged[i]   cur_bcs <- str_split(x, ',')[[1]]   cur_df <- subset(seurat_vhd@meta.data, barcode %in% cur_bcs)   cur_x <- mean(cur_df$spatial_x)   cur_y <- mean(cur_df$spatial_y)   data.frame(spatial_1 = cur_y, spatial_2=cur_x) })) rownames(meta_spatial_coords) <- colnames(m_obj)  # add this as a dim reduct m_obj@reductions$spatial <- CreateDimReducObject(   embeddings = as.matrix(meta_spatial_coords),   key = 'spatial' )  p <- DimPlot(   m_obj,    split.by='seurat_clusters',   reduction = 'spatial',   ncol=9 ) + NoLegend() + umap_theme()   p"},{"path":"https://smorabit.github.io/hdWGCNA/articles/ST_basics.html","id":"co-expression-network-analysis-2","dir":"Articles","previous_headings":"10X Visium HD Dataset","what":"Co-expression network analysis","title":"hdWGCNA in spatial transcriptomics","text":"now ready perform co-expression network analysis, similar . Next plot expression modules spatial coordinates. concludes part tutorial Visium HD dataset, proceed perform downstream analysis data visualization.","code":"# set up the expression matrix seurat_vhd  <- SetDatExpr(seurat_vhd)  # test different soft power thresholds seurat_vhd <- TestSoftPowers(seurat_vhd)  # construct co-expression network: seurat_vhd <- ConstructNetwork(   seurat_vhd,   tom_name='vhd' )  # compute module eigengenes & connectivity seurat_vhd <- ModuleEigengenes(seurat_vhd) seurat_vhd <- ModuleConnectivity(   seurat_vhd )  # plot the dendrogram PlotDendrogram(seurat_vhd, main='Visium HD hdWGCNA dendrogram') plot_list <- ModuleFeaturePlot(   seurat_vhd,   reduction = 'spatial',   restrict_range=FALSE )  wrap_plots(plot_list, ncol=3)"},{"path":"https://smorabit.github.io/hdWGCNA/articles/ST_basics.html","id":"conclusion-and-next-steps","dir":"Articles","previous_headings":"","what":"Conclusion and next steps","title":"hdWGCNA in spatial transcriptomics","text":"tutorial demonstrated core functions performing co-expression network analysis two types ST datasets: Visium Slide-Seq. encourage explore tutorials downstream analysis co-expression networks.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/articles/basic_tutorial.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"hdWGCNA in single-cell data","text":"tutorial covers basics using hdWGCNA perform co-expression network analysis single-cell data. , start processed single-nucleus RNA-seq (snRNA-seq) dataset human cortical samples publication. dataset already fully processed using standard single-cell transcritpomics analysis pipeline Seurat Scanpy. like follow tutorial using dataset, first need satisfy following prerequisites: single-cell single-nucleus transcriptomics dataset Seurat format. Normalize gene expression matrix NormalizeData. Identify highly variable genes VariableFeatures. Scale normalized expression data ScaleData Perform dimensionality reduction RunPCA batch correction needed RunHarmony. Non-linear dimensionality reduction RunUMAP visualizations. Group cells clusters (FindNeighbors FindClusters). example running prerequisite data processing steps can found Seurat Guided Clustering Tutorial. Additionally, lot WGCNA-specific terminology acronyms, clarified table. Important note: re-generate tutorial figures update hdWGCNA, figures generate slightly different shown following along dataset.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/articles/basic_tutorial.html","id":"download-the-tutorial-data","dir":"Articles","previous_headings":"","what":"Download the tutorial data","title":"hdWGCNA in single-cell data","text":"purpose tutorial, provide processed Seurat object control human brains Zhou et al 2020 study.","code":"wget https://swaruplab.bio.uci.edu/public_data/Zhou_2020.rds"},{"path":"https://smorabit.github.io/hdWGCNA/articles/basic_tutorial.html","id":"load-the-dataset-and-required-libraries","dir":"Articles","previous_headings":"","what":"Load the dataset and required libraries","title":"hdWGCNA in single-cell data","text":"First load single-cell dataset required R libraries tutorial. plot UMAP colored cell type just check loaded data correctly, make sure grouped cells clusters cell types.","code":"# single-cell analysis package library(Seurat)  # plotting and data science packages library(tidyverse) library(cowplot) library(patchwork)  # co-expression network analysis packages: library(WGCNA) library(hdWGCNA)  # using the cowplot theme for ggplot theme_set(theme_cowplot())  # set random seed for reproducibility set.seed(12345)  # optionally enable multithreading enableWGCNAThreads(nThreads = 8)  # load the Zhou et al snRNA-seq dataset seurat_obj <- readRDS('Zhou_2020.rds') p <- DimPlot(seurat_obj, group.by='cell_type', label=TRUE) +    umap_theme() + ggtitle('Zhou et al Control Cortex') + NoLegend()  p"},{"path":"https://smorabit.github.io/hdWGCNA/articles/basic_tutorial.html","id":"set-up-seurat-object-for-wgcna","dir":"Articles","previous_headings":"","what":"Set up Seurat object for WGCNA","title":"hdWGCNA in single-cell data","text":"running hdWGCNA, first set Seurat object. information computed hdWGCNA stored Seurat object’s @misc slot. single Seurat object can hold multiple hdWGCNA experiments, example representing different cell types single-cell dataset. Notably, since consider hdWGCNA downstream data analysis step, support subsetting Seurat object SetupForWGCNA run. set Seurat object using SetupForWGCNA function, specifying name hdWGNCA experiment. function also selects genes used WGCNA. user can select genes using three different approaches using gene_select parameter: variable: use genes stored Seurat object’s VariableFeatures. fraction: use genes expressed certain fraction cells whole dataset group cells, specified group.. custom: use genes specified custom list. example, select genes expressed least 5% cells dataset, name hdWGCNA experiment “tutorial”.","code":"seurat_obj <- SetupForWGCNA(   seurat_obj,   gene_select = \"fraction\", # the gene selection approach   fraction = 0.05, # fraction of cells that a gene needs to be expressed in order to be included   wgcna_name = \"tutorial\" # the name of the hdWGCNA experiment )"},{"path":"https://smorabit.github.io/hdWGCNA/articles/basic_tutorial.html","id":"construct-metacells","dir":"Articles","previous_headings":"","what":"Construct metacells","title":"hdWGCNA in single-cell data","text":"set Seurat object, first step running hdWGCNA pipeine hdWGCNA construct metacells single-cell dataset. Briefly, metacells aggregates small groups similar cells originating biological sample origin. k-Nearest Neighbors (KNN) algorithm used identify groups similar cells aggregate, average summed expression cells computed, thus yielding metacell gene expression matrix. sparsity metacell expression matrix considerably reduced compared original expression matrix, therefore preferable use. originally motivated use metacells place original single cells correlation network approaches WGCNA sensitive data sparsity. hdWGCNA includes function MetacellsByGroups construct metacell expression matrices given single-cell dataset. function constructs new Seurat object metacell dataset stored internally hdWGCNA experiment. group.parameter determines groups metacells constructed . want construct metacells cells came biological sample origin, critical pass information hdWGCNA via group.parameter. Additionally, usually construct metacells cell type separately. Thus, example, grouping Sample cell_type achieve desired result. number cells aggregated k tuned based size input dataset, general lower number k can used small datasets. generally use k values 20 75. dataset used tutorial 40,039 cells, ranging 890 8,188 biological sample, used k=25. amount allowable overlap metacells can tuned using max_shared argument. range K values suitable reducing sparsity retaining cellular heterogeneity given dataset, rather single optimal value. Note: found metacell aggregation approach yield good results extremely underrepresented cell types. example, dataset, brain vascular cells (pericytes endothelial cells) least represented, excluded analysis. MetacellsByGroups parameter min_cells exclude groups smaller specified number cells. Errors likely arise selected value min_cells low. construct metacells normalize resulting expression matrix using following code: Since store Metacell expression information Seurat object, can run Seurat functions metacell data. can get metacell object hdWGCNA experiment using GetMetacellObject. Additionally, included wrapper functions apply Seurat workflow metacell object within hdWGCNA experiment. apply wrapper functions process metacell object visualize aggregated expression profiles two dimensions UMAP.","code":"# construct metacells  in each group seurat_obj <- MetacellsByGroups(   seurat_obj = seurat_obj,   group.by = c(\"cell_type\", \"Sample\"), # specify the columns in seurat_obj@meta.data to group by   reduction = 'harmony', # select the dimensionality reduction to perform KNN on   k = 25, # nearest-neighbors parameter   max_shared = 10, # maximum number of shared cells between two metacells   ident.group = 'cell_type' # set the Idents of the metacell seurat object )  # normalize metacell expression matrix: seurat_obj <- NormalizeMetacells(seurat_obj) metacell_obj <- GetMetacellObject(seurat_obj) seurat_obj <- NormalizeMetacells(seurat_obj) seurat_obj <- ScaleMetacells(seurat_obj, features=VariableFeatures(seurat_obj)) seurat_obj <- RunPCAMetacells(seurat_obj, features=VariableFeatures(seurat_obj)) seurat_obj <- RunHarmonyMetacells(seurat_obj, group.by.vars='Sample') seurat_obj <- RunUMAPMetacells(seurat_obj, reduction='harmony', dims=1:15)   p1 <- DimPlotMetacells(seurat_obj, group.by='cell_type') + umap_theme() + ggtitle(\"Cell Type\") p2 <- DimPlotMetacells(seurat_obj, group.by='Sample') + umap_theme() + ggtitle(\"Sample\")  p1 | p2"},{"path":"https://smorabit.github.io/hdWGCNA/articles/basic_tutorial.html","id":"co-expression-network-analysis","dir":"Articles","previous_headings":"","what":"Co-expression network analysis","title":"hdWGCNA in single-cell data","text":"section discuss perform co-expression network analysis hdWGNCA inhibitory neuron (INH) cells example dataset.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/articles/basic_tutorial.html","id":"set-up-the-expression-matrix","dir":"Articles","previous_headings":"Co-expression network analysis","what":"Set up the expression matrix","title":"hdWGCNA in single-cell data","text":"specify expression matrix use network analysis. Since want include inhibitory neurons, subset expression data prior constructing network. hdWGCNA includes SetDatExpr function store transposed expression matrix given group cells used downstream network analysis. metacell expression matrix used default (use_metacells=TRUE), hdWGCNA allow single-cell expression matrix used desired.. function allows user specify slot take expression matrix , example user wanted apply SCTransform normalization instead NormalizeData. Suppose want perform co-expression network analysis one cell type cluster simultaneously. SetDatExpr can run slighly different settings achieve desired result passing character vector group_name parameter.","code":"seurat_obj <- SetDatExpr(   seurat_obj,   group_name = \"INH\", # the name of the group of interest in the group.by column   group.by='cell_type', # the metadata column containing the cell type info. This same column should have also been used in MetacellsByGroups   assay = 'RNA', # using RNA assay   slot = 'data' # using normalized data ) seurat_obj <- SetDatExpr(   seurat_obj,   group_name = c(\"INH\", \"EX\"),   group.by='cell_type' )"},{"path":"https://smorabit.github.io/hdWGCNA/articles/basic_tutorial.html","id":"select-soft-power-threshold","dir":"Articles","previous_headings":"Co-expression network analysis","what":"Select soft-power threshold","title":"hdWGCNA in single-cell data","text":"Next select “soft power threshold”. extremely important step hdWGNCA pipleine (vanilla WGCNA). hdWGCNA constructs gene-gene correlation adjacency matrix infer co-expression relationships genes. correlations raised power reduce amount noise present correlation matrix, thereby retaining strong connections removing weak connections. Therefore, critical determine proper value soft power threshold. include function TestSoftPowers perform parameter sweep different soft power thresholds. function helps us guide choice soft power threshold constructing co-expression network inspecting resulting network topology different power values. co-expression network scale-free topology, therefore TestSoftPowers function models closely co-expression network resembles scale-free graph different soft power thresholds. Furthermore, include function PlotSoftPowers visualize results parameter sweep. following code performs parameter sweep outputs summary figure.  general guidance WGCNA hdWGCNA pick lowest soft power threshold Scale Free Topology Model Fit greater equal 0.8, case select soft power threshold 9. Later , ConstructNetwork automatically select soft power threshold user provide one. Tthe output table parameter sweep stored hdWGCNA experiment can accessed using GetPowerTable function inspection:","code":"# Test different soft powers: seurat_obj <- TestSoftPowers(   seurat_obj,   networkType = 'signed' # you can also use \"unsigned\" or \"signed hybrid\" )  # plot the results: plot_list <- PlotSoftPowers(seurat_obj)  # assemble with patchwork wrap_plots(plot_list, ncol=2) power_table <- GetPowerTable(seurat_obj) head(power_table) Power   SFT.R.sq     slope truncated.R.sq   mean.k. median.k.    max.k. 1     1 0.26110351 11.889729      0.9546294 6525.7417 6532.2923 7219.7053 2     2 0.01631495  1.375111      0.9935408 3434.0090 3421.8601 4293.1289 3     3 0.04178826 -1.487314      0.9784280 1840.1686 1817.2352 2651.0575 4     4 0.29769630 -3.249674      0.9588046 1003.7962  978.3657 1719.7194 5     5 0.55846894 -4.060086      0.9617106  557.3639  533.2201 1157.0353 6     6 0.70513240 -4.195496      0.9696135  315.0681  295.1368  804.1011"},{"path":"https://smorabit.github.io/hdWGCNA/articles/basic_tutorial.html","id":"construct-co-expression-network","dir":"Articles","previous_headings":"Co-expression network analysis","what":"Construct co-expression network","title":"hdWGCNA in single-cell data","text":"now everything need construct co-expression network. use hdWGCNA function ConstructNetwork, calls WGCNA function blockwiseConsensusModules hood. function quite parameters play advanced user, selected default parameters work well many single-cell datasets. parameters blockwiseConsensusModules can passed directly ConstructNetwork parameter names. following code construtcts co-expression network using soft power threshold selected : hdWGCNA also includes function PlotDendrogram visualize WGCNA dendrogram, common visualization show different co-expression modules resulting network analysis. leaf dendrogram represents single gene, color bottom indicates co-expression module assignment. Importantly, “grey” module consists genes grouped co-expression module. grey module ignored downstream analysis interpretation.","code":"# construct co-expression network: seurat_obj <- ConstructNetwork(   seurat_obj,   tom_name = 'INH' # name of the topoligical overlap matrix written to disk ) PlotDendrogram(seurat_obj, main='INH hdWGCNA Dendrogram')"},{"path":"https://smorabit.github.io/hdWGCNA/articles/basic_tutorial.html","id":"optional-inspect-the-topoligcal-overlap-matrix-tom","dir":"Articles","previous_headings":"Co-expression network analysis","what":"Optional: inspect the topoligcal overlap matrix (TOM)","title":"hdWGCNA in single-cell data","text":"hdWGCNA represents co-expression network topoligcal overlap matrix (TOM). square matrix genes genes, value topoligcal overlap genes. TOM written disk running ConstructNetwork, can load R using GetTOM function. Advanced users may wish inspect TOM custom downstream analyses.","code":"TOM <- GetTOM(seurat_obj)"},{"path":"https://smorabit.github.io/hdWGCNA/articles/basic_tutorial.html","id":"module-eigengenes-and-connectivity","dir":"Articles","previous_headings":"","what":"Module Eigengenes and Connectivity","title":"hdWGCNA in single-cell data","text":"section cover compute module eigengenes single cells, compute eigengene-based connectivity gene.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/articles/basic_tutorial.html","id":"compute-harmonized-module-eigengenes","dir":"Articles","previous_headings":"Module Eigengenes and Connectivity","what":"Compute harmonized module eigengenes","title":"hdWGCNA in single-cell data","text":"Module Eigengenes (MEs) commonly used metric summarize gene expression profile entire co-expression module. Briefly, module eigengenes computed performing principal component analysis (PCA) subset gene expression matrix comprising module. first PC PCA matrices MEs. Dimensionality reduction techniques hot topic single-cell genomics. well known technical artifacts can muddy analysis single-cell datasets, years many methods aim reduce effects artifacts. Therefore stands reason MEs subject technical artifacts well, hdWGCNA seeks alleviate effects. hdWGCNA includes function ModuleEigengenes compute module eigengenes single cells. Additionally, allow user apply Harmony batch correction MEs, yielding harmonized module eigengenes (hMEs). following code performs module eigengene computation harmonizing Sample origin using group..vars parameter. matrices stored matrix row cell column module. matrix can extracted Seurat object using GetMEs function, retrieves hMEs default.","code":"# need to run ScaleData first or else harmony throws an error: #seurat_obj <- ScaleData(seurat_obj, features=VariableFeatures(seurat_obj))  # compute all MEs in the full single-cell dataset seurat_obj <- ModuleEigengenes(  seurat_obj,  group.by.vars=\"Sample\" ) # harmonized module eigengenes: hMEs <- GetMEs(seurat_obj)  # module eigengenes: MEs <- GetMEs(seurat_obj, harmonized=FALSE)"},{"path":"https://smorabit.github.io/hdWGCNA/articles/basic_tutorial.html","id":"compute-module-connectivity","dir":"Articles","previous_headings":"Module Eigengenes and Connectivity","what":"Compute module connectivity","title":"hdWGCNA in single-cell data","text":"co-expression network analysis, often want focus “hub genes”, highly connected within module. Therefore wish determine eigengene-based connectivity, also known kME, gene. hdWGCNA includes ModuleConnectivity compute kME values full single-cell dataset, rather metacell dataset. function essentially computes pairwise correlations genes module eigengenes. kME can computed cells dataset, recommend computing kME cell type group previously used run ConstructNetwork. convenience, re-name hdWGCNA modules indicate inhibitory neuron group. information renaming modules can found module customization tutorial. can visualize genes module ranked kME using PlotKMEs function.","code":"# compute eigengene-based connectivity (kME): seurat_obj <- ModuleConnectivity(   seurat_obj,   group.by = 'cell_type', group_name = 'INH' ) # rename the modules seurat_obj <- ResetModuleNames(   seurat_obj,   new_name = \"INH-M\" ) # plot genes ranked by kME for each module p <- PlotKMEs(seurat_obj, ncol=5)  p"},{"path":"https://smorabit.github.io/hdWGCNA/articles/basic_tutorial.html","id":"getting-the-module-assignment-table","dir":"Articles","previous_headings":"Module Eigengenes and Connectivity","what":"Getting the module assignment table","title":"hdWGCNA in single-cell data","text":"hdWGCNA allows easy access module assignment table using GetModules function. table consists three columns: gene_name stores gene’s symbol ID, module stores gene’s module assignment, color stores color mapping module, used many downstream plotting steps. ModuleConnectivity called hdWGCNA experiment, table additional columns kME module. table top N hub genes sorted kME can extracted using GetHubGenes function. wraps critical analysis steps hdWGCNA, remember save output.","code":"# get the module assignment table: modules <- GetModules(seurat_obj) %>% subset(module != 'grey')  # show the first 6 columns: head(modules[,1:6]) gene_name module     color   kME_grey  kME_INH-M1 kME_INH-M2 LINC01409 LINC01409 INH-M1       red 0.06422496  0.14206189 0.02146438 INTS11       INTS11 INH-M2      blue 0.19569750  0.04996486 0.22687525 CCNL2         CCNL2 INH-M3     green 0.21124081  0.04668528 0.20013727 GNB1           GNB1 INH-M4 lightcyan 0.24093763  0.03203763 0.20114899 TNFRSF14   TNFRSF14 INH-M5    yellow 0.01315166  0.02388175 0.02342308 TPRG1L       TPRG1L INH-M6 turquoise 0.10138479 -0.05137751 0.12394048 # get hub genes hub_df <- GetHubGenes(seurat_obj, n_hubs = 10)  head(hub_df) gene_name module       kME 1 ANKRD30BL INH-M1 0.3711414 2   CACNA1B INH-M1 0.3694937 3     GRIN1 INH-M1 0.3318094 4   BMS1P14 INH-M1 0.3304103 5 LINC00342 INH-M1 0.3252982 6 LINC01278 INH-M1 0.3100343 saveRDS(seurat_obj, file='hdWGCNA_object.rds')"},{"path":"https://smorabit.github.io/hdWGCNA/articles/basic_tutorial.html","id":"compute-hub-gene-signature-scores","dir":"Articles","previous_headings":"Module Eigengenes and Connectivity > Getting the module assignment table","what":"Compute hub gene signature scores","title":"hdWGCNA in single-cell data","text":"Gene scoring analysis popular method single-cell transcriptomics computing score overall signature set genes. can use methods alternatives module eigengenes. hdWGCNA includes function ModuleExprScore compute gene scores give number genes module, using either UCell Seurat algorithm.","code":"# compute gene scoring for the top 25 hub genes by kME for each module # with UCell method library(UCell) seurat_obj <- ModuleExprScore(   seurat_obj,   n_genes = 25,   method='UCell' )"},{"path":"https://smorabit.github.io/hdWGCNA/articles/basic_tutorial.html","id":"basic-visualization","dir":"Articles","previous_headings":"","what":"Basic Visualization","title":"hdWGCNA in single-cell data","text":"showcase basic visualization capabilities hdWGCNA, demonstrate use Seurat’s built-plotting tools visualize hdWGCNA results. Note separate tutorial visualization hdWGCNA networks.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/articles/basic_tutorial.html","id":"module-feature-plots","dir":"Articles","previous_headings":"Basic Visualization","what":"Module Feature Plots","title":"hdWGCNA in single-cell data","text":"FeaturePlot commonly used Seurat visualization show feature interest directly dimensionality reduction. hdWGCNA includes ModuleFeaturePlot function consruct FeaturePlots co-expression module colored module’s uniquely assigned color.  can also plot hub gene signature score using function:  can also use radar plot visualize relative expression level module across different cell groupings. use function ModuleRadarPlot visualize expression modules INH subclusters.  can easily visualize modules shared across different INH subtypes, like module INH-M1, well modules expressed specifically one subtype like module INH-M18. type plot recommend trying visualize many cell groups . hdWGCNA includes ModuleCorrelogram function visualize correlation module based hMEs, MEs, hub gene scores using R package corrplot.","code":"# make a featureplot of hMEs for each module plot_list <- ModuleFeaturePlot(   seurat_obj,   features='hMEs', # plot the hMEs   order=TRUE # order so the points with highest hMEs are on top )  # stitch together with patchwork wrap_plots(plot_list, ncol=6) # make a featureplot of hub scores for each module plot_list <- ModuleFeaturePlot(   seurat_obj,   features='scores', # plot the hub gene scores   order='shuffle', # order so cells are shuffled   ucell = TRUE # depending on Seurat vs UCell for gene scoring )  # stitch together with patchwork wrap_plots(plot_list, ncol=6) seurat_obj$cluster <- do.call(rbind, strsplit(as.character(seurat_obj$annotation), ' '))[,1]  ModuleRadarPlot(   seurat_obj,   group.by = 'cluster',   barcodes = seurat_obj@meta.data %>% subset(cell_type == 'INH') %>% rownames(),   axis.label.size=4,   grid.label.size=4 ) # plot module correlagram ModuleCorrelogram(seurat_obj)"},{"path":"https://smorabit.github.io/hdWGCNA/articles/basic_tutorial.html","id":"plotting-beyond-the-hdwgcna-package","dir":"Articles","previous_headings":"Basic Visualization","what":"Plotting beyond the hdWGCNA package","title":"hdWGCNA in single-cell data","text":"Sometimes want make custom visualization may included hdWGCNA. Fortunately, R incredible amount different data visualization packages take advantage . base Seurat plotting functions also great visualizing hdWGCNA outputs. simple example visualize MEs using Seurat DotPlot function. key using Seurat’s plotting functions visualize hdWGCNA data add Seurat object’s @meta.data slot. Now can easily use Seurat’s DotPlot function:","code":"# get hMEs from seurat object MEs <- GetMEs(seurat_obj, harmonized=TRUE) modules <- GetModules(seurat_obj) mods <- levels(modules$module); mods <- mods[mods != 'grey']  # add hMEs to Seurat meta-data: seurat_obj@meta.data <- cbind(seurat_obj@meta.data, MEs) # plot with Seurat's DotPlot function p <- DotPlot(seurat_obj, features=mods, group.by = 'cell_type')  # flip the x/y axes, rotate the axis labels, and change color scheme: p <- p +   RotatedAxis() +   scale_color_gradient2(high='red', mid='grey95', low='blue')  # plot output p"},{"path":"https://smorabit.github.io/hdWGCNA/articles/basic_tutorial.html","id":"next-steps","dir":"Articles","previous_headings":"","what":"Next steps","title":"hdWGCNA in single-cell data","text":"tutorial went core functions performing co-expression network analysis single-cell transcriptomics data. encourage explore network visualization tutorial tutorials downstream analysis hdWGCNA results.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/articles/consensus_wgcna.html","id":"example-1-consensus-network-analysis-of-astrocytes-from-male-and-female-donors","dir":"Articles","previous_headings":"","what":"Example 1: Consensus network analysis of astrocytes from male and female donors","title":"Consensus network analysis","text":"section, perform consensus network analysis male female donors Zhou et al. snRNA-seq dataset. also follow “standard” workflow (consensus), compare resulting gene module assignments. First, setup seurat object hdWGCNA construct metacells. part workflow standard hdWGCNA workflow, must include relevant metadata consensus network analysis running MetacellsByGroups. Seurat object metadata column called msex, contains 0 1 depending sex donor given cell originated , must include msex group.list within MetacellsByGroups order run consensus network analysis. Next set expression dataset consensus network analysis. standard workflow, use function SetDatExpr set expression matrix used network analyis. Instead SetDatExpr, use SetMultiExpr set separate expression matrix male female donors. allows us perform network analysis individually expression matrices. Now expression matrices male female donors, must identify appropriate soft power threshold matrices separately. Instead TestSoftPowers function use standard hdWGCNA workflow, use TestSoftPowersConsensus, perform test expression matrices. plot results PlotSoftPowers, get nested list plots dataset, can assemble plots using patchwork.  Now construct co-expression network identify gene modules using ConstructNetwork function, making sure specify consensus=TRUE. Indicating consensus=TRUE tells hdWGCNA construct separate network expression matrix, followed integrating networks identifying gene modules. Depending results TestSoftPowersConsensus, can supply different soft power threshold dataset.  can compare consensus network results standard hdWGCNA workflow.  can plot gene module assignments standard workflow consensus analysis dendrogram plot rough comparison.  can see many co-expression modules identified consensus standard workflows, also modules unique workflow. Now can perform downstream analysis tasks using consensus network, example network visualization:","code":"# load the Zhou et al snRNA-seq dataset seurat_obj <- readRDS('data/Zhou_control.rds')  seurat_obj <- SetupForWGCNA(   seurat_obj,   gene_select = \"fraction\",   fraction = 0.05,   wgcna_name = 'ASC_consensus' )  seurat_obj <- MetacellsByGroups(   seurat_obj = seurat_obj,   group.by = c(\"cell_type\", \"Sample\", 'msex'),   ident.group = 'cell_type'   k = 25,   max_shared = 12,   min_cells = 50,   target_metacells = 250,   reduction = 'harmony' )  seurat_obj <- NormalizeMetacells(seurat_obj) seurat_obj <- SetMultiExpr(   seurat_obj,   group_name = \"ASC\",   group.by = \"cell_type\",   multi.group.by =\"msex\",   multi_groups = NULL # this parameter can be used to select a subset of groups in the multi.group.by column ) # run soft power test seurat_obj <- TestSoftPowersConsensus(seurat_obj)  # generate plots plot_list <-  PlotSoftPowers(seurat_obj)  # get just the scale-free topology fit plot for each group consensus_groups <- unique(seurat_obj$msex) p_list <- lapply(1:length(consensus_groups), function(i){   cur_group <- consensus_groups[[i]]   plot_list[[i]][[1]] + ggtitle(paste0('Sex: ', cur_group)) + theme(plot.title=element_text(hjust=0.5)) })  wrap_plots(p_list, ncol=2) # build consensus network seurat_obj <- ConstructNetwork(   seurat_obj,   soft_power=c(8,5), # soft power can be a single number of a vector with a value for each datExpr in multiExpr   consensus=TRUE,   tom_name = \"Sex_Consensus\" )  # plot the dendogram PlotDendrogram(seurat_obj, main='Sex consensus dendrogram') # setup new hdWGCNA experiment seurat_obj <- SetupForWGCNA(   seurat_obj,   gene_select = \"fraction\",   fraction = 0.05,   wgcna_name = 'ASC_standard',   metacell_location = 'ASC' # use the same metacells ) seurat_obj <- NormalizeMetacells(seurat_obj)  # construct network seurat_obj <- SetDatExpr(seurat_obj,group_name = \"ASC\",group.by = \"cell_type\") seurat_obj <- TestSoftPowers(seurat_obj) seurat_obj <- ConstructNetwork(seurat_obj,soft_power=8, tom_name = \"ASC_standard\")  # plot the dendrogram PlotDendrogram(seurat_obj, main='ASC standard Dendrogram') # get both sets of modules modules <- GetModules(seurat_obj, 'ASC_standard') consensus_modules <- GetModules(seurat_obj, 'ASC')  # get consensus dendrogram net <- GetNetworkData(seurat_obj, wgcna_name=\"ASC\") dendro <- net$dendrograms[[1]]  # get the gene and module color for consensus consensus_genes <- consensus_modules$gene_name consensus_colors <- consensus_modules$color names(consensus_colors) <- consensus_genes  # get the gene and module color for standard genes <- modules$gene_name colors <- modules$color names(colors) <- genes  # re-order the genes to match the consensus genes colors <- colors[consensus_genes]  # set up dataframe for plotting color_df <- data.frame(   consensus = consensus_colors,   standard = colors )  # plot dendrogram using WGCNA function WGCNA::plotDendroAndColors(   net$dendrograms[[1]],   color_df,   groupLabels=colnames(color_df),   dendroLabels = FALSE, hang = 0.03, addGuide = TRUE, guideHang = 0.05,   main = \"Sex consensus dendrogram\", ) library(reshape2) library(igraph)  # change active hdWGCNA experiment to consensus seurat_obj <- SetActiveWGCNA(seurat_obj, 'ASC_consensus')  # compute eigengenes and connectivity seurat_obj <- ModuleEigengenes(seurat_obj) seurat_obj <- ModuleConnectivity(seurat_obj, group_name ='ASC', group.by='cell_type')  # visualize network with semi-supervised UMAP seurat_obj <- RunModuleUMAP(   seurat_obj,   n_hubs = 5,   n_neighbors=5,   min_dist=0.1,   spread=2,   wgcna_name = 'ASC',   target_weight=0.05,   supervised=TRUE )  ModuleUMAPPlot(   seurat_obj,   edge.alpha=0.5,   sample_edges=TRUE,   keep_grey_edges=FALSE,   edge_prop=0.075,   label_hubs=0 )"},{"path":"https://smorabit.github.io/hdWGCNA/articles/consensus_wgcna.html","id":"example-2-cross-species-consensus-network-analysis-of-astrocytes-from-mouse-and-human-samples","dir":"Articles","previous_headings":"","what":"Example 2: Cross-species consensus network analysis of astrocytes from mouse and human samples","title":"Consensus network analysis","text":"section, cover complex example consensus network analysis using astrocytes mouse human cortex snRNA-seq datasets. main difference section Example 1 start two different Seurat objects, section applicable wish perform consensus network analysis two different datasets. cross-species analysis, require table maps gene names different species, can convert gene names consistent datasets. provide table analysis, obtained BioMart. First, download human mouse datasets.","code":"wget https://swaruplab.bio.uci.edu/public_data/Zhou_2020.rds wget https://swaruplab.bio.uci.edu/public_data/Zhou_2020_mouse.rds wget https://swaruplab.bio.uci.edu/public_data/hg38_mm10_orthologs_2021.txt"},{"path":"https://smorabit.github.io/hdWGCNA/articles/consensus_wgcna.html","id":"formatting-mouse-and-human-datasets","dir":"Articles","previous_headings":"Example 2: Cross-species consensus network analysis of astrocytes from mouse and human samples","what":"Formatting mouse and human datasets","title":"Consensus network analysis","text":"Next, load data, convert mouse gene names human, construct merged Seurat object. Note using datasets different sources, metadata columns may named differently, careful ensure relevant metadata properly renamed. hg38_mm10_genes table contains gene ID gene symbol (name) mm10 hg38, can use translate gene names mouse dataset human orthologs. run Seurat workflow process dataset, using Harmony integrate cells across species.","code":"# load mouse <-> human gene name table: hg38_mm10_genes <- read.table(\"hg38_mm10_orthologs_2021.txt\", sep='\\t', header=TRUE) colnames(hg38_mm10_genes) <-c('hg38_id', 'mm10_id', 'mm10_name', 'hg38_name')  # remove entries that don't have an ortholog hg38_mm10_genes <- subset(hg38_mm10_genes, mm10_name != '' & hg38_name != '')  # show what the table looks like head(hg38_mm10_genes) hg38_id            mm10_id mm10_name hg38_name 6  ENSG00000198888 ENSMUSG00000064341    mt-Nd1    MT-ND1 10 ENSG00000198763 ENSMUSG00000064345    mt-Nd2    MT-ND2 16 ENSG00000198804 ENSMUSG00000064351    mt-Co1    MT-CO1 19 ENSG00000198712 ENSMUSG00000064354    mt-Co2    MT-CO2 21 ENSG00000228253 ENSMUSG00000064356   mt-Atp8   MT-ATP8 22 ENSG00000198899 ENSMUSG00000064357   mt-Atp6   MT-ATP6 # load seurat objects seurat_mouse <- readRDS('Zhou_2020_mouse.rds') seurat_obj <- readRDS('Zhou_2020.rds')  # re-order the gene table by mouse genes mm10_genes <- unique(hg38_mm10_genes$mm10_name) hg38_genes <- unique(hg38_mm10_genes$hg38_name) hg38_mm10_genes <- hg38_mm10_genes[match(mm10_genes, hg38_mm10_genes$mm10_name),]  # get the mouse counts matrix, keep only genes with a human ortholog X_mouse <- GetAssayData(seurat_mouse, slot='counts') X_mouse <- X_mouse[rownames(X_mouse) %in% hg38_mm10_genes$mm10_name,]  # rename mouse genes to human ortholog ix <- match(rownames(X_mouse), hg38_mm10_genes$mm10_name) converted_genes <- hg38_mm10_genes[ix,'hg38_name'] rownames(X_mouse) <- converted_genes colnames(X_mouse) <- paste0(colnames(X_mouse), '_mouse')  # get the human counts matrix X_human <- GetAssayData(seurat_obj, slot='counts')  # what genes are in common? genes_common <- intersect(rownames(X_mouse), rownames(X_human)) X_human <- X_human[genes_common,] colnames(X_human) <- paste0(colnames(X_human), '_human')  # make sure to only keep genes that are common in the mouse and human datasets X_mouse <- X_mouse[genes_common,]  # set up metadata table for mouse mouse_meta <- seurat_mouse@meta.data %>% dplyr::select(c(Sample.ID, Wt.Tg, Age, Cell.Types)) %>%   dplyr::rename(c(Sample=Sample.ID, cell_type=Cell.Types, condition=Wt.Tg)) rownames(mouse_meta) <- colnames(X_mouse)  # set up metadata table for mouse human_meta <- seurat_obj@meta.data %>% dplyr::select(c(Sample, group, age_death, cell_type)) %>%   dplyr::rename(c(condition=group, Age=age_death)) rownames(human_meta) <- colnames(X_human)  # make mouse seurat obj seurat_m <- CreateSeuratObject(X_mouse, meta = mouse_meta) seurat_h <- CreateSeuratObject(X_human, meta = human_meta)  # merge: seurat_m$Species <- 'mouse' seurat_h$Species <- 'human' seurat_merged <- merge(seurat_m, seurat_h) seurat_merged <- NormalizeData(seurat_merged) seurat_merged <- FindVariableFeatures(seurat_merged, nfeatures=3000) seurat_merged <- ScaleData(seurat_merged) seurat_merged <- RunPCA(seurat_merged) seurat_merged <- RunHarmony(seurat_merged, group.by.vars = 'Species', reduction='pca', dims=1:30)  seurat_merged <- RunUMAP(seurat_merged, reduction='harmony', dims=1:30, min.dist=0.3)  DimPlot(seurat_merged, group.by='cell_type', split.by='Species', raster=FALSE, label=TRUE) + umap_theme()"},{"path":"https://smorabit.github.io/hdWGCNA/articles/consensus_wgcna.html","id":"consensus-network-analysis","dir":"Articles","previous_headings":"Example 2: Cross-species consensus network analysis of astrocytes from mouse and human samples","what":"Consensus network analysis","title":"Consensus network analysis","text":"Now Seurat object ready consensus network analysis. perform consensus network analysis hdWGCNA using similar approach Example 1.   can compare consensus network results standard hdWGCNA workflow. checking resulting dendrogram standard workflow, clearthat much underlying co-expression structure lost.   clear see much co-expression structure missing using standard workflow dataset contains vast differences coming individual species. , can take consensus network perform downstream hdWGCNA analysis steps.  summary, consensus co-expression network analysis useful alternative standard hdWGCNA workflow cases want build integrated co-expression network using different datasets/batches biological conditions.","code":"seurat_merged <- SetupForWGCNA(   seurat_merged,   gene_select = \"fraction\",   fraction = 0.05,   wgcna_name = 'ASC_consensus' )  # construct metacells: seurat_merged <- MetacellsByGroups(   seurat_merged,   group.by = c(\"cell_type\", \"Sample\", 'Species'),   k = 25,   max_shared = 12,   min_cells = 50,   target_metacells = 250,   reduction = 'harmony',   ident.group = 'cell_type' ) seurat_merged <- NormalizeMetacells(seurat_merged)  # setup expression matrices for each species in astrocytes seurat_merged <- SetMultiExpr(   seurat_merged,   group_name = \"ASC\",   group.by = \"cell_type\",   multi.group.by =\"Species\",   multi_groups = NULL )  # identify soft power thresholds seurat_merged <- TestSoftPowersConsensus(seurat_merged)  # plot soft power results plot_list <-  PlotSoftPowers(seurat_merged) consensus_groups <- unique(seurat_merged$Species) p_list <- lapply(1:length(consensus_groups), function(i){   cur_group <- consensus_groups[[i]]   plot_list[[i]][[1]] + ggtitle(paste0(cur_group)) + theme(plot.title=element_text(hjust=0.5)) }) wrap_plots(p_list, ncol=2)  # consensus network analysis seurat_merged <- ConstructNetwork(   seurat_merged,   soft_power=c(7,7),   consensus=TRUE,   tom_name = \"Species_Consensus\" )  # plot the dendrogram PlotDendrogram(seurat_merged, main='ASC cross species dendrogram') seurat_merged <- SetupForWGCNA(   seurat_merged,   gene_select = \"fraction\",   fraction = 0.05,   wgcna_name = 'ASC_standard',   metacell_location = 'ASC_consensus' ) seurat_merged <- NormalizeMetacells(seurat_merged)  seurat_merged <- SetDatExpr(seurat_merged, group_name = \"ASC\", group.by = \"cell_type\") seurat_merged <- TestSoftPowers(seurat_merged, setDatExpr = FALSE) seurat_merged <- ConstructNetwork(seurat_merged, tom_name = \"Species_ASC_standard\")  # plot the dendrogram PlotDendrogram(seurat_merged, main='ASC standard Dendrogram') modules <- GetModules(seurat_merged, 'ASC_standard') consensus_modules <- GetModules(seurat_merged, 'ASC_consensus')  # get consensus dendro net <- GetNetworkData(seurat_merged, wgcna_name=\"ASC_consensus\")  consensus_genes <- consensus_modules$gene_name consensus_colors <- consensus_modules$color names(consensus_colors) <- consensus_genes  genes <- modules$gene_name colors <- modules$color names(colors) <- genes  colors <- colors[consensus_genes]  color_df <- data.frame(   consensus = consensus_colors,   standard = colors )  # plot dendrogram pdf(paste0(fig_dir, \"cross_species_dendro_compare.pdf\"),height=3, width=6) WGCNA::plotDendroAndColors(   net$dendrograms[[1]],   color_df,   groupLabels=colnames(color_df),   dendroLabels = FALSE, hang = 0.03, addGuide = TRUE, guideHang = 0.05,   main = \"ASC cross species consensus dendrogram\", ) dev.off() # change the active WGCNA back to the consensus seurat_merged <- SetActiveWGCNA(seurat_merged, 'ASC_consensus')  # compute module eigengenes and connectivity seurat_merged <- ModuleEigengenes(seurat_merged, group.by.vars=\"Species\") seurat_merged <- ModuleConnectivity(seurat_merged, group_name ='ASC', group.by='cell_type')  # re-name modules seurat_merged <- ResetModuleNames(seurat_merged, new_name = \"ASC-CM\")  # visualize network with UMAP seurat_merged <- RunModuleUMAP(   seurat_merged,   n_hubs = 5,   n_neighbors=15,   min_dist=0.3,   spread=5 )  ModuleUMAPPlot(   seurat_merged,   edge.alpha=0.5,   sample_edges=TRUE,   keep_grey_edges=FALSE,   edge_prop=0.075, # taking the top 20% strongest edges in each module   label_hubs=0 # how many hub genes to plot per module? )"},{"path":"https://smorabit.github.io/hdWGCNA/articles/customization.html","id":"renaming-hdwgcna-modules","dir":"Articles","previous_headings":"","what":"Renaming hdWGCNA modules","title":"Module customization","text":"hdWGCNA includes ResetModuleNames function, assigns new name module. new_name parameter takes string base name module, number appended name. modules re-named entire hdWGCNA experiment, subsequent plots etc show updated names. following code shows rename hdWGCNA modules. Alternatively, can supply named list rename selected modules. Finally, can supply character vector new name module rather named list. next section, re-make hdWGCNA visualizations can see module names updated.","code":"seurat_obj <- ResetModuleNames(   seurat_obj,   new_name = \"Renamed-M\" # the base name for the new modules )  # print out the new module names modules <- GetModules(seurat_obj) print(levels(modules$module)) [1] \"Renamed-M1\"  \"Renamed-M2\"  \"Renamed-M3\"  \"Renamed-M4\"  \"Renamed-M5\" [6] \"Renamed-M6\"  \"Renamed-M7\"  \"Renamed-M8\"  \"Renamed-M9\"  \"Renamed-M10\" [11] \"grey\"        \"Renamed-M11\" \"Renamed-M12\" \"Renamed-M13\" \"Renamed-M14\" [16] \"Renamed-M15\" \"Renamed-M16\" \"Renamed-M17\" \"Renamed-M18\" rename_list <- list(   \"Renamed-M1\" = 'Charlie', # \"old_module_name\" = \"new_module_name\"   \"Renamed-M2\" = \"Mac\",   \"Renamed-M3\" = \"Dennis\" )  seurat_obj <- ResetModuleNames(   seurat_obj,   new_name = rename_list )  # print out the new module names modules <- GetModules(seurat_obj) print(levels(modules$module)) [1] \"Charlie\"     \"Mac\"         \"Dennis\"      \"Renamed-M4\"  \"Renamed-M5\" [6] \"Renamed-M6\"  \"Renamed-M7\"  \"Renamed-M8\"  \"Renamed-M9\"  \"Renamed-M10\" [11] \"grey\"        \"Renamed-M11\" \"Renamed-M12\" \"Renamed-M13\" \"Renamed-M14\" [16] \"Renamed-M15\" \"Renamed-M16\" \"Renamed-M17\" \"Renamed-M18\" # how many non-grey modules are there? n_mods <- length(levels(modules$module)) - 1  seurat_obj <- ResetModuleNames(   seurat_obj,   new_name = as.character(1:n_mods) )  # print out the new module names modules <- GetModules(seurat_obj) print(levels(modules$module)) [1] \"1\"    \"2\"    \"3\"    \"4\"    \"5\"    \"6\"    \"7\"    \"8\"    \"9\"    \"10\" [11] \"grey\" \"11\"   \"12\"   \"13\"   \"14\"   \"15\"   \"16\"   \"17\"   \"18\""},{"path":"https://smorabit.github.io/hdWGCNA/articles/customization.html","id":"re-coloring-hdwgcna-modules","dir":"Articles","previous_headings":"","what":"Re-coloring hdWGCNA modules","title":"Module customization","text":"demonstrate assign new colors hdWGCNA modules using ResetModuleColors function. function takes list new colors replace old colors, named list order change colors selected modules. ordering colors depends factor level hdWGCNA modules . Additionally, function ensures “grey moddule”, contains genes get assigned co-expression module, remains grey.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/articles/customization.html","id":"change-the-colors-of-all-modules","dir":"Articles","previous_headings":"Re-coloring hdWGCNA modules","what":"Change the colors of all modules","title":"Module customization","text":"example, use MetBrewer package select new color scheme modules. First, can make table show original module-color pairings. Next, use ResetModuleColors change module-color pairings. Now test different visualization functions check colors successfully modified.","code":"# get the module table modules <- GetModules(seurat_obj) mods <- unique(modules$module)  # make a table of the module-color pairings mod_colors_df <- dplyr::select(modules, c(module, color)) %>%   distinct %>% arrange(module) rownames(mod_colors_df) <- mod_colors_df$module  # print the dataframe mod_colors_df module        color INH-M1   INH-M1   lightgreen INH-M2   INH-M2  lightyellow INH-M3   INH-M3         blue INH-M4   INH-M4         cyan INH-M5   INH-M5        black INH-M6   INH-M6        green INH-M7   INH-M7        brown INH-M8   INH-M8       purple INH-M9   INH-M9       salmon INH-M10 INH-M10    turquoise INH-M11 INH-M11  greenyellow INH-M12 INH-M12       yellow INH-M13 INH-M13          tan INH-M14 INH-M14    lightcyan INH-M15 INH-M15       grey60 INH-M16 INH-M16 midnightblue INH-M17 INH-M17          red grey       grey         grey INH-M18 INH-M18      magenta INH-M19 INH-M19         pink INH-M20 INH-M20    royalblue # load MetBrewer color scheme pakckage library(MetBrewer)  # get a table of just the module and it's unique color mod_color_df <- GetModules(seurat_obj) %>%   dplyr::select(c(module, color)) %>%   distinct %>% arrange(module)  # the number of unique modules (subtract 1 because the grey module stays grey): n_mods <- nrow(mod_color_df) - 1  # using the \"Signac\" palette from metbrewer, selecting for the number of modules new_colors <- paste0(met.brewer(\"Signac\", n=n_mods))  # reset the module colors seurat_obj <- ResetModuleColors(seurat_obj, new_colors) PlotDendrogram(seurat_obj, main='Recolored Dendrogram') # make a featureplot of hMEs for each module plot_list <- ModuleFeaturePlot(seurat_obj)  # stitch together with patchwork wrap_plots(plot_list, ncol=6) ModuleUMAPPlot(   seurat_obj,   edge.alpha=0.15,   sample_edges=TRUE,   edge_prop=0.2,   label_hubs=2 )"},{"path":"https://smorabit.github.io/hdWGCNA/articles/customization.html","id":"change-the-colors-of-selected-modules","dir":"Articles","previous_headings":"Re-coloring hdWGCNA modules","what":"Change the colors of selected modules","title":"Module customization","text":"example, change colors two modules rather . need supply ResetModuleColors named list detailing modules want change, color change . make FeaturePlot changing colors test properly changed.  successfully changed color modules INH-M5 INH-M12, leaving module colors .","code":"# make a featureplot before changing colors pl1 <- ModuleFeaturePlot(seurat_obj, module_names = c('INH-M5', 'INH-M12', 'INH-M16'))  # set new colors new_colors <- list('INH-M12' = 'darksalmon', 'INH-M5' = 'deeppink') seurat_obj <- ResetModuleColors(seurat_obj, new_colors)  # make a featureplot after changing colors pl2 <- ModuleFeaturePlot(seurat_obj, module_names = c('INH-M5', 'INH-M12', 'INH-M16'))  # stitch together with patchwork wrap_plots(c(pl1, pl2), ncol=3)"},{"path":"https://smorabit.github.io/hdWGCNA/articles/differential_MEs.html","id":"dme-analysis-comparing-two-groups","dir":"Articles","previous_headings":"","what":"DME analysis comparing two groups","title":"Differential module eigengene (DME) analysis","text":"discuss perform DME testing two different groups. use hdWGCNA function FindDMEs, syntax similar Seurat function FindMarkers. use Mann-Whitney U test, also known Wilcoxon test, compare two groups, tests can specified test.use parameter. Since tutorial dataset contains control brain samples, use sex define two groups. FindDMEs requires list barcodes group1 group2. , going compare cells INH cluster since group performed network analysis . Next, run FindDMEs function. can visualize results using hdWGNCA functions PlotDMEsLollipop PlotDMEsVolcano. First make lollipop plot visualize DME results.  plot shows fold-change modules, size dot corresponds number genes module. “X” placed point reach statistical significance. PlotDMEsLollipop, self-defined columns DMEs data frame, can use group.parameter supply column names comparison arguments one comparison group list comparison groups plotting. example: Alternatively, can use PlotDMEsVolcano make volcano plot show effect size significance level together.","code":"group1 <- seurat_obj@meta.data %>% subset(cell_type == 'INH' & msex == 0) %>% rownames group2 <- seurat_obj@meta.data %>% subset(cell_type == 'INH' & msex != 0) %>% rownames  head(group1) [1] \"TCTTCGGCAAGACGTG-11\" \"ATTATCCGTTGATTCG-11\" \"CCACCTAGTCCAAGTT-11\" [4] \"AGCGTATGTTAAGAAC-11\" \"GTAACTGTCCAGATCA-11\" \"CGATTGATCTTTACAC-11\" DMEs <- FindDMEs(   seurat_obj,   barcodes1 = group1,   barcodes2 = group2,   test.use='wilcox',   wgcna_name='INH' )  head(DMEs) p_val  avg_log2FC pct.1 pct.2    p_val_adj  module INH-M18 4.714924e-23  0.40637874 0.894 0.729 8.486863e-22 INH-M18 INH-M16 5.257311e-08 -0.18257946 0.850 0.935 9.463160e-07 INH-M16 INH-M2  7.565615e-05 -0.18746938 0.661 0.738 1.361811e-03  INH-M2 INH-M15 1.496899e-03 -0.06603535 0.969 0.977 2.694417e-02 INH-M15 INH-M10 1.513458e-02 -0.07774661 0.975 0.980 2.724224e-01 INH-M10 INH-M17 2.034644e-02  0.24035946 0.589 0.557 3.662360e-01 INH-M17 PlotDMEsLollipop(   seurat_obj,    DMEs,    wgcna_name='INH',    pvalue = \"p_val_adj\" ) PlotDMEsLollipop(   seurat_obj,    DMEs,    wgcna_name='INH',    group.by = \"Comparisons\",    comparison = c(\"group1_vs_control\", \"group2_vs_control\"),     pvalue = \"p_val_adj\" ) PlotDMEsVolcano(   seurat_obj,   DMEs,   wgcna_name = 'INH' )"},{"path":"https://smorabit.github.io/hdWGCNA/articles/differential_MEs.html","id":"looping-through-multiple-clusters","dir":"Articles","previous_headings":"DME analysis comparing two groups","what":"Looping through multiple clusters","title":"Differential module eigengene (DME) analysis","text":"can run DME analysis loop perform comparison multiple groups. loop 5 INH subclusters run FindDMEs cluster. use ggplot2 make heatmap showing DME effect sizes. Since just using ggplot2 can easily customize heatmap suit needs.","code":"# list of clusters to loop through clusters <- c(\"INH1 VIP+\", \"INH2 PVALB+\", \"INH3 SST+\", 'INH4 LAMP5+', \"INH5 PVALB+\")  # set up an empty dataframe for the DMEs DMEs <- data.frame()  # loop through the clusters for(cur_cluster in clusters){    # identify barcodes for group1 and group2 in eadh cluster   group1 <- seurat_obj@meta.data %>% subset(annotation == cur_cluster & msex == 0) %>% rownames   group2 <- seurat_obj@meta.data %>% subset(annotation == cur_cluster & msex != 0) %>% rownames    # run the DME test   cur_DMEs <- FindDMEs(     seurat_obj,     barcodes1 = group1,     barcodes2 = group2,     test.use='wilcox',     pseudocount.use=0.01, # we can also change the pseudocount with this param     wgcna_name = 'INH'   )    # add the cluster info to the table   cur_DMEs$cluster <- cur_cluster    # append the table   DMEs <- rbind(DMEs, cur_DMEs) } # get the modules table: modules <- GetModules(seurat_obj) mods <- levels(modules$module); mods <- mods[mods != 'grey']  # make a copy of the DME table for plotting plot_df <- DMEs  # set the factor level for the modules so they plot in the right order: plot_df$module <- factor(as.character(plot_df$module), levels=mods)  # set a min/max threshold for plotting maxval <- 0.5; minval <- -0.5 plot_df$avg_log2FC <- ifelse(plot_df$avg_log2FC > maxval, maxval, plot_df$avg_log2FC) plot_df$avg_log2FC <- ifelse(plot_df$avg_log2FC < minval, minval, plot_df$avg_log2FC)  # add significance levels plot_df$Significance <- gtools::stars.pval(plot_df$p_val_adj)  # change the text color to make it easier to see  plot_df$textcolor <- ifelse(plot_df$avg_log2FC > 0.2, 'black', 'white')  # make the heatmap with geom_tile p <- plot_df %>%    ggplot(aes(y=cluster, x=module, fill=avg_log2FC)) +   geom_tile()   # add the significance levels p <- p +    geom_text(label=plot_df$Significance, color=plot_df$textcolor)   # customize the color and theme of the plot p <- p +    scale_fill_gradient2(low='purple', mid='black', high='yellow') +   RotatedAxis() +   theme(     panel.border = element_rect(fill=NA, color='black', size=1),     axis.line.x = element_blank(),     axis.line.y = element_blank(),     plot.margin=margin(0,0,0,0)   ) + xlab('') + ylab('') +   coord_equal()  p"},{"path":"https://smorabit.github.io/hdWGCNA/articles/differential_MEs.html","id":"one-versus-all-dme-analysis","dir":"Articles","previous_headings":"","what":"One-versus-all DME analysis","title":"Differential module eigengene (DME) analysis","text":"Similar Seurat function FindAllMarkers, can perform one-versus-DME test using function FindAllDMEs specifying column group cells. group.cell type one-versus-test. output looks similar FindDMEs, extra column called group containing information cell grouping. Now can plot results PlotDMEsVolcano","code":"group.by = 'cell_type'  DMEs_all <- FindAllDMEs(   seurat_obj,   group.by = 'cell_type',   wgcna_name = 'INH' )  head(DMEs_all) p_val avg_log2FC pct.1 pct.2 p_val_adj module group EX.INH-M1     0 -10.313763 0.003 0.621         0 INH-M1    EX EX.INH-M2     0   1.007115 0.670 0.445         0 INH-M2    EX EX.INH-M3     0   2.641423 0.729 0.205         0 INH-M3    EX EX.INH-M4     0   1.978553 0.910 0.246         0 INH-M4    EX EX.INH-M5     0   2.447565 0.865 0.185         0 INH-M5    EX EX.INH-M6     0   2.448315 0.877 0.209         0 INH-M6    EX p <- PlotDMEsVolcano(   seurat_obj,   DMEs_all,   wgcna_name = 'INH',   plot_labels=FALSE,   show_cutoff=FALSE )  # facet wrap by each cell type p + facet_wrap(~group, ncol=3)"},{"path":"https://smorabit.github.io/hdWGCNA/articles/differential_MEs.html","id":"using-modulescores-instead-of-mes","dir":"Articles","previous_headings":"","what":"Using ModuleScores instead of MEs","title":"Differential module eigengene (DME) analysis","text":"can also perform differential analysis using module expression scores instead module eigengenes. must first calculated using function ModuleExprScore, shown . Next can perform differential analysis using module scores specifying features = 'ModuleScores' FindDMEs function.","code":"seurat_obj <- ModuleExprScore(   seurat_obj,   n_genes = 25,   method='UCell' ) group1 <- seurat_obj@meta.data %>% subset(cell_type == 'INH' & msex == 0) %>% rownames group2 <- seurat_obj@meta.data %>% subset(cell_type == 'INH' & msex != 0) %>% rownames  DMEs_scores <- FindDMEs(   seurat_obj,   features = 'ModuleScores',   barcodes1 = group1,   barcodes2 = group2,   test.use='wilcox',   wgcna_name='tutorial' )  p <- PlotDMEsLollipop(   seurat_obj,    DMEs,    wgcna_name = 'tutorial',   pvalue = \"p_val_adj\" )  p"},{"path":"https://smorabit.github.io/hdWGCNA/articles/enrichment_analysis.html","id":"enrichr","dir":"Articles","previous_headings":"","what":"EnrichR","title":"Enrichment analysis","text":"section discuss perform Enrichr enrichment tests visualize results using hdWGCNA. hdWGCNA includes function RunEnrichr compare set genes module gene lists hosted Enrichr. can take look list different Enrichr gene lists . store results enrichment tests hdWGCNA experiment, can easily retrieved downstream analysis exporting external applicaitons like Excel. following example, perform enrichment test three Gene Ontology datbases: GO_Biological_Process_2021 GO_Cellular_Component_2021 GO_Molecular_Function_2021 outputs Enrichr test explained detail , offer short explanation different columns enrich_df: Term: name term (ie biological process, etc). Overlap: fraction genes overlapping module gene list. P.value: Fisher’s exact test p-value. Adjusted.P.value: Benjamini-Hochberg multiple testing correction Fisher’s exact test p-values. Odds.Ratio: statistic quantify association gene list current module gene list current Term. Combined.Score: natural log p-value multiplied z-score, z-score deviation expected rank. Genes: semicolon delimited list gene symbols overlapping genes. db: name Enrichr gene list. module: name hdWGCNA module.","code":"# enrichr databases to test dbs <- c('GO_Biological_Process_2021','GO_Cellular_Component_2021','GO_Molecular_Function_2021')  # perform enrichment tests seurat_obj <- RunEnrichr(   seurat_obj,   dbs=dbs, # character vector of enrichr databases to test   max_genes = 100 # number of genes per module to test. use max_genes = Inf to choose all genes! )  # retrieve the output table enrich_df <- GetEnrichrTable(seurat_obj)"},{"path":"https://smorabit.github.io/hdWGCNA/articles/enrichment_analysis.html","id":"visualize-enrichments","dir":"Articles","previous_headings":"EnrichR","what":"Visualize enrichments","title":"Enrichment analysis","text":"Now done enrichment tests, several ways can go visualizing results.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/articles/enrichment_analysis.html","id":"enrichrbarplot","dir":"Articles","previous_headings":"EnrichR > Visualize enrichments","what":"EnrichrBarPlot","title":"Enrichment analysis","text":"hdWGCNA includes function EnrichrBarPlot summarize results every Enrichr database every module. function outputs .pdf figure module, containing barplot showing top N enriched terms. following example plot top 10 terms module output results folder called enrichr_plots. following bar plot single example EnrichrBarPlot output:  Interpreting Enrichr results enrichment bar plots colored module’s unique color, term sorted enrichment (combined score). encourage users carefully inspect results enrichment tests, use prior biological knowledge jumping conclusions. example, see terms make sense inhibitory neurons, “inhibitory synapse assembly” “synaptic transmission, GABAergic”. hand, see several cardiac related terms realistically related system example (human brain). Many genes take part distinct biological processes different tissues within organism, leads enrichment results like .","code":"# make GO term plots: EnrichrBarPlot(   seurat_obj,   outdir = \"enrichr_plots\", # name of output directory   n_terms = 10, # number of enriched terms to show (sometimes more show if there are ties!!!)   plot_size = c(5,7), # width, height of the output .pdfs   logscale=TRUE # do you want to show the enrichment as a log scale? )"},{"path":"https://smorabit.github.io/hdWGCNA/articles/enrichment_analysis.html","id":"enrichrdotplot","dir":"Articles","previous_headings":"EnrichR > Visualize enrichments","what":"EnrichrDotPlot","title":"Enrichment analysis","text":"hdWGCNA includes additional visualization function enrichment results, EnrichrDotPlot, shows top results one Enrichr database module. following example, plot top term GO_Biological_Process_2021 database.  plot, dot colored module’s unique color, size dot scaled enrichment term.","code":"# enrichr dotplot EnrichrDotPlot(   seurat_obj,   mods = \"all\", # use all modules (this is the default behavior)   database = \"GO_Biological_Process_2021\", # this has to be one of the lists we used above!!!   n_terms=1 # number of terms for each module )"},{"path":"https://smorabit.github.io/hdWGCNA/articles/enrichment_analysis.html","id":"marker-gene-overlap-analysis","dir":"Articles","previous_headings":"","what":"Marker gene overlap analysis","title":"Enrichment analysis","text":"section discuss compare hdWGCNA modules cluster cell-type marker genes. First use Seurat function FindAllMarkers identify marker genes cell type, use hdWGCNA function OverlapModulesDEGs overlap modules DEGs. Notably, results OverlapModulesDEGs currently stored hdWGCNA experiment. partially test extremely fast run, partially many different sets DEGs one compare modules . overlap_df contains following columns: module: name hdWGCNA module. group: name RNA-seq cluster / cell-type / etc. color: module’s unique color. odds_ratio: statistic quantify association gene list current module gene list marker genes. pval: Fisher’s exact test p-value. fdr: False Discovery Rate (FDR) multiple testing correction Fisher’s p-values. Significance: Character vector indicating significance level overlap. Jaccard: Jaccard index two gene lists. size_intersection: number genes overlap two gene lists.","code":"# compute cell-type marker genes with Seurat: Idents(seurat_obj) <- seurat_obj$cell_type markers <- Seurat::FindAllMarkers(   seurat_obj,   only.pos = TRUE,   logfc.threshold=1 )  # compute marker gene overlaps overlap_df <- OverlapModulesDEGs(   seurat_obj,   deg_df = markers,   fc_cutoff = 1 # log fold change cutoff for overlap analysis )"},{"path":"https://smorabit.github.io/hdWGCNA/articles/enrichment_analysis.html","id":"visualize-overlaps","dir":"Articles","previous_headings":"Marker gene overlap analysis","what":"Visualize overlaps","title":"Enrichment analysis","text":"hdWGCNA includes two functions visualize results OverlapModulesDEGs, OverlapDotPlot OverlapBarPlot. demonstrate using OverlapBarPlot visualize results OverlapModulesDEGs. function creates bar plot cell type showing one overlap statistics module.  Next use OverlapDotPlot visualize overlap results single plot.  dot colored hdWGCNA module’s unique color, size dot scaled overlap statistic. show FDR significance levels stars top dots. ’***’: 0 - 0.001 ’**’: 0.001 - 0.01 ’*’: 0.01 - 0.05 ‘+’: 0.05 - 0.1 (symbol): 0.1 - 1.0","code":"# overlap barplot, produces a plot for each cell type plot_list <- OverlapBarPlot(overlap_df)  # stitch plots with patchwork wrap_plots(plot_list, ncol=3) # plot odds ratio of the overlap as a dot plot OverlapDotPlot(   overlap_df,   plot_var = 'odds_ratio') +   ggtitle('Overlap of modules & cell-type markers')"},{"path":"https://smorabit.github.io/hdWGCNA/articles/hdWGCNA.html","id":"co-expression-network-analysis","dir":"Articles","previous_headings":"","what":"Co-expression network analysis","title":"Vignettes overview","text":"tutorials cover essentials performing co-expression network analysis single-cell transcriptomics data, visualizing key results.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/articles/hdWGCNA.html","id":"hdwgcna-in-single-cell-data","dir":"Articles","previous_headings":"Co-expression network analysis","what":"hdWGCNA in single-cell data","title":"Vignettes overview","text":"tutorial covers essential functions construct co-expression network single-cell transcriptomics data hdWGCNA.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/articles/hdWGCNA.html","id":"hdwgcna-in-spatial-transcriptomics-data","dir":"Articles","previous_headings":"Co-expression network analysis","what":"hdWGCNA in spatial transcriptomics data","title":"Vignettes overview","text":"tutorial covers essential functions construct co-expression network spatial transcriptomics data hdWGCNA.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/articles/hdWGCNA.html","id":"network-visualization","dir":"Articles","previous_headings":"Co-expression network analysis","what":"Network visualization","title":"Vignettes overview","text":"tutorial highlights several approaches visualizing hdWGCNA co-expression networks.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/articles/hdWGCNA.html","id":"biological-context-for-co-expression-modules","dir":"Articles","previous_headings":"","what":"Biological context for co-expression modules","title":"Vignettes overview","text":"tutorials provide biological context co-expression modules, potentially revealing experimental conditions biological processes modules involved .","code":""},{"path":"https://smorabit.github.io/hdWGCNA/articles/hdWGCNA.html","id":"differential-module-eigengene-dme-analysis","dir":"Articles","previous_headings":"Biological context for co-expression modules","what":"Differential module eigengene (DME) analysis","title":"Vignettes overview","text":"tutorial covers compare module eigengenes experimental groups.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/articles/hdWGCNA.html","id":"module-trait-correlation","dir":"Articles","previous_headings":"Biological context for co-expression modules","what":"Module trait correlation","title":"Vignettes overview","text":"tutorial covers correlate continuous categorical variables module eigengenes module expression scores, revealing modules related different experimental conditions covariates.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/articles/hdWGCNA.html","id":"enrichment-analysis","dir":"Articles","previous_headings":"Biological context for co-expression modules","what":"Enrichment analysis","title":"Vignettes overview","text":"tutorial shows use Enrichr compare gene members co-expression module curated gene lists, thereby pointing towards biological functions co-expression modules.","code":""},{"path":[]},{"path":"https://smorabit.github.io/hdWGCNA/articles/hdWGCNA.html","id":"projecting-modules-to-new-datasets","dir":"Articles","previous_headings":"Exploring modules in external datasets","what":"Projecting modules to new datasets","title":"Vignettes overview","text":"tutorial covers project co-expression modules reference query dataset.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/articles/hdWGCNA.html","id":"module-preservation-and-reproducibility","dir":"Articles","previous_headings":"Exploring modules in external datasets","what":"Module preservation and reproducibility","title":"Vignettes overview","text":"tutorial covers statistical methods assessing preservation reproducibility co-expression networks using external datasets.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/articles/hdWGCNA.html","id":"cross-species-and-cross-modality-analysis","dir":"Articles","previous_headings":"Exploring modules in external datasets","what":"Cross-species and cross-modality analysis","title":"Vignettes overview","text":"tutorial covers project co-expression modules reference query dataset special cases data modality species match reference query.","code":""},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":"https://smorabit.github.io/hdWGCNA/articles/hdWGCNA.html","id":"module-customization","dir":"Articles","previous_headings":"Other","what":"Module customization","title":"Vignettes overview","text":"tutorial covers change default names colors hdWGCNA modules.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/articles/hdWGCNA.html","id":"using-sctransform-normalized-data","dir":"Articles","previous_headings":"Other","what":"Using SCTransform normalized data","title":"Vignettes overview","text":"tutorial covers use SCTransform normalized data hdWGCNA.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/articles/isoform_pbmcs.html","id":"download-the-tutorial-data","dir":"Articles","previous_headings":"","what":"Download the tutorial data","title":"Isoform co-expression network analysis with PacBio MAS-Seq","text":"download genes isoforms counts matrices PacBio two replicates using wget. counts matrices generated using PacBio SMRT Link software, details can found isoseq documentation website. can also download unprocessed Seurat object containing replicates instead running “Create multi-assay Seurat object” section.","code":"# download replicate 1 wget --recursive --no-parent https://downloads.pacbcloud.com/public/dataset/MAS-Seq/DATA-Revio-PBMC-1/4-SeuratMatrix/  # download replicate 2 wget --recursive --no-parent https://downloads.pacbcloud.com/public/dataset/MAS-Seq/DATA-Revio-PBMC-2/4-SeuratMatrix/"},{"path":"https://smorabit.github.io/hdWGCNA/articles/isoform_pbmcs.html","id":"seurat-clustering-analysis","dir":"Articles","previous_headings":"","what":"Seurat clustering analysis","title":"Isoform co-expression network analysis with PacBio MAS-Seq","text":"section, perform clustering analysis MAS-Seq dataset using Seurat. principal, analysis also performed using alternative pipelines Scanpy performing network analysis. perform standard clustering steps including quality control (QC) filtering, normalization, feature selection, linear dimensionality reduction (PCA), batch correction (harmony), non-linear dimensionality reduction (UMAP), louvain clustering. perform clustering analysis using gene counts matrix isoform counts matrix separately compare differences.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/articles/isoform_pbmcs.html","id":"create-a-multi-assay-seurat-object","dir":"Articles","previous_headings":"Seurat clustering analysis","what":"Create a multi-assay Seurat object","title":"Isoform co-expression network analysis with PacBio MAS-Seq","text":"MAS-Seq dataset includes gene isoform level quantifications, section load matrices replicates create multi-assay Seurat object. number isoforms detected differs replicate, chosen include isoforms detected replicates. don’t want run section, can download unprocessed Seurat object . successfully created Seurat object two assays, iso containing isoform counts counts matrix, RNA containing gene counts matrix. iso assay contains 225080 different isoforms, RNA assay contains 19877 genes. Seurat object 17637 cell barcodes QC filtering.","code":"library(Seurat) library(tidyverse) library(harmony) library(Matrix) library(patchwork) library(cowplot) library(RColorBrewer) library(viridis) library(ggpubr) theme_set(theme_cowplot()) set.seed(12345)  # directories with the counts matrices for each replicate sample_dirs <- c(   'DATA-Revio-PBMC-1/4-SeuratMatrix/NoNovelGenesIsoforms/',   'DATA-Revio-PBMC-2/4-SeuratMatrix/NoNovelGenesIsoforms/' ) names(sample_dirs) <- c('PBMC-1', 'PBMC-2')  # load isoform counts matrices for each sample: iso_X_list <- lapply(sample_dirs, function(x){Seurat::Read10X(paste0(x, 'isoforms_seurat/'))})  # load gene counts matrices for each sample: gene_X_list <- lapply(sample_dirs, function(x){Seurat::Read10X(paste0(x, 'genes_seurat/'))})  # only keep isoforms that are common in all samples: common_iso <- Reduce(intersect, lapply(iso_X_list, function(x){rownames(x)})) iso_X_list <- lapply(iso_X_list, function(x){x[common_iso,]})  # create individual Seurat objects for each sample seurat_list <- lapply(1:length(sample_dirs), function(i){   cur <- Seurat::CreateSeuratObject(gene_X_list[[i]], min.cells=5);    # add a column for the original barcode   cur$barcode <- colnames(cur)    # add a column indicating the sample name   cur$Sample <- names(sample_dirs)[[i]]    # add the iso assay to the seurat object to contain the isoform counts matrix   cur[[\"iso\"]] <- Seurat::CreateAssayObject(counts = iso_X_list[[i]], min.cells=5)   cur })  # merge replicates into one Seurat object seurat_obj <- Reduce(merge, seurat_list)  # save the unprocessed Seurat object saveRDS(seurat_obj, file = 'PBMC_masseq_unprocessed_seurat.rds')  # check basic info about this seurat object seurat_obj An object of class Seurat  225080 features across 17637 samples within 2 assays  Active assay: RNA (19877 features, 0 variable features)  1 other assay present: iso"},{"path":"https://smorabit.github.io/hdWGCNA/articles/isoform_pbmcs.html","id":"quality-control-qc-filtering","dir":"Articles","previous_headings":"Seurat clustering analysis","what":"Quality control (QC) filtering","title":"Isoform co-expression network analysis with PacBio MAS-Seq","text":"insepct distribution certain QC metrics order determine reasonable cutoffs outlier removal. can inspect distributions gene UMI counts, number genes detected, isoform UMI counts, number isoforms detected.  Based distributions, remove barcodes fewer 500 gene UMI counts greater 5000 gene UMI counts.","code":"# load unprocessed seurat object: seurat_obj <- readRDS(file = 'PBMC_masseq_unprocessed_seurat.rds')  # violin plots for different QC stats features <- c('nCount_RNA', 'nFeature_RNA', 'nCount_iso', 'nFeature_iso')  # make a violin plot for each QC metric plot_list <- lapply(features, function(x){ VlnPlot(   seurat_obj,   features = x,   group.by = 'Sample',   pt.size=0) +   RotatedAxis() +   NoLegend() +   geom_boxplot(notch=TRUE, fill=NA, outlier.shape=NA) +   xlab('') +   theme(plot.title = element_text(size=10, hjust=0.5)) })  # assemble plots with patchwork wrap_plots(plot_list, ncol=4) # keep cells with greater than 500 UMIs and fewer than 5000 UMIs seurat_obj <- subset(seurat_obj, nCount_RNA >= 500 & nCount_RNA <= 5000)"},{"path":"https://smorabit.github.io/hdWGCNA/articles/isoform_pbmcs.html","id":"clustering-on-gene-counts-matrix","dir":"Articles","previous_headings":"Seurat clustering analysis","what":"Clustering on gene counts matrix","title":"Isoform co-expression network analysis with PacBio MAS-Seq","text":"section, perform clustering analysis gene counts matrix. use harmony integrate two replicates prior clustering, also include results without integration. general section follows generic Seurat clustering workflow.  can see PCA-based clustering separates replicate, whereas harmony-based clustering results clusters originating replicates.","code":"# change the assay to the gene counts matrix DefaultAssay(seurat_obj) <- 'RNA'  # run normalization, feature selection, scaling, and linear dimensional reduction seurat_obj <- seurat_obj %>%   NormalizeData() %>%   FindVariableFeatures() %>%   ScaleData() %>%   RunPCA(reduction.name = 'pca_RNA')  # run harmony to integrate the two replicates seurat_obj <- RunHarmony(   seurat_obj,    group.by.vars = 'Sample',   reduction = 'pca_RNA',   reduction.save = 'harmony_RNA',   assay.use = 'RNA' )  # run UMAP seurat_obj <- RunUMAP(   seurat_obj,   dims=1:30,   min.dist=0.3,   reduction='harmony_RNA',   reduction.name = 'umap_RNA' )  # run clustering seurat_obj <- FindNeighbors(seurat_obj, dims = 1:30, reduction='harmony_RNA') seurat_obj <- FindClusters(seurat_obj, resolution = 0.5) seurat_obj$seurat_clusters_RNA <- seurat_obj$seurat_clusters  # plot clusters and samples on the UMAP p1 <- DimPlot(seurat_obj, group.by = 'seurat_clusters_RNA', label=TRUE, reduction='umap_RNA')  +    NoLegend() p2 <- DimPlot(seurat_obj, group.by = 'Sample', label=TRUE, reduction='umap_RNA') +   NoLegend() p3 <- FeaturePlot(seurat_obj, features='nCount_RNA', reduction='umap_RNA', order=TRUE)   # show the plots p1 | p2 | p3 # run UMAP seurat_obj <- RunUMAP(   seurat_obj,   dims=1:30,   min.dist=0.3,   reduction='pca_RNA',   reduction.name = 'umap_pca' )  # run clustering seurat_obj <- FindNeighbors(seurat_obj, dims = 1:30, reduction='pca_RNA', graph.name = c('pca_nn', 'pca_snn')) seurat_obj <- FindClusters(seurat_obj, resolution = 0.5, graph.name='pca_snn') seurat_obj$seurat_clusters_pca <- seurat_obj$seurat_clusters  # plot clusters and samples on the UMAP p1 <- DimPlot(seurat_obj, group.by = 'Sample', label=TRUE, reduction='umap_pca')  +    NoLegend() p2 <- DimPlot(seurat_obj, group.by = 'seurat_clusters_pca', label=TRUE, reduction='umap_pca')  +    NoLegend() + ggtitle('PCA') p3 <- DimPlot(seurat_obj, group.by = 'Sample', label=TRUE, reduction='umap_RNA') +   NoLegend() p4 <- DimPlot(seurat_obj, group.by = 'seurat_clusters_RNA', label=TRUE, reduction='umap_RNA') +   NoLegend() + ggtitle('Harmony')  # show the plots (p1 | p2) / (p3 | p4)"},{"path":"https://smorabit.github.io/hdWGCNA/articles/isoform_pbmcs.html","id":"clustering-on-isoform-counts-matrix","dir":"Articles","previous_headings":"Seurat clustering analysis","what":"Clustering on isoform counts matrix","title":"Isoform co-expression network analysis with PacBio MAS-Seq","text":"section, perform Seurat clustering analysis isoform counts matrix. use nearly steps gene counts matrix, however tackle feature selection step slightly different way. particular dataset, many isoforms expressed much higher one replicate , variance expression picked FindVariableFeatures function. Therefore, running FindVariableFeatures followed rest clustering steps result clusters separate replicate, even running Harmony (show analysis , run fun exercise). Instead, run FindVariableFeatures separately replicate take intersection variable isoforms analysis, giving us set variable isoforms whole dataset. rest steps identical gene-level analysis.  visualize isoform-level clustering gene-level clustering isoform UMAP, can see qualitatively appears overlap cluster assignments. Without analysis, immediately obvious clustering better seem separate major cell populations PBMC dataset.","code":"# switch to the isoform assay  DefaultAssay(seurat_obj) <- 'iso'  # log normalize data seurat_obj <- NormalizeData(seurat_obj)  # Get top 20k variable isoforms in each sample and take the intersection selected_features <- lapply(SplitObject(seurat_obj, split.by = 'Sample'), function(x){   FindVariableFeatures(x, nfeatures=20000) %>% VariableFeatures }) VariableFeatures(seurat_obj) <- Reduce(intersect, selected_features)  # scale data and run PCA seurat_obj <- seurat_obj %>%   ScaleData() %>%   RunPCA(reduction.name='pca_iso')  # run harmony seurat_obj <- RunHarmony(   seurat_obj,   group.by.vars = 'Sample',   reduction='pca_iso',   assay.use = 'iso',   reduction.save = 'harmony_iso' )  # run umap seurat_obj <- RunUMAP(   seurat_obj,   dims=1:30,   min.dist=0.3,   reduction='harmony_iso',   reduction.name='umap_iso' )  # clustering seurat_obj <- FindNeighbors(   seurat_obj, dims = 1:30,   reduction='harmony_iso', graph.name = c('iso_nn', 'iso_snn') ) seurat_obj <- FindClusters(seurat_obj, resolution = 0.5, graph.name='iso_snn') seurat_obj$seurat_clusters_iso <- seurat_obj$seurat_clusters  # plot clusters and samples on the UMAP p1 <- DimPlot(seurat_obj, group.by = 'seurat_clusters_iso', label=TRUE, reduction='umap_iso') +   NoLegend() p2 <- DimPlot(seurat_obj, group.by = 'seurat_clusters_RNA', label=TRUE, reduction='umap_iso') + NoLegend() p3 <- DimPlot(seurat_obj, group.by = 'Sample', label=TRUE, reduction='umap_iso') +   NoLegend() p4 <- FeaturePlot(seurat_obj, features='nCount_iso', reduction='umap_iso')  # assemble with patchwork (p1 | p2) / (p3 | p4)"},{"path":"https://smorabit.github.io/hdWGCNA/articles/isoform_pbmcs.html","id":"multimodal-clustering-with-genes-and-isoforms","dir":"Articles","previous_headings":"Seurat clustering analysis > Clustering on isoform counts matrix","what":"Multimodal clustering with genes and isoforms","title":"Isoform co-expression network analysis with PacBio MAS-Seq","text":"Seurat includes functionality multimodal clustering analysis using algorithm called Weighted Nearest Neighbors (WNN) create cell graph accounting information two assays simultaneously. used Seurat authors CITE-Seq data RNA + ATAC multiome data success, clear help us better characterize long-read single-cell data. follow major steps Seurat WNN tutorial perform multimodal clustering analysis using gene isoform assays. Note analysis first requires already processed assays interest.  Qualitatively, side--side comparison three clustering analysis shows similar results, note milage may vary depending particular tissue system interest. WNN outputs cell-specific modality weights tell us relative information content cell modality. weight 0 1 close 0 means information come isoform assay, close 1 means information come gene assay, close 0.5 means assays provide similar levels information. visualize distributions weights WNN clusters.  appears genes + isoforms WNN analysis, seem huge advantage using information assays simultaneously, can see median groups near 0.5. Cluster 8 highest median RNA.weight = 0.574, cluster may occluded isoform-level clustering analysis. can use Sankey diagram compare clustering assignments three separate analyses. Note step necessary can skipped.  appears WNN cluster 8 grouped together another cluster isoform-level analysis, separated RNA WNN analyses. Thus far performed three different clustering analyses demonstrate different ways analyzing long-read single-cell data, want note thorough quantitative comparison different approaches ultimately clear method superior. remainder tutorial, going use UMAP clustering gene-level analysis, just easily done isoform-level clusters WNN clusters likely similar results.","code":"# switch back to genes assay DefaultAssay(seurat_obj) <- 'RNA'  # run the WNN seurat_obj <- FindMultiModalNeighbors(   seurat_obj, reduction.list = list(\"harmony_RNA\", \"harmony_iso\"),   dims.list = list(1:30, 1:30), modality.weight.name = \"RNA.weight\" )  # UMAP and clustering, make sure to use the WNN output! seurat_obj <- RunUMAP(   seurat_obj,   nn.name = \"weighted.nn\",   reduction.name = \"wnn.umap\",   reduction.key = \"wnnUMAP_\" ) seurat_obj <- FindClusters(   seurat_obj,   graph.name = \"wsnn\",   algorithm = 3,   resolution = 0.5,   verbose = FALSE ) seurat_obj$seurat_clusters_wnn <- seurat_obj$seurat_clusters  # plot clusters from each analysis on the respective UMAPs p1 <- DimPlot(seurat_obj, group.by = 'seurat_clusters_RNA', label=TRUE, reduction='umap_RNA') +    NoLegend() + ggtitle('Gene-level clusters') p2 <- DimPlot(seurat_obj, group.by = 'seurat_clusters_iso', label=TRUE, reduction='umap_iso') +    NoLegend() + ggtitle('Isoform-level clusters') p3 <- DimPlot(seurat_obj, group.by = 'seurat_clusters_wnn', label=TRUE, reduction='wnn.umap') +    NoLegend() + ggtitle('Gene + Isoform WNN')   # assemble with patchwork p1 | p2 | p3 p <- VlnPlot(   seurat_obj,   features = \"RNA.weight\",   group.by = 'seurat_clusters_wnn',   sort = TRUE,   pt.size=0) +    NoLegend() +   geom_boxplot(notch=TRUE, fill=NA, outlier.shape=NA) +   geom_hline(yintercept=0.5, linetype='dashed', color='black') +   xlab('WNN clusters')  p # install ggsankey if necessary # install.packages(\"remotes\") # remotes::install_github(\"davidsjoberg/ggsankey\")  library(ggsankey)  df <- seurat_obj@meta.data %>%    ggsankey::make_long(seurat_clusters_RNA, seurat_clusters_wnn, seurat_clusters_iso)  p <- ggplot(df, aes(x = x,                 next_x = next_x,                 node = node,                 next_node = next_node,                fill = factor(node),                label = node)) +   geom_sankey() +   geom_sankey_label(size=2) +   theme_sankey(base_size = 16) + NoLegend() +   scale_x_discrete(labels=c(     'seurat_clusters_RNA' = 'Genes',     'seurat_clusters_wnn' = 'WNN',     'seurat_clusters_iso' = 'Isoforms'     ))   p"},{"path":"https://smorabit.github.io/hdWGCNA/articles/isoform_pbmcs.html","id":"cell-type-annotation","dir":"Articles","previous_headings":"Seurat clustering analysis","what":"Cell type annotation","title":"Isoform co-expression network analysis with PacBio MAS-Seq","text":"section manually assign cell-type labels cluster. inspected expression levels many different known PBMC marker genes obtained Azimuth assign cluster cell type label. Note can also done automatically using transfer learning algorithms reasonable reference dataset. generated file called pbmc_annotations.txt containing following table based marker gene expression profiles. Next add information Seurat object plot labels UMAP.  now finished Seurat clustering part tutorial, good idea save Seurat object point moving network analysis.","code":"# list of selected cell type markers for different PBMC populations # note that this is not a comprehensive list! markers = list( 'ASDC_mDC'= c('AXL', 'LILRA4', 'SCN9A', 'CLEC4C'), 'ASDC_pDC'=c('SCT', 'PROC', 'LTK'), 'cDC'= c('CD14', 'FCER1A', 'CLEC10A', 'ENHO', 'CD1C'), 'Eryth'= c('HBM', 'HBD', 'SNCA', 'ALAS2'), 'Mature B'= c('MS4A1', 'IGKC', 'IGHM', 'CD24', 'CD22'), 'Memory B'= c('BANK1', 'CD79A', 'SSPN'), 'Naive B'= c('TCL1A', 'IGHD', 'IL4R', 'CD79B'), 'CD14 Mono'= c('LYZ', 'CTSD', 'VCAN', 'CTSS'), 'CD16 Mono'= c('LST1', 'YBX1', 'AIF1', 'MS4A7'), 'CD4 CTL'= c('GZMH', 'CD4', 'GNLY', 'IL7R', 'CCL5'), 'CD4+ Naive T'= c('TCF7', 'LEF1', 'NUCB2', 'LDHB'), 'Proliferating T'= c('PCLAF', 'CD8B', 'CD3D', 'TRAC', 'CLSPN'), 'CD8 TCM'= c('CD8A', 'SELL', 'ITGB1', 'CD8'), 'gDT'= c('TRDC', 'TRGV9', 'TRDV2', 'KLRD1'), 'MAIT'= c('KLRB1', 'NKG7', 'GZMK', 'SLC4A10', 'NCR3', 'CTSW', 'KLRG1', 'CEBPD', 'DUSP2'), 'NK'= c('STMN1', 'KLRC2', 'S100A4', 'CD3E', 'CST7'), 'Plasmablast'= c('TYMS', 'TK1', 'ASPM', 'SHCBP1', 'TPX2'), 'Platelet'= c('GNG11', 'PPBP', 'NRGN', 'PF4', 'TUBB1', 'CLU'), 'Treg'= c('B2M', 'FOXP3', 'RTKN2', 'TIGIT', 'CTLA4'), 'Basophil'= c('KIT', 'CPA3', 'TPSAB1', 'CD44', 'GATA2', 'GRAP2') )  # make a dotplot for each set of markers plot_list <- lapply(names(markers), function(x){   DotPlot(     seurat_obj,     features = markers[[x]],     group.by = 'seurat_clusters_RNA'   ) + coord_flip() + ggtitle(x) })  # plot the results and save to a .pdf to inspect the results. pdf(paste0(fig_dir, 'dotplot_markers.pdf'), width=6, height=3) for(p in plot_list){   print(p) } dev.off() annotations <- read.table(paste0('data/pbmc_annotations.txt'), header=TRUE, sep='\\t') ix <- match(seurat_obj$seurat_clusters_RNA, annotations$seurat_cluster) seurat_obj$annotation <- annotations$annotation[ix] seurat_obj$cell_type <- annotations$cell_type[ix]  # plot clusters and samples on the UMAP p1 <- DimPlot(seurat_obj, group.by = 'cell_type', label=TRUE, reduction='umap_RNA') +   NoLegend() p2 <- DimPlot(seurat_obj, group.by = 'annotation', label=TRUE, repel=TRUE, reduction='umap_RNA') +   NoLegend()  # assemble with patchwork p1 | p2 saveRDS(seurat_obj, file = 'PBMC_masseq_processed_seurat.rds')"},{"path":"https://smorabit.github.io/hdWGCNA/articles/isoform_pbmcs.html","id":"isoform-co-expression-network-analysis","dir":"Articles","previous_headings":"","what":"Isoform co-expression network analysis","title":"Isoform co-expression network analysis with PacBio MAS-Seq","text":"section, perform isofom co-expression network analysis hdWGCNA. cover several different approaches tutorial. general, isoform network analysis complicated gene co-expression network analysis since working larger data matrix start . dataset, isoform matrix roughly ten times number features gene matrix. Since networks represented features--features square matrices, extremely computationally challenging compute represent full isoform co-expression network. Additionally, many isoforms expressed low levels, like ordinary scRNA-seq technical data sparsity well. reasons, carefully consider isoforms cell populations include co-expression network analysis. Variable features PBMC clusters Major isoforms cluster marker genes PBMC clusters major isoforms NK cells proceeding, need remove smallest cell populations cause trouble metacell grouping step. also need load relevant libraries running hdWGCNA, enable multithreading (optional) speed processing time.","code":"library(WGCNA) library(igraph) library(hdWGCNA) enableWGCNAThreads(nThreads = 8)  # re-load processed Seurat object: seurat_obj <- readRDS('PBMC_masseq_processed_seurat.rds')  # subset to remove the smallest cell types seurat_obj <- seurat_obj[,!(seurat_obj$annotation %in% c('DC', 'Platelet'))]"},{"path":"https://smorabit.github.io/hdWGCNA/articles/isoform_pbmcs.html","id":"example-1-variable-features-in-all-pbmcs","dir":"Articles","previous_headings":"Isoform co-expression network analysis","what":"Example 1: Variable Features in all PBMCs","title":"Isoform co-expression network analysis with PacBio MAS-Seq","text":"First, demonstrate isoform co-expression network analysis using variable features input set isoforms, use PBMCs. Similar clustering analysis, identify variable isoforms separately sample take intersection feature set. However, like use features network analysis, increase number variable features 50000. approach gives us 9265 isoforms perform network analysis . Next run SetupForWGCNA function indicate want use variable features set input features network analysis. also perform metacell aggregation MetacellsByGroups function, specifying assay=\"iso\" order obtain metacells isoforms matrix. Next specify cell groups used network analysis set expression matrix using SetDatExpr. Note setting group_name = unique(seurat_obj$cell_type) order use cell types single network analysis. ensure specify assay='iso' isoform-level analysis. run TestSoftPowers function find suitable values soft_power parameter.  Now ready construct network, compute module eigenisoforms (MEiso), compute eigenisoform-based connectivities (kMEiso).  now constructed isoform co-expression network, can now perform downstream analysis better characterize understand network isoform modules. move another way isoform co-expression network analysis, plot MEiso values module cluster DotPlot, use RunModuleUMAP visualize isoform co-expression network two dimensions.","code":"# switch to isoform assay: DefaultAssay(seurat_obj) <- 'iso'  # Get top 50k variable isoforms in each sample and take the intersection selected_features <- lapply(SplitObject(seurat_obj, split.by = 'Sample'), function(x){   FindVariableFeatures(x, nfeatures=50000) %>% VariableFeatures }) VariableFeatures(seurat_obj) <- Reduce(intersect, selected_features) length(VariableFeatures(seurat_obj)) [1] 9265 # setup this hdWGCNA experiment seurat_obj <- SetupForWGCNA(   seurat_obj,   gene_select = \"variable\",   wgcna_name = \"variable\", )  # construct metacells: seurat_obj <- MetacellsByGroups(   seurat_obj = seurat_obj,   group.by = c(\"annotation\", \"cell_type\", \"Sample\"),   k = 50,   max_shared=25,   min_cells=75,   reduction = 'harmony_RNA',   ident.group = 'annotation',   assay = 'iso',   mode = 'sum',   target_metacells=150 ) seurat_obj <- NormalizeMetacells(seurat_obj) # get list of cell populations groups <- unique(GetMetacellObject(seurat_obj)$annotation)  # set up gene expression matrix seurat_obj <- SetDatExpr(   seurat_obj,   group.by='cell_type',   group_name = groups,   use_metacells=TRUE,   slot = 'data',   assay = 'iso' )  # test soft powers seurat_obj <- TestSoftPowers(seurat_obj) plot_list <- PlotSoftPowers(seurat_obj)  # assemble with patchwork wrap_plots(plot_list, ncol=2) # construct wgcna network: seurat_obj <- ConstructNetwork(   seurat_obj,   soft_power=5,   setDatExpr=FALSE,   detectCutHeight=0.995,   mergeCutHeight=0.05,   TOM_name = 'variable',   minModuleSize=30,   overwrite_tom = TRUE )  # plot the dendrogram PlotDendrogram(seurat_obj, main='hdWGCNA Dendrogram')       # note: we have to run ScaleData or else harmony won't work in the ModuleEigengenes function seurat_obj <- ScaleData(seurat_obj, features=rownames(seurat_obj)[1:100])  # harmony correction by Sample seurat_obj <- ModuleEigengenes(   seurat_obj,   group.by.vars = 'Sample',   verbose=TRUE )         # compute module connectivity: modules_orig <- GetModules(seurat_obj) seurat_obj <- ModuleConnectivity(seurat_obj) modules <- GetModules(seurat_obj) # get the MEisos from the seurat object and add it to the metadata MEiso <- GetMEs(seurat_obj) meta <- seurat_obj@meta.data seurat_obj@meta.data <- cbind(meta, MEiso)  # get a list of features to plot modules <- GetModules(seurat_obj) mods <- levels(modules$module) mods <- mods[mods!='grey']  # make dotplot p <- DotPlot(   seurat_obj,   group.by='annotation',   features = rev(mods) ) + RotatedAxis() +   scale_color_gradient2(high='red', mid='grey95', low='blue') + xlab('') + ylab('') +   theme(     plot.title = element_text(hjust = 0.5),     axis.line.x = element_blank(),     axis.line.y = element_blank(),     panel.border = element_rect(colour = \"black\", fill=NA, size=1)   )  # show plot p  # restore the original metadata seurat_obj@meta.data <- meta seurat_obj <- RunModuleUMAP(   seurat_obj,   n_hubs =5,   n_neighbors=15,   min_dist=0.2,   spread=1   #supervised=TRUE,   #target_weight=0.5 )   # get the hub gene UMAP table from the seurat object umap_df <- GetModuleUMAP(   seurat_obj )  # plot with ggplot p <- ggplot(umap_df, aes(x=UMAP1, y=UMAP2)) +   geom_point(    color=umap_df$color,    size=umap_df$kME*2   ) +   umap_theme()  pdf(paste0(fig_dir, 'variable_test_hubgene_umap_ggplot_uns.pdf'), width=5, height=5) p dev.off()  png(paste0(fig_dir, 'variable_coex_umap.png'), width=6, height=6, units='in', res=500) ModuleUMAPPlot(   seurat_obj,   edge.alpha=0.5,   sample_edges=TRUE,   keep_grey_edges=FALSE,   edge_prop=0.075, # taking the top 20% strongest edges in each module #   label_genes = umap_df$isoform_name[umap_df$gene_name %in% plot_genes],   #label_genes = c(''),   label_hubs=2 # how many hub genes to plot per module? ) dev.off()  saveRDS(seurat_obj, file=paste0(data_dir, 'PBMC_masseq_hdWGCNA_wip.rds'))"},{"path":"https://smorabit.github.io/hdWGCNA/articles/isoform_pbmcs.html","id":"example-2-major-isoforms-of-cluster-marker-genes-in-all-pbmcs","dir":"Articles","previous_headings":"Isoform co-expression network analysis","what":"Example 2: Major isoforms of cluster marker genes in all PBMCs","title":"Isoform co-expression network analysis with PacBio MAS-Seq","text":"use different approach obtaining list input isoforms hdWGCNA. first identify Major Isoforms, defined set isoforms accounting 80% gene’s total expression. Major isoforms identified gene cell population, 80% threshold parameter can tweaked. hdWGCNA includes FindMajorIsoforms, function call major isoforms Seurat object. set major isoforms across cell populations may still contain feature set challenging perform network analysis due size. Therefore, tutorial intersect major isoform list cluster marker gene list, giving us set major isoforms cell population’s marker genes. following block code, run Seurat’s FindAllMarkers function RNA assay get marker gene table. Note identifying marker genes marker isoforms step. Next, run FindMajorIsoforms identify major isoforms cluster marker genes, set Seurat object new hdWGCNA experiment using isoforms input features. approach gives us 13217 isoforms network analysis. Now run main steps co-expression network analysis hdWGCNA similarly previous section.  Next visualize MEiso signatures module cell population using DotPlot.","code":"# switch to the RNA assay because we want marker genes DefaultAssay(seurat_obj) <- 'RNA'  # change the idents to your desired clusters, cell annotations, etc Idents(seurat_obj) <- seurat_obj$annotation  # Run FindAllMarkers to get cluster marker genes!! cluster_markers <- FindAllMarkers(   seurat_obj,   logfc.threshold = 0.5,   min.pct = 0.1 )  # save your cluster markers as a table cluster_markers <- read.csv(file='data/cluster_markers.csv') cluster_markers <- subset(cluster_markers, !(cluster %in% c('DC', 'Platelet'))) library(magrittr)  # get the list of major isoforms in each cell population # intersected with the cluster_markers table major_list <- FindMajorIsoforms(   seurat_obj,   group.by = 'annotation',    replicate_col = 'Sample',   isoform_delim = '[.]',   cluster_markers = cluster_markers ) major_marker_list <- major_list[[2]] major_list <- major_list[[1]]  # merge into a single list of features for hdWGCNA selected_isoforms <- unique(unlist(major_marker_list))  # setup for WGCNA seurat_obj <- SetupForWGCNA(   seurat_obj,   gene_select = \"custom\",   gene_list = selected_isoforms,   metacell_location = 'variable', # this will use the same Metacell seurat object that we made before   wgcna_name = \"major\" )  # how many isoforms? length(selected_isoforms) [1] 13217 # set up expression matrix groups <- unique(GetMetacellObject(seurat_obj)$annotation) seurat_obj <- SetDatExpr(   seurat_obj,   group.by='annotation',   group_name = groups,   use_metacells=TRUE,   slot = 'data',   assay = 'iso' )  # test soft powers seurat_obj <- TestSoftPowers(seurat_obj,) plot_list <- PlotSoftPowers(seurat_obj) wrap_plots(plot_list, ncol=2)  # construct wgcna network: seurat_obj <- ConstructNetwork(   seurat_obj,   soft_power = 5,   detectCutHeight=0.995,   mergeCutHeight=0.05,   TOM_name = 'major',   minModuleSize=30,   overwrite_tom = TRUE )  # plot the dendrogram PlotDendrogram(seurat_obj, main='hdWGCNA Dendrogram')  # have to have this ScaleData line or else Harmony gets angry seurat_obj <- ScaleData(seurat_obj, features=rownames(seurat_obj)[1:100]) seurat_obj <- ModuleEigengenes(seurat_obj, group.by.vars = 'Sample')  # compute module connectivity: seurat_obj <- ModuleConnectivity(seurat_obj) MEs <- GetMEs(seurat_obj) modules <- GetModules(seurat_obj) mods <- levels(modules$module) mods <- mods[mods!='grey']  meta <- seurat_obj@meta.data seurat_obj@meta.data <- cbind(meta, MEs)   # make dotplot p <- DotPlot(   seurat_obj,   group.by='annotation',   features = rev(mods) ) + RotatedAxis() +   scale_color_gradient2(high='red', mid='grey95', low='blue') + xlab('') + ylab('') +   theme(     plot.title = element_text(hjust = 0.5),     axis.line.x = element_blank(),     axis.line.y = element_blank(),     panel.border = element_rect(colour = \"black\", fill=NA, size=1)   )  p seurat_obj@meta.data <- meta   seurat_obj <- RunModuleUMAP(   seurat_obj,   n_hubs =5,   n_neighbors=15,   min_dist=0.2,   spread=1   #supervised=TRUE,   #target_weight=0.5 )   # get the hub gene UMAP table from the seurat object umap_df <- GetModuleUMAP(   seurat_obj )  # plot with ggplot p <- ggplot(umap_df, aes(x=UMAP1, y=UMAP2)) +   geom_point(    color=umap_df$color,    size=umap_df$kME*2   ) +   umap_theme()  pdf(paste0(fig_dir, 'major_iso_hubgene_umap_ggplot_uns.pdf'), width=5, height=5) p dev.off()  png(paste0(fig_dir, 'major_coex_umap.png'), width=7, height=7, units='in', res=500) ModuleUMAPPlot(   seurat_obj,   edge.alpha=0.5,   sample_edges=TRUE,   keep_grey_edges=FALSE,   edge_prop=0.075, # taking the top 20% strongest edges in each module #   label_genes = umap_df$isoform_name[umap_df$gene_name %in% plot_genes],   #label_genes = c(''),   label_hubs=2 # how many hub genes to plot per module? ) dev.off()   # individual module networks ModuleNetworkPlot(   seurat_obj,   mods = \"all\",   #label_center=TRUE,   outdir = paste0(fig_dir, 'hubNetworks/') )   saveRDS(seurat_obj, file = paste0(data_dir, 'PBMC_masseq_hdWGCNA_wip.rds')) seurat_obj <- readRDS(file = 'tutorial_data/PBMC_masseq_hdWGCNA_major.rds')"},{"path":"https://smorabit.github.io/hdWGCNA/articles/module_preservation.html","id":"module-preservation-analysis","dir":"Articles","previous_headings":"","what":"Module preservation analysis","title":"Module preservation and reproducibility","text":"2011 paper titled “Network Module Preserved Reproducible?”, Langfelder et al discuss statistical methods module preservation analysis co-expression network analysis. Notably, module preservation analysis can used assess reproducibility co-expression networks, can also used specific biological analyses, example identify modules significantly preserved across different disease conditions, tissues, developmental stages, even evolutionary time. first step module preservation analysis project modules reference query dataset, explained detail previous tutorial. Next, set expression matrices query reference datasets. Either single-cell metacell gene expression matrices can used setting use_metacells flag SetDatExpr. general recommend using matrix used construct network reference (case, metacell matrix). already constructed metacells query dataset, can prior module preservation analysis. Now can run ModulePreservation function. Note function take run since permutation test, can sped lowering n_permutations parameter, recommend lower 100 permutations. Also note parallel option currently work. demonstration purposes, ran code tutorial using 20 permutations run quickly. ModulePreservation takes name parameter, used store results module perturbation test.","code":"seurat_query <- ProjectModules(   seurat_obj = seurat_query,   seurat_ref = seurat_ref,   wgcna_name = \"tutorial\",   wgcna_name_proj=\"projected\",   assay=\"RNA\" # assay for query dataset ) # construct metacells: seurat_query <- MetacellsByGroups(   seurat_obj = seurat_query,   group.by = c(\"cell_type\", \"Sample\"),   k = 25,   max_shared = 12,   reduction = 'harmony',   ident.group = 'cell_type' ) seurat_query <- NormalizeMetacells(seurat_query) # set expression matrix for reference dataset seurat_ref <- SetDatExpr(   seurat_ref,   group_name = \"INH\",   group.by = \"cell_type\" )  # set expression matrix for query dataset: seurat_query <- SetDatExpr(   seurat_query,   group_name = \"INH\",   group.by = \"cell_type\" ) # run module preservation function seurat_query <- ModulePreservation(   seurat_query,   seurat_ref = seurat_ref,   name=\"Zhou-INH\",   verbose=3,   n_permutations=250 # n_permutations=20 used for the tutorial )"},{"path":"https://smorabit.github.io/hdWGCNA/articles/module_preservation.html","id":"visualize-preservation-stats","dir":"Articles","previous_headings":"","what":"Visualize preservation stats","title":"Module preservation and reproducibility","text":"module perturbation test produces number different preservation statistics, can inspect following tables. past linked original WGCNA documentation website detailed explanations thes statistics, unfortunately time writing tutorial website taken offline. Please refer original publication PLOS Computational Biology explanations. hdWGCNA includes function PlotModulePreservation visualize statistics computed previous section. function generates scatter plot showing module size versus module preservation stats. summary statistics aggregate individual preservation quality statistics single metric generally recommend primarily interpreting results plots.  can see three different shades background. represent cutoff values interpreting Z summary statistics. following guidelines help us understand preservation modules. Z > 2, module preserved query dataset. 10 > Z > 2, module moderately preserved query dataset. Z > 10, module highly preserved query dataset. following code shows plot additional module preservation stats.  Plot different stats:","code":"# get the module preservation table mod_pres <- GetModulePreservation(seurat_query, \"Zhou-INH\")$Z obs_df <- GetModulePreservation(seurat_query, \"Zhou-INH\")$obs plot_list <- PlotModulePreservation(   seurat_query,   name=\"Zhou-INH\",   statistics = \"summary\" )  wrap_plots(plot_list, ncol=2) # plot ranking stats plot_list <- PlotModulePreservation(   seurat_query,   name=\"Zhou-INH\",   statistics = \"rank\" )   wrap_plots(plot_list, ncol=2) plot_list <- PlotModulePreservation(   seurat_query,   name=\"Zhou-INH\",   statistics = \"all\",   plot_labels=FALSE )  wrap_plots(plot_list, ncol=6)"},{"path":"https://smorabit.github.io/hdWGCNA/articles/module_preservation.html","id":"module-preservation-analysis-with-netrep","dir":"Articles","previous_headings":"","what":"Module preservation analysis with NetRep","title":"Module preservation and reproducibility","text":"include alternative method performing module preservation analysis using R package NetRep. 2016 paper titled “Scalable Permutation Approach Reveals Replication Preservation Patterns Network Modules Large Datasets”, Ritchie et al. introduced relatively faster approach module preservation. paper, authors also show method improved false discovery control. include function ModulePreservationNetRep order perform analysis hdWGCNA. NetRep included dependency hdWGCNA since used analyses, must install NetRep proceeding. use method research, encourage properly cite NetRep paper. Please consult NetRep GitHub repository details. One important difference two implementations module preservation analysis NetRep requires topological overlap matrix (TOM) query reference datasets. order satisfy requirement, first perform standard hdWGCNA analysis query dataset. Next can run ModulePreservationNetRep function perform module preservation analysis using NetRep method. approach reports preservation statistics module, case significant p-value indicates given module significantly preserved. NetRep reports p-values seven different network attributes, can see specifically attributes preserved . get overall result module preservation, compute average different p-values. Next plot resulting statistics using function PlotModulePreservationLollipop.  plot shows us module ranked well module preserved query dataset. x-axis showing us averaged FDR-corrected p-values different network attributes module result composite statistic. size dot corresponds number genes module. can also use function plot individual statistics. demonstration also set fdr=FALSE show look raw p-value rather FDR-corrected p-value based user’s preference.","code":"# install install.packages('NetRep') # use the genes from the ref dataset genes_use <- GetWGCNAGenes(seurat_ref) seurat_query <- SetupForWGCNA(   seurat_query,   features = genes_use,   wgcna_name = \"INH\" )  # construct metacells: seurat_query <- MetacellsByGroups(   seurat_obj = seurat_query,   group.by = c(\"cell_type\", \"Sample\"),   k = 25,   max_shared = 12,   reduction = 'harmony',   ident.group = 'cell_type' ) seurat_query <- NormalizeMetacells(seurat_query)   seurat_query <- SetDatExpr(   seurat_query,   group_name = \"INH\",    group.by='cell_type' )  # Test different soft powers: seurat_query <- TestSoftPowers(   seurat_query,   networkType = 'signed' )  # construct co-expression network: seurat_query <- ConstructNetwork(   seurat_query,   tom_name = 'INH_query',   overwrite_tom=TRUE  )  # compute all MEs in the full single-cell dataset seurat_query <- ModuleEigengenes(seurat_query)  # compute eigengene-based connectivity (kME): seurat_query <- hdWGCNA::ModuleConnectivity(   seurat_query,   group.by = 'cell_type', group_name = 'INH' )  # reset the active WGCNA to projected seurat_query <- SetActiveWGCNA(seurat_query, 'projected') # run NetRep module preservation seurat_query <- ModulePreservationNetRep(   seurat_query,   seurat_ref,   name = 'testing_NetRep',   n_permutations = 5000,   n_threads=8, # number of threads to run in Parallel   TOM_use=\"INH\", # specify the name of the hdWGCNA experiment that contains the TOM for the query dataset   wgcna_name = 'projected',   wgcna_name_ref = 'tutorial' )  # access the results: mod_pres <- GetModulePreservation(seurat_query, 'testing_NetRep', 'projected')  # access statistics for each module: mod_pres$p.values PlotModulePreservationLollipop(   seurat_query,    name='testing_NetRep',   features='average',   wgcna_name='projected' ) + RotatedAxis() + NoLegend() # get the module preservation results mod_pres <- GetModulePreservation(seurat_query, 'testing_NetRep', 'projected')  # get the names of the statistics to plot plot_features <- c('average', colnames(mod_pres$p.value))  # loop through each statistic  plot_list <- list() for(cur_feature in plot_features){     plot_list[[cur_feature]] <- PlotModulePreservationLollipop(     seurat_query,      name='testing_NetRep',     features=cur_feature,     fdr=FALSE,     wgcna_name='projected'   ) + RotatedAxis() + NoLegend() }  # assemble the final plot wrap_plots(plot_list, ncol=4)"},{"path":"https://smorabit.github.io/hdWGCNA/articles/module_preservation.html","id":"module-topology-comparisons","dir":"Articles","previous_headings":"","what":"Module topology comparisons","title":"Module preservation and reproducibility","text":"demonstrate several functions help visually compare network topology co-expression module two different datasets. can useful visualize modules interest based results module preservation test. function ModuleTopologyHeatmap generates heatmap showing gene-gene co-expression matrix, either colored correlation value edge weight TOM. plot, genes sorted intramodular connectivity. Additionally, ModuleTopologyBarplot complements showing connectivity gene (network degree kME value) module. make patchwork plot showing correlation heatmap, TOM heatmap, degree barplot, kME barplot module INH-M9, showed significant preservation based module preservation approaches. better visually compare plots side--side, must ensure genes ordered way. order genes based reference dataset.  another example, can create similar plot module significantly preserved query dataset, INH-M2.  module topology plots module INH-M9, overall see similar signals correlation matrix, TOM, degrees kME rankings gene. contrast INH-M2, significantly preserved, signal clearly diminished. plots effectively show us differences similarities co-expression network topology picked module preservation analysis.","code":"# select the module to plot cur_mod <- 'INH-M9'  # plot the correlation matrix in the reference dataset tmp <- ModuleTopologyHeatmap(     seurat_ref,     mod = cur_mod,     matrix = \"Cor\",     order_by = 'degree',     TOM_use = 'tutorial',     wgcna_name = 'tutorial',     high_color = 'red',     type = 'unsigned',     plot_max = 0.75,     return_genes = TRUE # select this option to get the gene order )  # get the plot from the output list p1 <- tmp[[1]] + ggtitle('Reference') + ylab('Correlation') + NoLegend()  # get the gene order from the output list gene_list <- tmp[[2]]  # plot the correlation matrix in the query dataset p2 <- ModuleTopologyHeatmap(     seurat_query,     mod = cur_mod,     matrix = \"Cor\",     order_by = 'degree',     wgcna_name = 'projected',     high_color = 'red',     type = 'unsigned',     plot_max = 0.75,     genes_order = gene_list ) + ggtitle('Query')   # plot the TOM in the reference dataset p3 <- ModuleTopologyHeatmap(     seurat_ref,     mod = cur_mod,     matrix = \"TOM\",     order_by = 'degree',     wgcna_name = 'tutorial',     high_color = 'seagreen',     genes_order = gene_list,     plot_max = 0.05 ) + ylab('Network edge weight') + NoLegend()  # plot the TOM in the query dataset p4 <- ModuleTopologyHeatmap(     seurat_query,     mod = cur_mod,     matrix = \"TOM\",     order_by = 'degree',     TOM_use = 'INH',     wgcna_name = 'projected',     high_color = 'seagreen',     plot_max = 0.05,     genes_order = gene_list )    # plot the degree in the reference dataset p5 <- ModuleTopologyBarplot(     seurat_ref,      mod = cur_mod,     features = 'weighted_degree',     genes_order = gene_list,     wgcna_name = 'tutorial', ) + NoLegend()  # plot the degree in the query dataset p6 <- ModuleTopologyBarplot(     seurat_query,      mod = cur_mod,     features = 'weighted_degree',     genes_order = gene_list,     wgcna_name = 'projected' )+ NoLegend()  # plot the kME in the reference dataset tmp <- ModuleTopologyBarplot(     seurat_ref,      mod = cur_mod,     features = 'kME',     wgcna_name = 'tutorial',     return_genes=TRUE ) p7 <- tmp[[1]] + NoLegend() gene_list2 <- tmp[[2]]  # plot the kME in the query dataset p8 <- ModuleTopologyBarplot(     seurat_query,      mod = cur_mod,     features = 'kME',     genes_order = gene_list2,     wgcna_name = 'projected' )+ NoLegend()  # assemble patch: patch <- (p1 | p2) / (p3 | p4) / (p5 | p6) / (p7 | p8) +      plot_layout(heights=c(3,3,1,1)) &     plot_annotation(title = paste0(cur_mod, ' topology comparison')) &     theme(plot.title=element_text(hjust=0.5)) # select the module to plot cur_mod <- 'INH-M2'  # plot the correlation matrix in the reference dataset tmp <- ModuleTopologyHeatmap(     seurat_ref,     mod = cur_mod,     matrix = \"Cor\",     order_by = 'degree',     TOM_use = 'tutorial',     wgcna_name = 'tutorial',     high_color = 'red',     type = 'unsigned',     plot_max = 0.75,     return_genes = TRUE # select this option to get the gene order )  # get the plot from the output list p1 <- tmp[[1]] + ggtitle('Reference') + ylab('Correlation') + NoLegend()  # get the gene order from the output list gene_list <- tmp[[2]]  # plot the correlation matrix in the query dataset p2 <- ModuleTopologyHeatmap(     seurat_query,     mod = cur_mod,     matrix = \"Cor\",     order_by = 'degree',     wgcna_name = 'projected',     high_color = 'red',     type = 'unsigned',     plot_max = 0.75,     genes_order = gene_list ) + ggtitle('Query')   # plot the TOM in the reference dataset p3 <- ModuleTopologyHeatmap(     seurat_ref,     mod = cur_mod,     matrix = \"TOM\",     order_by = 'degree',     wgcna_name = 'tutorial',     high_color = 'seagreen',     genes_order = gene_list,     plot_max = 0.05 ) + ylab('Network edge weight') + NoLegend()  # plot the TOM in the query dataset p4 <- ModuleTopologyHeatmap(     seurat_query,     mod = cur_mod,     matrix = \"TOM\",     order_by = 'degree',     TOM_use = 'INH',     wgcna_name = 'projected',     high_color = 'seagreen',     plot_max = 0.05,     genes_order = gene_list )    # plot the degree in the reference dataset p5 <- ModuleTopologyBarplot(     seurat_ref,      mod = cur_mod,     features = 'weighted_degree',     genes_order = gene_list,     wgcna_name = 'tutorial', ) + NoLegend()  # plot the degree in the query dataset p6 <- ModuleTopologyBarplot(     seurat_query,      mod = cur_mod,     features = 'weighted_degree',     genes_order = gene_list,     wgcna_name = 'projected' )+ NoLegend()  # plot the kME in the reference dataset tmp <- ModuleTopologyBarplot(     seurat_ref,      mod = cur_mod,     features = 'kME',     wgcna_name = 'tutorial',     return_genes=TRUE ) p7 <- tmp[[1]] + NoLegend() gene_list2 <- tmp[[2]]  # plot the kME in the query dataset p8 <- ModuleTopologyBarplot(     seurat_query,      mod = cur_mod,     features = 'kME',     genes_order = gene_list2,     wgcna_name = 'projected' )+ NoLegend()  # assemble patch: patch <- (p1 | p2) / (p3 | p4) / (p5 | p6) / (p7 | p8) +      plot_layout(heights=c(3,3,1,1)) &     plot_annotation(title = paste0(cur_mod, ' topology comparison')) &     theme(plot.title=element_text(hjust=0.5))"},{"path":"https://smorabit.github.io/hdWGCNA/articles/module_trait_correlation.html","id":"compute-correlations","dir":"Articles","previous_headings":"","what":"Compute correlations","title":"Module Trait Correlation","text":"use function ModuleTraitCorrelation correlate selected variables module eigengenes. function computes correlations specified groupings cells, since can expect variables may correlated certain modules certain cell groups others. certain types variables can used analysis others used. Variables can used Numeric variables Categorical variables 2 categories, “control” “condition”. Categorical variables sequential relationship. example, may “disease stage” category ordered “healthy”, “stage 1”, “stage 2”, “stage 3”, etc. case, must ensure variable stored factor levels set appropriately. Variables can used Categorical variables two categories sequentially linked. example, suppose dataset consiting three strains transgenic mice one control. Categorical variables must converted numeric running correlation, end correlation biologically meaningful since ’s way order three different strains way makes sense numeric variable. case, just set pairwise correlation control strain separately. often “Sample ID” variable indicating cell came sample, variable necessarily make sense order particular way, variable like suitable module-trait correlation analysis. categorical variables used, function prints warning message tell user order categories listed , just make sure makes sense.","code":"# convert sex to factor seurat_obj$msex <- as.factor(seurat_obj$msex)  # convert age_death to numeric seurat_obj$age_death <- as.numeric(seurat_obj$age_death)  # list of traits to correlate cur_traits <- c('braaksc', 'pmi', 'msex', 'age_death', 'doublet_scores', 'nCount_RNA', 'nFeature_RNA', 'total_counts_mt')  seurat_obj <- ModuleTraitCorrelation(   seurat_obj,   traits = cur_traits,   group.by='cell_type' ) Warning message: In ModuleTraitCorrelation(seurat_obj, traits = cur_traits, group.by = \"cell_type\") :   Trait msex is a factor with levels 0, 1. Levels will be converted to numeric IN THIS ORDER for the correlation, is this the expected order?"},{"path":"https://smorabit.github.io/hdWGCNA/articles/module_trait_correlation.html","id":"inspecting-the-output","dir":"Articles","previous_headings":"Compute correlations","what":"Inspecting the output","title":"Module Trait Correlation","text":"can run function GetModuleTraitCorrelation retrieve output function. mt_cor list containing three items; cor holds correlation results, pval holds correlation p-values, fdr holds FDR-corrected p-values. items list element dataframe correlation tests performed.","code":"# get the mt-correlation results mt_cor <- GetModuleTraitCorrelation(seurat_obj)  names(mt_cor) [1] \"cor\"  \"pval\" \"fdr\" names(mt_cor$cor) [1] \"all_cells\" \"INH\"       \"EX\"        \"OPC\"       \"ODC\"       \"ASC\" [7] \"MG\" head(mt_cor$cor$INH[,1:5]) INH-M1       INH-M2       INH-M3      INH-M4        INH-M5 braaksc         0.040786737  0.090483529 -0.032898347  0.07570061 -0.0156434561 pmi             0.018372836 -0.030364143  0.035579410 -0.01642725  0.0004368311 msex           -0.032901606  0.009628401  0.014598909  0.00144740 -0.0126589860 age_death      -0.106830840 -0.154190736  0.000779827 -0.14647123  0.0080354876 doublet_scores  0.005359932  0.004313248 -0.282622533 -0.20010529 -0.2921721048 nCount_RNA     -0.192697871 -0.176522750 -0.427046078 -0.41516830 -0.1119312303"},{"path":"https://smorabit.github.io/hdWGCNA/articles/module_trait_correlation.html","id":"plot-correlation-heatmap","dir":"Articles","previous_headings":"","what":"Plot Correlation Heatmap","title":"Module Trait Correlation","text":"can plot results correlation analysis using PlotModuleTraitCorrelation function. function creates separate heatmap correlation matrices, assembles one plot using patchwork.","code":"PlotModuleTraitCorrelation(   seurat_obj,   label = 'fdr',   label_symbol = 'stars',   text_size = 2,   text_digits = 2,   text_color = 'white',   high_color = 'yellow',   mid_color = 'black',   low_color = 'purple',   plot_max = 0.2,   combine=TRUE )"},{"path":"https://smorabit.github.io/hdWGCNA/articles/network_visualizations.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Network Visualization","text":"tutorial, demonstrate several ways visualizing co-expression networks made hdWGCNA. starting tutorial, make sure constructed co-expression network single-cell tutorial spatial transcriptomics. tutorial covers three main network visualizations functions within hdWGCNA: ModuleNetworkPlot, visualizes separate network plot module, showing top 25 genes kME. HubGeneNetworkPlot, visualizes network comprisng modules given number hub genes per module. ModuleUMAPPlot, visualizes genes co-expression simultaneously using UMAP dimensionality reduction algorithm. Finally, provide guidance making custom network visualizations using ggraph tidygraph packages. visualize anything, first need load data required libraries.","code":"# single-cell analysis package library(Seurat)  # plotting and data science packages library(tidyverse) library(cowplot) library(patchwork) library(magrittr)  # co-expression network analysis packages: library(WGCNA) library(hdWGCNA)  # network analysis & visualization package: library(igraph)  # using the cowplot theme for ggplot theme_set(theme_cowplot())  # set random seed for reproducibility set.seed(12345)  # load the Zhou et al snRNA-seq dataset seurat_obj <- readRDS('data/Zhou_control.rds')"},{"path":"https://smorabit.github.io/hdWGCNA/articles/network_visualizations.html","id":"individual-module-network-plots","dir":"Articles","previous_headings":"","what":"Individual module network plots","title":"Network Visualization","text":"demonstrate using ModuleNetworkPlot function visualize network underlying top 25 hub genes module. default, function creates new folder called “ModuleNetworks”, generates .pdf figure module. parameters can adjust function: can see one network plots looks like:  network, node represents gene, edge represents co-expression relationship two genes network. module network plots colored based color column hdWGCNA module assignment table GetModules(seurat_obj). top 10 hub genes kME placed center plot, remaining 15 genes placed outer circle. Optionally, certain visualization parameters can changed plot: edge.alpha: determines opacity network edges vertex.size: determines size nodes vertex.label.cex: determines font size gene label run function options changed show genes:","code":"ModuleNetworkPlot(   seurat_obj,   outdir = 'ModuleNetworks' ) ModuleNetworkPlot(     seurat_obj,      outdir='ModuleNetworks2', # new folder name     n_inner = 20, # number of genes in inner ring     n_outer = 30, # number of genes in outer ring     n_conns = Inf, # show all of the connections     plot_size=c(10,10), # larger plotting area     vertex.label.cex=1 # font size )"},{"path":"https://smorabit.github.io/hdWGCNA/articles/network_visualizations.html","id":"combined-hub-gene-network-plots","dir":"Articles","previous_headings":"","what":"Combined hub gene network plots","title":"Network Visualization","text":"make network plot combining modules together using HubGeneNetworkPlot function. function takes top n hub genes specified user, randomly selected genes, constructs joint network using force-directed graph drawing algorithm. visual clarity, number edges network can downsampled using edge_prop parameter. following example, visualize top 3 hub genes 6 genes per module.  previous network plot, node represents gene edge represents co-expression relationship. network, color intramodular edges module’s color, intermodular edges gray. opacity edges network scaled strength co-expression relationship. Additional network layout settings can passed layout_with_fr function igraph. user can also specify return_graph = TRUE return igraph object plot using custom code. run HubGeneNetworkPlot , time selecting 5 specific modules:","code":"# hubgene network HubGeneNetworkPlot(   seurat_obj,   n_hubs = 3, n_other=5,   edge_prop = 0.75,   mods = 'all' ) g <- HubGeneNetworkPlot(seurat_obj,  return_graph=TRUE) # get the list of modules: modules <- GetModules(seurat_obj) mods <- levels(modules$module); mods <- mods[mods != 'grey']  # hubgene network HubGeneNetworkPlot(   seurat_obj,   n_hubs = 10, n_other=20,   edge_prop = 0.75,   mods = mods[1:5] # only select 5 modules )"},{"path":"https://smorabit.github.io/hdWGCNA/articles/network_visualizations.html","id":"applying-umap-to-co-expression-networks","dir":"Articles","previous_headings":"","what":"Applying UMAP to co-expression networks","title":"Network Visualization","text":"Previously visualized subset co-expression network emphasis hub genes. , use alternative approach visualize genes co-expression network simultaneously. UMAP suitable method visualizing high-dimensional data two dimensions, apply UMAP embed hdWGCNA network low-dimensional manifold. hdWGCNA includes function RunModuleUMAP run UMAP algorithm hdWGCNA topological overlap matrix (TOM). UMAP analysis, subset columns TOM contain top n hub genes kME module, specified user. Therefore, organization gene UMAP space dependent gene’s connectivity network’s hub genes. function leverages UMAP implementation uwot R package, additional UMAP parameters uwot::umap function min_dist spread can included RunModuleUMAP. following code demonstrates using RunModuleUMAP function 10 hub genes per module: Next make simple visualization UMAP using ggplot2:  plot, point represents single gene. size dot scaled gene’s kME ’s assigned module. ggplot2 sufficient visualize genes module UMAP, visualizing underlying network. can use function ModuleUMAPPlot plot genes co-expression relationships.  plot similar one made ggplot2, showing co-expression network, labeling 2 hub genes module. visual clarity, downsample keep 10% edges network using edge_prop parameter. also allow user also return igraph object make custom plots perform downstream network analysis:","code":"seurat_obj <- RunModuleUMAP(   seurat_obj,   n_hubs = 10, # number of hub genes to include for the UMAP embedding   n_neighbors=15, # neighbors parameter for UMAP   min_dist=0.1 # min distance between points in UMAP space ) # get the hub gene UMAP table from the seurat object umap_df <- GetModuleUMAP(seurat_obj)  # plot with ggplot ggplot(umap_df, aes(x=UMAP1, y=UMAP2)) +   geom_point(    color=umap_df$color, # color each point by WGCNA module    size=umap_df$kME*2 # size of each point based on intramodular connectivity   ) +   umap_theme() ModuleUMAPPlot(   seurat_obj,   edge.alpha=0.25,   sample_edges=TRUE,   edge_prop=0.1, # proportion of edges to sample (20% here)   label_hubs=2 ,# how many hub genes to plot per module?   keep_grey_edges=FALSE  ) g <- ModuleUMAPPlot(seurat_obj,  return_graph=TRUE)"},{"path":"https://smorabit.github.io/hdWGCNA/articles/network_visualizations.html","id":"varying-the-number-of-hub-genes","dir":"Articles","previous_headings":"Applying UMAP to co-expression networks","what":"Varying the number of hub genes","title":"Network Visualization","text":"number hub genes include UMAP calculation influences downstream visualization. use gganimate visually compare UMAPs computed different numbers hub genes.  animation shows UMAPs generated using different numbers hub genes.","code":"# different label weights to test n_hubs <- c(1, 1:10*5)  # loop through different weights df <- data.frame() for(cur_hubs in n_hubs){    # make a module UMAP using different label weights   seurat_obj <- RunModuleUMAP(     seurat_obj,     n_hubs = cur_hubs,     n_neighbors=15,     exclude_grey = TRUE,     min_dist=0.1   )    # add to ongoing dataframe   cur_df <- GetModuleUMAP(seurat_obj)   cur_df$n_hubs <- cur_hubs   df <- rbind(df, cur_df) }  # ggplot animation library library(gganimate)  # plot with ggplot + gganimate p <- ggplot(df, aes(x=UMAP1, y=UMAP2)) +   geom_point(color=df$color, size=df$kME*2 ) +   ggtitle(\"N hubs: {closest_state}\") +   transition_states(     n_hubs,     transition_length = 2,     state_length = 2,     wrap = TRUE   ) +   view_follow() +   enter_fade() +   umap_theme()  animate(p, fps=30, duration=25)"},{"path":"https://smorabit.github.io/hdWGCNA/articles/network_visualizations.html","id":"supervised-umap","dir":"Articles","previous_headings":"Applying UMAP to co-expression networks","what":"Supervised UMAP","title":"Network Visualization","text":"UMAP often used unsupervised approach project data points dimensionally-reduced spaced, can also supply UMAP known labels perform supervised analysis. principal, UMAP can better distinguish different groups data points embedding algorithm aware groupings. Therefore, allow user run supervised UMAP using RunModuleUMAP function, gene’s module assignment supplied label. perform supervised UMAP analysis, set supervised=TRUE, can optionally use target_weight parameter determine much influnce labels final embedding. target_weight closer 0 weights based structure data target_weight closer 1 weights based labels. following code shows run visualize supervised UMAP:  demonstrate supervised UMAP looks like using different weights labels, can make different UMAP several values target_weight compare outputs using gganimate.","code":"# run supervised UMAP: seurat_obj <- RunModuleUMAP(   seurat_obj,   n_hubs = 10,   n_neighbors=15,   min_dist=0.1,   supervised=TRUE,   target_weight=0.5 )  # get the hub gene UMAP table from the seurat object umap_df <- GetModuleUMAP(seurat_obj)  # plot with ggplot ggplot(umap_df, aes(x=UMAP1, y=UMAP2)) +   geom_point(    color=umap_df$color, # color each point by WGCNA module    size=umap_df$kME*2 # size of each point based on intramodular connectivity   ) +   umap_theme() # different label weights to test weights <- 0:10/10  # loop through different weights df <- data.frame() for(cur_weight in weights){    # make a module UMAP using different label weights   seurat_obj <- RunModuleUMAP(     seurat_obj,     n_hubs = 10,     n_neighbors=15,     exclude_grey = TRUE,     min_dist=0.3,     supervised=TRUE,     target_weight = cur_weight   )    # add to ongoing dataframe   cur_df <- GetModuleUMAP(seurat_obj)   cur_df$weight <- cur_weight   df <- rbind(df, cur_df) }  # ggplot animation library library(gganimate)  # plot with ggplot + gganimate p <- ggplot(df, aes(x=UMAP1, y=UMAP2)) +   geom_point(color=df$color, size=df$kME*2 ) +   ggtitle(\"Supervised weight: {closest_state}\") +   transition_states(     weight,     transition_length = 2,     state_length = 2,     wrap = TRUE   ) +   view_follow() +   enter_fade() +   umap_theme()  animate(p, fps=30, duration=25)"},{"path":"https://smorabit.github.io/hdWGCNA/articles/network_visualizations.html","id":"customized-network-plots","dir":"Articles","previous_headings":"","what":"Customized network plots","title":"Network Visualization","text":"many different packages within R beyond making network visualizations aside functions included hdWGCNA. provide guided example creating customized network plot using ggraph tidygraph R packages. Making custom network plot suit specific needs likely require writing custom code, consider part optional advanced topic. example, goal make custom network plot showing genes involved “nervous system development” based Gene Ontology. start simple example gradually different customization options, typical process making customized network plot. principal approach can applied custom list genes.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/articles/network_visualizations.html","id":"setup","dir":"Articles","previous_headings":"Customized network plots","what":"Setup","title":"Network Visualization","text":"First, need install ggraph tidygraph. also need install fgsea order load Gene Ontology lists EnrichR website. Next need get genes associated nervous system development subset co-expression network genes. Please follow link download GO Biological Process 2021 database EnrichR website.","code":"# install fgsea: BiocManager::install('fgsea')  # install tidygraph and ggraph install.packages(c(\"ggraph\", \"tidygraph\"))  # load the packages: library(ggraph) library(tidygraph) # get modules and TOM from the seurat obj modules <- GetModules(seurat_obj) %>%    subset(module != 'grey') %>%    mutate(module = droplevels(module)) mods <- levels(modules$module) TOM <- GetTOM(seurat_obj)  # get module colors for plotting  mod_colors <- dplyr::select(modules, c(module, color)) %>% distinct() mod_cp <- mod_colors$color; names(mod_cp) <- as.character(mod_colors$module)  # load the GO Biological Pathways file (donwloaded from EnrichR website) pathways <- fgsea::gmtPathways('GO_Biological_Process_2021.txt')  # remove GO Term ID for simplicity: names(pathways) <- stringr::str_replace(names(pathways), \" \\\\s*\\\\([^\\\\)]+\\\\)\", \"\")  # selected pathway  cur_pathway <- 'nervous system development'  # get genes in this pathway  cur_genes <- pathways[[cur_pathway]] cur_genes <- cur_genes[cur_genes %in% modules$gene_name]  # subset the TOM  cur_TOM <- TOM[cur_genes,cur_genes]"},{"path":"https://smorabit.github.io/hdWGCNA/articles/network_visualizations.html","id":"basic-network-plot-with-ggraph","dir":"Articles","previous_headings":"Customized network plots","what":"Basic network plot with ggraph","title":"Network Visualization","text":"now co-expression network contains 136 genes interest. Next create graph object igraph tidygraph, make network plot ggraph.  first custom network plot showing 136 genes. node (dot) represents gene, edges (lines) represent co-expression two genes. problems plot make less meaningful. many edges, showing 136*136 co-expression links, resulting graph looks like hairball. links thickness, color, opacity, tell links stronger weaker. nodes colored , tell come module. nodes labeled, may much information effectively display . Let’s try fix problems. Next set edges opacity (alpha) co-expression strength using geom_edge_link color nodes gene’s assigned module using geom_node_point. igrah, can use V(graph) set attributes network’s nodes, order add module information graph.  plot little bit informative last one, however still issues.","code":"# set up the graph object with igraph & tidygraph graph <- cur_TOM %>%    igraph::graph_from_adjacency_matrix(mode='undirected', weighted=TRUE) %>%    tidygraph::as_tbl_graph(directed=FALSE) %>%    tidygraph::activate(nodes)   # make the plot with ggraph p <- ggraph(graph) +    geom_edge_link(color='grey', alpha=0.2) +    geom_node_point(color='black') +   geom_node_label(aes(label=name), repel=TRUE, max.overlaps=Inf, fontface='italic')   p # set up the graph object with igraph & tidygraph graph <- cur_TOM %>%    igraph::graph_from_adjacency_matrix(mode='undirected', weighted=TRUE) %>%    tidygraph::as_tbl_graph(directed=FALSE) %>%    tidygraph::activate(nodes)   # add the module name to the graph: V(graph)$module <- modules[V(graph)$name,'module']  # make the plot with gggraph p <- ggraph(graph) +    geom_edge_link(aes(alpha=weight), color='grey') +    geom_node_point(aes(color=module)) +   geom_node_label(aes(label=name), repel=TRUE, max.overlaps=Inf, fontface='italic') +   scale_colour_manual(values=mod_cp)    p"},{"path":"https://smorabit.github.io/hdWGCNA/articles/network_visualizations.html","id":"manipulating-the-network","dir":"Articles","previous_headings":"Customized network plots","what":"Manipulating the network","title":"Network Visualization","text":"previous plot, many edges still hard interpret plot. also still many genes labeled plot crowded. solve problems, can make simple manipulations graph make plots much interpretable. Next make new plot reduce number edges keeping strongest connections. also color edges based genes module, label genes top 25 hub genes module.  can also make similar plot keep edges genes module instead just keeping strongest edges.  default settings, seems layout nodes graph making squished plot, partially modules fully disconnected one another.","code":"# only keep the upper triangular part of the TOM: cur_TOM[upper.tri(cur_TOM)] <- NA  # cast the network from wide to long format cur_network <- cur_TOM %>%    reshape2::melt() %>%    dplyr::rename(gene1 = Var1, gene2 = Var2, weight=value) %>%   subset(!is.na(weight))  # get the module & color info for gene1 temp1 <- dplyr::inner_join(   cur_network,   modules %>%      dplyr::select(c(gene_name, module, color)) %>%      dplyr::rename(gene1 = gene_name, module1=module, color1=color),   by = 'gene1' ) %>% dplyr::select(c(module1, color1))  # get the module & color info for gene2 temp2 <- dplyr::inner_join(   cur_network,   modules %>%      dplyr::select(c(gene_name, module, color)) %>%      dplyr::rename(gene2 = gene_name, module2=module, color2=color),   by = 'gene2' ) %>% dplyr::select(c(module2, color2))  # add the module & color info  cur_network <- cbind(cur_network, temp1, temp2)  # set the edge color to the module's color if they are the two genes are in the same module  cur_network$edge_color <- ifelse(   cur_network$module1 == cur_network$module2,    as.character(cur_network$module1),   'grey' )  # keep this network before subsetting cur_network_full <- cur_network   # keep the top 10% of edges  edge_percent <- 0.1 cur_network <- cur_network_full %>%    dplyr::slice_max(     order_by = weight,      n = round(nrow(cur_network)*edge_percent)   )  # make the graph object with tidygraph graph <- cur_network %>%    igraph::graph_from_data_frame() %>%   tidygraph::as_tbl_graph(directed=FALSE) %>%    tidygraph::activate(nodes)  # add the module name to the graph: V(graph)$module <- modules[V(graph)$name,'module']  # get the top 25 hub genes for each module hub_genes <- GetHubGenes(seurat_obj, n_hubs=25) %>% .$gene_name V(graph)$hub <- ifelse(V(graph)$name %in% hub_genes, V(graph)$name, \"\")  # make the plot with gggraph p <- ggraph(graph) +    geom_edge_link(aes(alpha=weight, color=edge_color)) +    geom_node_point(aes(color=module)) +   geom_node_label(aes(label=hub), repel=TRUE, max.overlaps=Inf, fontface='italic') +   scale_colour_manual(values=mod_cp) +   scale_edge_colour_manual(values=mod_cp)   p # subset to only keep edges between genes in the same module cur_network <- cur_network_full %>%    subset(module1 == module2)  # make the graph object with tidygraph graph <- cur_network %>%    igraph::graph_from_data_frame() %>%   tidygraph::as_tbl_graph(directed=FALSE) %>%    tidygraph::activate(nodes)  # add the module name to the graph: V(graph)$module <- modules[V(graph)$name,'module']  # get the top 25 hub genes for each module hub_genes <- GetHubGenes(seurat_obj, n_hubs=25) %>% .$gene_name V(graph)$hub <- ifelse(V(graph)$name %in% hub_genes, V(graph)$name, \"\")  # make the plot with gggraph p <- ggraph(graph) +    geom_edge_link(aes(alpha=weight, color=edge_color)) +    geom_node_point(aes(color=module)) +   geom_node_label(aes(label=hub), repel=TRUE, max.overlaps=Inf, fontface='italic') +   scale_colour_manual(values=mod_cp) +   scale_edge_colour_manual(values=mod_cp) +   NoLegend()  p"},{"path":"https://smorabit.github.io/hdWGCNA/articles/network_visualizations.html","id":"specifying-network-layouts","dir":"Articles","previous_headings":"Customized network plots","what":"Specifying network layouts","title":"Network Visualization","text":"hood, ggraph determines 2D layout points graph. Next try different layouts default. Please consult documentation page learn ggraph layouts.  show combined plot six different layouts exact network. can appreciate different results using different layout algorithms, encourage trying different layouts best suit particular needs. ggraph documentation page shows many options different graph layouts can use. can also provide “custom” layout, can set 2D coordinates nodes. show can use co-expression UMAP layout computed previously. also make additional modifications. Make size node scaled kME. Highlight hub genes giving black outline plotting top.  can easily modify plot add background layer showing genes co-expression network. also change shape selected genes better differentiate background.  plot, show hub genes diamonds, non-hub genes circles, genes pathway interest background. Since ggraph based ggplot2, can easily add customizations. final example, change gene label colors match assigned modules, change plot background black, add title upper right corner.  encourage users learn example, leverage powerful plotting libraries create custom network visualizations suit particular study.","code":"# randomly sample 50% of the edges within the same module cur_network1 <- cur_network_full %>%    subset(module1 == module2) %>%   group_by(module1) %>%   sample_frac(0.5) %>%    ungroup()  # keep the top 10% of other edges  edge_percent <- 0.10 cur_network2 <- cur_network_full %>%    subset(module1 != module2) %>%   dplyr::slice_max(     order_by = weight,      n = round(nrow(cur_network)*edge_percent)   )  cur_network <- rbind(cur_network1, cur_network2)  # set factor levels for edges: cur_network$edge_color <- factor(   as.character(cur_network$edge_color),   levels = c(mods, 'grey') )  # rearrange so grey edges are on the bottom: cur_network %<>% arrange(rev(edge_color))  # make the graph object with tidygraph graph <- cur_network %>%    igraph::graph_from_data_frame() %>%   tidygraph::as_tbl_graph(directed=FALSE) %>%    tidygraph::activate(nodes)  # add the module name to the graph: V(graph)$module <- modules[V(graph)$name,'module']  # get the top 25 hub genes for each module hub_genes <- GetHubGenes(seurat_obj, n_hubs=25) %>% .$gene_name V(graph)$hub <- ifelse(V(graph)$name %in% hub_genes, V(graph)$name, \"\")  # 1. default layout p1 <- ggraph(graph) +    geom_edge_link(aes(alpha=weight, color=edge_color)) +    geom_node_point(aes(color=module)) +   scale_colour_manual(values=mod_cp) +   scale_edge_colour_manual(values=mod_cp) +   ggtitle(\"layout = 'stress' (auto)\") +   NoLegend()  # 2. Kamada Kawai (kk) layout graph2 <- graph; E(graph)$weight <- E(graph)$weight + 0.0001 p2 <- ggraph(graph, layout='kk', maxiter=100) +    geom_edge_link(aes(alpha=weight, color=edge_color)) +    geom_node_point(aes(color=module)) +   scale_colour_manual(values=mod_cp) +   scale_edge_colour_manual(values=mod_cp) +   ggtitle(\"layout = 'kk'\") +   NoLegend()  # 3. igraph layout_with_fr p3 <- ggraph(graph, layout=layout_with_fr(graph)) +    geom_edge_link(aes(alpha=weight, color=edge_color)) +    geom_node_point(aes(color=module)) +   scale_colour_manual(values=mod_cp) +   scale_edge_colour_manual(values=mod_cp) +   ggtitle(\"layout_with_fr()\") +   NoLegend()  # 4. igraph layout_as_tree p4 <- ggraph(graph, layout=layout_as_tree(graph)) +    geom_edge_link(aes(alpha=weight, color=edge_color)) +    geom_node_point(aes(color=module)) +   scale_colour_manual(values=mod_cp) +   scale_edge_colour_manual(values=mod_cp) +   ggtitle(\"layout_as_tree()\") +   NoLegend()  # 5. igraph layout_nicely p5 <- ggraph(graph, layout=layout_nicely(graph)) +    geom_edge_link(aes(alpha=weight, color=edge_color)) +    geom_node_point(aes(color=module)) +   scale_colour_manual(values=mod_cp) +   scale_edge_colour_manual(values=mod_cp) +   ggtitle(\"layout_nicely()\") +   NoLegend()  # 6. igraph layout_in_circle p6 <- ggraph(graph, layout=layout_in_circle(graph)) +    geom_edge_link(aes(alpha=weight, color=edge_color)) +    geom_node_point(aes(color=module)) +   scale_colour_manual(values=mod_cp) +   scale_edge_colour_manual(values=mod_cp) +   ggtitle(\"layout_in_circle()\") +   NoLegend()   # make a combined plot (p1 | p2 | p3) / (p4 | p5 | p6) # get the UMAP df and subset by genes that are in our graph umap_df <- GetModuleUMAP(seurat_obj) umap_layout <- umap_df[names(V(graph)),] %>% dplyr::rename(c(x=UMAP1, y = UMAP2, name=gene)) rownames(umap_layout) <- 1:nrow(umap_layout)  # create the layout lay <- ggraph::create_layout(graph, umap_layout) lay$hub <- V(graph)$hub  p <- ggraph(lay) +    geom_edge_link(aes(alpha=weight, color=edge_color)) +   geom_node_point(data=subset(lay, hub == ''), aes(color=module, size=kME)) +    geom_node_point(data=subset(lay, hub != ''), aes(fill=module, size=kME), color='black', shape=21) +   scale_colour_manual(values=mod_cp) +   scale_fill_manual(values=mod_cp) +   scale_edge_colour_manual(values=mod_cp) +   geom_node_label(aes(label=hub), repel=TRUE, max.overlaps=Inf, fontface='italic') +   NoLegend()   p p <- ggraph(lay) +    ggrastr::rasterise(     geom_point(inherit.aes=FALSE, data=umap_df, aes(x=UMAP1, y=UMAP2), color=umap_df$color, alpha=0.1, size=1),     dpi=500    ) +   geom_edge_link(aes(alpha=weight, color=edge_color)) +   geom_node_point(data=subset(lay, hub == ''), aes(fill=module, size=kME), color='black', shape=21) +    geom_node_point(data=subset(lay, hub != ''), aes(fill=module, size=kME), color='black', shape=23) +   scale_colour_manual(values=mod_cp) +   scale_fill_manual(values=mod_cp) +   scale_edge_colour_manual(values=mod_cp) +   geom_node_label(aes(label=hub), repel=TRUE, max.overlaps=Inf, fontface='italic') +   NoLegend() p <- ggraph(lay) +    ggrastr::rasterise(     geom_point(inherit.aes=FALSE, data=umap_df, aes(x=UMAP1, y=UMAP2), color=umap_df$color, alpha=0.1, size=1),     dpi=500    ) +   geom_edge_link(aes(alpha=weight, color=edge_color)) +   geom_node_point(data=subset(lay, hub == ''), aes(fill=module, size=kME), color='black', shape=21) +    geom_node_point(data=subset(lay, hub != ''), aes(fill=module, size=kME), color='black', shape=23) +   scale_colour_manual(values=mod_cp) +   scale_fill_manual(values=mod_cp) +   scale_edge_colour_manual(values=mod_cp) +   geom_node_label(aes(label=hub, color=module), repel=TRUE, max.overlaps=Inf, fontface='italic') +   NoLegend()  p <- p +    theme(     panel.background = element_rect(fill='black'),     plot.title = element_text(hjust=0.5)   ) +    annotate(\"text\", x=Inf, y=Inf, label=\"Nervous system development\",    vjust=2, hjust=1.1, color='white', fontface='bold', size=5)  p"},{"path":"https://smorabit.github.io/hdWGCNA/articles/other_metacells.html","id":"constructing-metacells-with-seacells","dir":"Articles","previous_headings":"","what":"Constructing metacells with SEACells","title":"Alternative metacell algorithms","text":"section, follow recommended workflow constructing metacells SEACells. show code, may wish consult tutorial SEACells github page information. Note tried run tutorial larger dataset 60k cells 30k genes, SEACells didn’t complete running several hours. Thus, mileage may vary depending input dataset, issue essentially reason entire tutorial done using SEACells hematopoietic stem cell dataset. Next, need write data matrices disk can read R. several different approaches convert directly .h5ad Seurat formats, personally run lot unresolved bugs approaches (SeuratDisk) exporting data using scipy pandas reliable, least experience. just want run SEACells MC2, can skip next section.","code":"# following this tutorial: https://github.com/dpeerlab/SEACells/blob/main/notebooks/SEACell_computation.ipynb import numpy as np import pandas as pd import scanpy as sc import SEACells  import matplotlib import matplotlib.pyplot as plt import seaborn as sns  import scipy from scipy import io  # load the dataset downloaded above into Python adata = sc.read_h5ad('cd34_multiome_rna.h5ad')  # retain the unprocessed UMI counts matrix in the .raw slot raw_ad = sc.AnnData(adata.X) raw_ad.obs_names, raw_ad.var_names = adata.obs_names, adata.var_names adata.raw = raw_ad  # process data with SCANPY # note that we don't scale the data matrix before PCA. this is how # they do it in the SEACells tutorial so we do it that way here. sc.pp.normalize_per_cell(adata) sc.pp.log1p(adata) sc.pp.highly_variable_genes(adata, n_top_genes=1500) sc.tl.pca(adata, n_comps=50, use_highly_variable=True)  ################################################################################## # Running SEACells ##################################################################################  # they recommend one metacell for every 75 real cells n_SEACells = int(np.floor(adata.obs.shape[0] / 75))  build_kernel_on = 'X_pca' # key in ad.obsm to use for computing metacells                           # This would be replaced by 'X_svd' for ATAC data  ## Additional parameters n_waypoint_eigs = 10 # Number of eigenvalues to consider when initializing metacells waypoint_proportion = 0.9 # Proportion of metacells to initialize using waypoint analysis,                         # the remainder of cells are selected by greedy selection  # set up the model model = SEACells.core.SEACells(adata,                   build_kernel_on=build_kernel_on,                   n_SEACells=n_SEACells,                   n_waypoint_eigs=n_waypoint_eigs,                   waypt_proportion=waypoint_proportion,                   convergence_epsilon = 1e-5)  # Initialize archetypes model.initialize_archetypes()  # fit the model model.fit(n_iter=20)  # create aggregated metacell expression dataset SEACell_ad = SEACells.core.summarize_by_SEACell(adata, SEACells_label='SEACell', summarize_layer='raw') # write the h5ad files in case we want to load them into Python again adata.write_h5ad('data/tutorial_singlecell.h5ad') SEACell_ad.write_h5ad('data/tutorial_seacells.h5ad')   ################################################################################ # Save components of single-cell dataset ################################################################################  # write obs table data_dir = 'data/' adata.obs['UMAP_1'] = adata.obsm['X_umap'][:,0] adata.obs['UMAP_2'] = adata.obsm['X_umap'][:,1] adata.obs.to_csv('{}/tutorial_singlecell_obs.csv'.format(data_dir))  # write var table: adata.var.to_csv('{}/tutorial_singlecell_var.csv'.format(data_dir))  # save the sparse matrix for Seurat: X = adata.raw.X X = scipy.sparse.csr_matrix.transpose(X) io.mmwrite('{}/tutorial_singlecell.mtx'.format(data_dir), X)  # write the PCA pd.DataFrame(adata.obsm['X_pca']).to_csv('{}/tutorial_singlecell_pca.csv'.format(data_dir))   ################################################################################ # Save components of SEACells dataset ################################################################################  # write obs table SEACell_ad.obs.to_csv('{}/tutorial_seacells_obs.csv'.format(data_dir))  # save the sparse matrix for Seurat: X = SEACell_ad.X X = scipy.sparse.csr_matrix.transpose(X) io.mmwrite('{}/tutorial_seacells.mtx'.format(data_dir), X)"},{"path":"https://smorabit.github.io/hdWGCNA/articles/other_metacells.html","id":"constructing-metacells-with-mc2","dir":"Articles","previous_headings":"","what":"Constructing metacells with MC2","title":"Alternative metacell algorithms","text":"section, follow recommended workflow constructing metacells MC2, using dataset used SEACells. Now can save results can load R later.","code":"# following this tutorial: https://metacells.readthedocs.io/en/latest/Metacells_Vignette.html   import numpy as np import pandas as pd import scanpy as sc import SEACells  import matplotlib import matplotlib.pyplot as plt import seaborn as sns  import scipy from scipy import io import os  import anndata as ad import metacells as mc import scipy.sparse as sp import seaborn as sb from math import hypot    adata = sc.read_h5ad('data/cd34_multiome_rna.h5ad')  # need to run these utilities functions to fix the counts matrix X = adata.X mc.utilities.typing.sum_duplicates(X) mc.utilities.typing.sort_indices(X) adata.X = X  # set the raw counts matrix raw_ad = sc.AnnData(adata.X) raw_ad.obs_names, raw_ad.var_names = adata.obs_names, adata.var_names adata.raw = raw_ad  # name of the dataset mc.ut.set_name(adata, 'cd34')   ################################################################################ # Cleaning genes ################################################################################  excluded_gene_names = ['IGHMBP2', 'IGLL1', 'IGLL5', 'IGLON5', 'NEAT1', 'TMSB10', 'TMSB4X'] excluded_gene_patterns = ['MT-.*']  mc.pl.analyze_clean_genes(adata,                           excluded_gene_names=excluded_gene_names,                           excluded_gene_patterns=excluded_gene_patterns,                           random_seed=123456)  # combine into a clean gene mask mc.pl.pick_clean_genes(adata)  ################################################################################ # Clean cells ################################################################################  full = adata   properly_sampled_min_cell_total = 800 properly_sampled_max_cell_total = 15000  total_umis_of_cells = mc.ut.get_o_numpy(full, name='__x__', sum=True)  too_small_cells_count = sum(total_umis_of_cells < properly_sampled_min_cell_total) too_large_cells_count = sum(total_umis_of_cells > properly_sampled_max_cell_total)  too_small_cells_percent = 100.0 * too_small_cells_count / len(total_umis_of_cells) too_large_cells_percent = 100.0 * too_large_cells_count / len(total_umis_of_cells)  print(f\"Will exclude %s (%.2f%%) cells with less than %s UMIs\"       % (too_small_cells_count,          too_small_cells_percent,          properly_sampled_min_cell_total)) print(f\"Will exclude %s (%.2f%%) cells with more than %s UMIs\"       % (too_large_cells_count,          too_large_cells_percent,          properly_sampled_max_cell_total))   properly_sampled_max_excluded_genes_fraction = 0.1  excluded_genes_data = mc.tl.filter_data(full, var_masks=['~clean_gene'])[0] excluded_umis_of_cells = mc.ut.get_o_numpy(excluded_genes_data, name='__x__', sum=True) excluded_fraction_of_umis_of_cells = excluded_umis_of_cells / total_umis_of_cells  too_excluded_cells_count = sum(excluded_fraction_of_umis_of_cells > properly_sampled_max_excluded_genes_fraction)  too_excluded_cells_percent = 100.0 * too_excluded_cells_count / len(total_umis_of_cells)  print(f\"Will exclude %s (%.2f%%) cells with more than %.2f%% excluded gene UMIs\"       % (too_excluded_cells_count,          too_excluded_cells_percent,          100.0 * properly_sampled_max_excluded_genes_fraction))   mc.pl.analyze_clean_cells(     full,     properly_sampled_min_cell_total=properly_sampled_min_cell_total,     properly_sampled_max_cell_total=properly_sampled_max_cell_total,     properly_sampled_max_excluded_genes_fraction=properly_sampled_max_excluded_genes_fraction)   mc.pl.pick_clean_cells(full)  clean = mc.pl.extract_clean_data(full)   ################################################################################ # Forbidden genes ################################################################################  suspect_gene_names = ['PCNA', 'MKI67', 'TOP2A', 'HIST1H1D',                       'FOS', 'JUN', 'HSP90AB1', 'HSPA1A',                       'ISG15', 'WARS' ] suspect_gene_patterns = [ 'MCM[0-9]', 'SMC[0-9]', 'IFI.*' ] suspect_genes_mask = mc.tl.find_named_genes(clean, names=suspect_gene_names,                                             patterns=suspect_gene_patterns) suspect_gene_names = sorted(clean.var_names[suspect_genes_mask])   mc.pl.relate_genes(clean, random_seed=123456)  # which groups of genes contain sus genes module_of_genes = clean.var['related_genes_module'] suspect_gene_modules = np.unique(module_of_genes[suspect_genes_mask]) suspect_gene_modules = suspect_gene_modules[suspect_gene_modules >= 0] print(suspect_gene_modules)   similarity_of_genes = mc.ut.get_vv_frame(clean, 'related_genes_similarity') for gene_module in suspect_gene_modules:     module_genes_mask = module_of_genes == gene_module     similarity_of_module = similarity_of_genes.loc[module_genes_mask, module_genes_mask]     similarity_of_module.index = \\     similarity_of_module.columns = [         '(*) ' + name if name in suspect_gene_names else name         for name in similarity_of_module.index     ]     ax = plt.axes()     sb.heatmap(similarity_of_module, vmin=0, vmax=1, xticklabels=True, yticklabels=True, ax=ax, cmap=\"YlGnBu\")     ax.set_title(f'Gene Module {gene_module}')     plt.savefig('figures/module_heatmap_{}.pdf'.format(gene_module))     plt.clf()    # genes that are correlated with the known forbidden genes forbidden_genes_mask = suspect_genes_mask for gene_module in [17, 19, 24, 78, 113, 144, 149]:     module_genes_mask = module_of_genes == gene_module     forbidden_genes_mask |= module_genes_mask  forbidden_gene_names = sorted(clean.var_names[forbidden_genes_mask]) print(len(forbidden_gene_names)) print(' '.join(forbidden_gene_names))     ################################################################################ # computing metacells ################################################################################  max_parallel_piles = mc.pl.guess_max_parallel_piles(clean) print(max_parallel_piles) mc.pl.set_max_parallel_piles(max_parallel_piles)    with mc.ut.progress_bar():     mc.pl.divide_and_conquer_pipeline(clean,                                       forbidden_gene_names=forbidden_gene_names,                                       #target_metacell_size=...,                                       random_seed=123456)   metacells = mc.pl.collect_metacells(clean, name='cd34.metacells') # output dir data_dir = './'  # write the h5ad file metacells.write_h5ad('{}/tutorial_MC2.h5ad'.format(data_dir))   # write obs/var tables metacells.obs.to_csv('{}/tutorial_MC2_obs.csv'.format(data_dir)) metacells.var.to_csv('{}/tutorial_MC2_var.csv'.format(data_dir))  # save the sparse matrix for Seurat: X = metacells.X X = scipy.sparse.csr_matrix(np.transpose(X).astype(int)) io.mmwrite('{}/tutorial_MC2.mtx'.format(data_dir), X)"},{"path":"https://smorabit.github.io/hdWGCNA/articles/other_metacells.html","id":"load-the-seacells-and-mc2-metacell-datasets-into-r","dir":"Articles","previous_headings":"","what":"Load the SEACells and MC2 metacell datasets into R","title":"Alternative metacell algorithms","text":"load results running SEACells MC2 R, format data Seurat objects. Plot UMAP cluster assignments CD34+ HSC dataset:","code":"# single-cell analysis package library(Seurat)  # plotting and data science packages library(tidyverse) library(cowplot) library(patchwork)  # co-expression network analysis packages: library(WGCNA) library(hdWGCNA)  # network analysis & visualization package: library(igraph)  # using the cowplot theme for ggplot theme_set(theme_cowplot())  # set random seed for reproducibility set.seed(12345)  # location of the directory where the data was saved indir <- './'; data_dir <- './'  # load the UMI counts gene expression matrix X <- Matrix::readMM(paste0(indir,'tutorial_singlecell.mtx'))  # load harmony matrix X_pca <- read.table(paste0(indir, 'tutorial_singlecell_pca.csv'), sep=',', header=TRUE, row.names=1)  # load the cell & gene metadata table: cell_meta <- read.delim(paste0(indir, 'tutorial_singlecell_obs.csv'), sep=',', header=TRUE, row.names=1)  gene_meta <- read.table(paste0(indir, 'tutorial_singlecell_var.csv'), sep=',', header=TRUE, row.names=1)  # get the umap from cell_meta: umap <- cell_meta[,c('UMAP_1', 'UMAP_2')]  # set the rownames and colnames for the expression matrix: # for Seurat, rows of X are genes, cols of X are cells colnames(X) <- rownames(cell_meta) rownames(X) <- rownames(gene_meta) rownames(X_pca) <- rownames(cell_meta) rownames(umap) <- rownames(cell_meta)  # create a Seruat object: seurat_obj <- Seurat::CreateSeuratObject(   counts = X,   meta.data = cell_meta,   assay = \"RNA\",   project = \"SEACells\",   min.features = 0,   min.cells = 0 )  # set PCA reduction seurat_obj@reductions$pca <- Seurat::CreateDimReducObject(   embeddings = as.matrix(X_pca),   key=\"PC\",   assay=\"RNA\" )  # set UMAP reduction seurat_obj@reductions$umap <- Seurat::CreateDimReducObject(   embeddings = as.matrix(umap),   key=\"UMAP\",   assay=\"RNA\" )  # normalize expression matrix seurat_obj <- NormalizeData(seurat_obj)  # save data: saveRDS(seurat_obj, file=paste0(data_dir, 'tutorial_seacells.rds'))  ############################################################## # SEACells metacells ##############################################################  X <- Matrix::readMM(paste0(indir,'tutorial_seacells.mtx'))  cell_meta <- read.delim(paste0(indir, 'tutorial_seacells_obs.csv'), sep=',', header=TRUE, row.names=1)  colnames(X) <- rownames(cell_meta) rownames(X) <- rownames(gene_meta)  # create a Seruat object: m_obj <- Seurat::CreateSeuratObject(   counts = X,   assay = \"RNA\",   project = \"SEACells\",   min.features = 0,   min.cells = 0 )  saveRDS(m_obj, file=paste0(data_dir, 'tutorial_seacells_metacell.rds'))  ############################################################## # MC2 metacells ##############################################################  # load and type cast to sparse matrix X <- Matrix::readMM(paste0(indir,'tutorial_MC2.mtx')) X <- as(X, 'dgCMatrix')  cell_meta <- read.delim(paste0(indir, 'tutorial_MC2_obs.csv'), sep=',', header=TRUE, row.names=1) gene_meta <- read.table(paste0(indir, 'tutorial_MC2_var.csv'), sep=',', header=TRUE, row.names=1)  colnames(X) <- rownames(cell_meta) rownames(X) <- rownames(gene_meta)  # create a Seruat object: m_obj <- Seurat::CreateSeuratObject(   counts = X,   assay = \"RNA\",   project = \"MC2\",   min.features = 0,   min.cells = 0 )  saveRDS(m_obj, file=paste0(data_dir, 'tutorial_MC2_metacell.rds')) p <- DimPlot(seurat_obj, group.by='celltype', label=TRUE) +   umap_theme() + coord_equal() + NoLegend() + theme(plot.title=element_blank())"},{"path":"https://smorabit.github.io/hdWGCNA/articles/other_metacells.html","id":"co-expression-network-analysis","dir":"Articles","previous_headings":"","what":"Co-expression network analysis","title":"Alternative metacell algorithms","text":"Now ready perform co-expression network analysis using metacell datasets. First need load CD34+ HSC dataset.","code":"# directory where the data was saved  data_dir <- './'  # load CD34+ HSC dataset seurat_obj <- readRDS(paste0(data_dir, \"tutorial_seacells.rds\"))"},{"path":"https://smorabit.github.io/hdWGCNA/articles/other_metacells.html","id":"seacells","dir":"Articles","previous_headings":"Co-expression network analysis","what":"SEACells","title":"Alternative metacell algorithms","text":"perform co-expression network analysis using SEACells metacells. can use function SetMetacellObject add SEACells metacell data hdWGCNA experiment.","code":"# load datasets m_obj <- readRDS(paste0(data_dir, 'tutorial_seacells_metacell.rds'))  # set up hdWGCNA experiment seurat_obj <- SetupForWGCNA(   seurat_obj,   gene_select = \"fraction\",   fraction = 0.05,   wgcna_name = 'SEACells' )  # add the seacells dataset seurat_obj <- SetMetacellObject(seurat_obj, m_obj) seurat_obj <- NormalizeMetacells(seurat_obj)  # setup expression matrix seurat_obj <- SetDatExpr(   seurat_obj,   group_name = 'all',   use_metacells=TRUE, )  # test soft power threshold seurat_obj <- TestSoftPowers(seurat_obj)  # compute the co-expression network seurat_obj <- ConstructNetwork(seurat_obj)  # compute module eigengenes and eigengene-based connectivity seurat_obj <- ModuleEigengenes(seurat_obj) seurat_obj <- ModuleConnectivity(seurat_obj)  # rename modules seurat_obj <- ResetModuleNames(   seurat_obj,   new_name = 'sc-M',   wgcna_name='SEACells' )  # plot module eigengenes plot_list <- ModuleFeaturePlot(seurat_obj, order=TRUE, raster=TRUE, alpha=1, restrict_range=FALSE)  # assemble plots wrap_plots(plot_list, ncol=6)"},{"path":"https://smorabit.github.io/hdWGCNA/articles/other_metacells.html","id":"mc2","dir":"Articles","previous_headings":"Co-expression network analysis","what":"MC2","title":"Alternative metacell algorithms","text":"perform co-expression network analysis using MC2 metacells. nearly , add extra step ensure genes selected WGCNA MC2 metacell object.","code":"m_obj <- readRDS(paste0(data_dir, 'tutorial_MC2_metacell.rds'))  # set up hdWGCNA experiment seurat_obj <- SetupForWGCNA(   seurat_obj,   gene_select = \"fraction\",   fraction = 0.05,   wgcna_name = 'MC2' )  # IMPORTANT: # in the MC2 code above, we had to exclude some of the genes, so here we have to # make sure the genes that we selected for WGCNA are actually in the metacell # dataset wgcna_genes <- GetWGCNAGenes(seurat_obj) wgcna_genes <- wgcna_genes[wgcna_genes %in% rownames(m_obj)] seurat_obj <- SetWGCNAGenes(seurat_obj, wgcna_genes)  # add the MC2 dataset seurat_obj <- SetMetacellObject(seurat_obj, m_obj) seurat_obj <- NormalizeMetacells(seurat_obj)  # setup expression matrix seurat_obj <- SetDatExpr(   seurat_obj,   group_name = 'all',   use_metacells=TRUE, )  # test soft power threshold seurat_obj <- TestSoftPowers(seurat_obj)  # compute the co-expression network seurat_obj <- ConstructNetwork(seurat_obj)  # compute module eigengenes and eigengene-based connectivity seurat_obj <- ModuleEigengenes(seurat_obj) seurat_obj <- ModuleConnectivity(seurat_obj)  # rename modules seurat_obj <- ResetModuleNames(   seurat_obj,   new_name = 'mc2-M',   wgcna_name='MC2' )  # plot module eigengenes plot_list <- ModuleFeaturePlot(seurat_obj, order=TRUE, raster=TRUE, alpha=1, restrict_range=FALSE)  # assemble plots wrap_plots(plot_list, ncol=6)"},{"path":"https://smorabit.github.io/hdWGCNA/articles/other_metacells.html","id":"hdwgcna","dir":"Articles","previous_headings":"Co-expression network analysis","what":"hdWGCNA","title":"Alternative metacell algorithms","text":"Lastly, run hdWGCNA metacell algorithm can compare results three different methods. Since MC2 SEACells don’t aggregate metacells separately cluster biological replicate, run hdWGCNA manner metacells constructed whole dataset. means metacells mix different cell types, also case SEACells MC2.","code":"# set up hdWGCNA experiment seurat_obj <- SetupForWGCNA(   seurat_obj,   gene_select = \"fraction\",   fraction = 0.05,   wgcna_name = 'hdWGCNA' )  # set up dummy variable so we can run MetacellsByGroups for all clusters together seurat_obj$all_cells <- 'all'  # run hdWGCNA metacell aggregation seurat_obj <- MetacellsByGroups(   seurat_obj = seurat_obj,   group.by = \"all_cells\",   k = 50,   target_metacells=250,   ident.group = 'all_cells',   min_cells=0,   max_shared=5, ) seurat_obj <- NormalizeMetacells(seurat_obj)  # setup expression matrix seurat_obj <- SetDatExpr(   seurat_obj,   group_name = 'all',   use_metacells=TRUE, )   # test soft power threshold seurat_obj <- TestSoftPowers(seurat_obj)  # compute the co-expression network seurat_obj <- ConstructNetwork(seurat_obj)  # compute module eigengenes and eigengene-based connectivity seurat_obj <- ModuleEigengenes(seurat_obj) seurat_obj <- ModuleConnectivity(seurat_obj)  # rename modules seurat_obj <- ResetModuleNames(   seurat_obj,   new_name = 'hd-M',   wgcna_name='hdWGCNA' )  # plot module eigengenes plot_list <- ModuleFeaturePlot(seurat_obj, order=TRUE, raster=TRUE, alpha=1, restrict_range=FALSE)  # assemble plots wrap_plots(plot_list, ncol=6)"},{"path":"https://smorabit.github.io/hdWGCNA/articles/other_metacells.html","id":"comparing-co-expression-modules-across-methods","dir":"Articles","previous_headings":"","what":"Comparing co-expression modules across methods","title":"Alternative metacell algorithms","text":"CD34+ HSC dataset, three metacell methods resulted set gene modules, module eigengene FeaturePlots look like cell-type/lineage specificity modules. section, compare results different analyses get idea shared distinct.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/articles/other_metacells.html","id":"compare-dendrograms-and-module-assignments","dir":"Articles","previous_headings":"Comparing co-expression modules across methods","what":"Compare dendrograms and module assignments","title":"Alternative metacell algorithms","text":"can plot hdWGCNA dendrogram gene module color assignments three methods high-level comparison different approaches.","code":"m1 <- GetModules(seurat_obj, wgcna_name='SEACells') m2 <- GetModules(seurat_obj, wgcna_name='hdWGCNA') m3 <- GetModules(seurat_obj, wgcna_name='MC2')  # get WGCNA network and module data net <- GetNetworkData(seurat_obj, wgcna_name=\"SEACells\")  m1_genes <- m1$gene_name m1_colors <- m1$color names(m1_colors) <- m1$gene_name  m2_colors <- m2[m1$gene_name, 'color'] m2_colors[m2_colors == NA] <- 'grey' names(m2_colors) <- m1$gene_name  m3_colors <- m3[m1$gene_name, 'color'] m3_colors[m3_colors == NA] <- 'grey' names(m3_colors) <- m1$gene_name  color_df <- data.frame(   SEACells = m1_colors,   hdWGCNA = m2_colors,   MC2 = m3_colors )  # plot dendrogram png(paste0(fig_dir, \"compare_dendro_sc.png\"),height=3, width=5, res=600, units='in') WGCNA::plotDendroAndColors(   net$dendrograms[[1]],   color_df,   groupLabels=colnames(color_df),   dendroLabels = FALSE, hang = 0.03, addGuide = TRUE, guideHang = 0.05,   main = \"SEACells dendro\", ) dev.off() m1 <- GetModules(seurat_obj, wgcna_name='SEACells') m2 <- GetModules(seurat_obj, wgcna_name='hdWGCNA') m3 <- GetModules(seurat_obj, wgcna_name='MC2')  # get WGCNA network and module data net <- GetNetworkData(seurat_obj, wgcna_name=\"MC2\")   m3_genes <- m3$gene_name m3_colors <- m3$color names(m3_colors) <- m3$gene_name  m2_colors <- m2[m3$gene_name, 'color'] m2_colors[m2_colors == NA] <- 'grey' names(m2_colors) <- m3$gene_name  m1_colors <- m1[m3$gene_name, 'color'] m1_colors[m1_colors == NA] <- 'grey' names(m1_colors) <- m3$gene_name   color_df <- data.frame(   MC2 = m3_colors,   hdWGCNA = m2_colors,   SEACells = m1_colors  )  # plot dendrogram png(paste0(fig_dir, \"compare_dendro_mc2.png\"),height=3, width=5, res=600, units='in') WGCNA::plotDendroAndColors(   net$dendrograms[[1]],   color_df,   groupLabels=colnames(color_df),   dendroLabels = FALSE, hang = 0.03, addGuide = TRUE, guideHang = 0.05,   main = \"MC2 dendro\", ) dev.off() m1 <- GetModules(seurat_obj, wgcna_name='SEACells') m2 <- GetModules(seurat_obj, wgcna_name='hdWGCNA') m3 <- GetModules(seurat_obj, wgcna_name='MC2')  # get WGCNA network and module data net <- GetNetworkData(seurat_obj, wgcna_name=\"hdWGCNA\")   m2_genes <- m2$gene_name  m2_colors <- m2$color names(m2_colors) <- m2$gene_name  m1_colors <- m1[m2$gene_name, 'color'] m1_colors[m2_colors == NA] <- 'grey' names(m1_colors) <- m1$gene_name  m3_colors <- m3[m2$gene_name, 'color'] m3_colors[m2_colors == NA] <- 'grey' names(m3_colors) <- m1$gene_name   color_df <- data.frame(   hdWGCNA = m2_colors,   MC2 = m3_colors,   SEACells = m1_colors )  # plot dendrogram png(paste0(fig_dir, \"compare_dendro_hdWGCNA.png\"),height=3, width=5, res=600, units='in') WGCNA::plotDendroAndColors(   net$dendrograms[[1]],   color_df,   groupLabels=colnames(color_df),   dendroLabels = FALSE, hang = 0.03, addGuide = TRUE, guideHang = 0.05,   main = \"hdWGCNA dendro\", ) dev.off()"},{"path":"https://smorabit.github.io/hdWGCNA/articles/projecting_modules.html","id":"projecting-modules-from-reference-to-query","dir":"Articles","previous_headings":"","what":"Projecting modules from reference to query","title":"Projecting modules to new datasets","text":"section project modules Zhou et al inhibitory neuron hdWGCNA experiment Morabito & Miyoshi et al control brain dataset. refer Zhou et al dataset “reference” dataset, Morabito & Miyoshi et al dataset “query” dataset. Just done building co-expression network scratch, basic single-cell pipeline done query dataset (normalization, scaling, variable features, PCA, batch correction, UMAP, clustering). First make UMAP plot visualize two datasets ensure processed.  Next run function ProjectModules project modules reference dataset query dataset. genes used co-expression network analysis reference dataset scaled query dataset, Seurat’s ScaleData function run within ProjectModules. perform following analysis steps project modules query dataset: Run ProjectModules compute module eigengenes query dataset based gene modules reference dataset. Optionally run ModuleExprScore compute hub gene expression scores projected modules. Run ModuleConnectivity compute intramodular connectivity (kME) query dataset. can see takes running one function project co-expression modules one dataset another using hdWGCNA. Optionally, can also compute hub gene expression scores intramodular connectivity projected modules. Note run ModuleConnectivity function query dataset, kME values module assignment table GetModules(seurat_query) kME values reference dataset. can extract projected module eigengenes using GetMEs function. projected modules can used downstream hdWGCNA analysis tasks visualization functions, module trait correlation, however important note functions run projected modules. particular, make network plots since actually construct co-expression network query dataset, running functions RunModuleUMAP ModuleNetworks throw error.","code":"p1 <- DimPlot(seurat_ref, group.by='cell_type', label=TRUE) +    umap_theme() +    ggtitle('Zhou') +    NoLegend()  p2 <- DimPlot(seurat_query, group.by='cell_type', label=TRUE) +    umap_theme() +    ggtitle('Morabito & Miyoshi') +    NoLegend()  p1 | p2 # Project modules from query to reference dataset seurat_query <- ProjectModules(   seurat_obj = seurat_query,   seurat_ref = seurat_ref,   # vars.to.regress = c(), # optionally regress covariates when running ScaleData   group.by.vars = \"Batch\", # column in seurat_query to run harmony on   wgcna_name_proj=\"projected\", # name of the new hdWGCNA experiment in the query dataset   wgcna_name = \"tutorial\" # name of the hdWGCNA experiment in the ref dataset ) seurat_query <- ModuleConnectivity(   seurat_query,   group.by = 'cell_type', group_name = 'INH' )  seurat_query <- ModuleExprScore(   seurat_query,   method='UCell' ) projected_hMEs <- GetModules(seurat_query)"},{"path":"https://smorabit.github.io/hdWGCNA/articles/projecting_modules.html","id":"visualization","dir":"Articles","previous_headings":"","what":"Visualization","title":"Projecting modules to new datasets","text":"section demonstrate visualization functions projected modules query dataset. First, use ModuleFeaturePlot function visualizes hMEs UMAP:  Next make dot plot modules grouped cell type identity.","code":"# make a featureplot of hMEs for each module plot_list <- ModuleFeaturePlot(   seurat_query,   features='hMEs',   order=TRUE,   restrict_range=FALSE )  # stitch together with patchwork wrap_plots(plot_list, ncol=6) # get the projected MEs projected_MEs <-  GetMEs(seurat_query)  # add MEs to Seurat meta-data: seurat_query@meta.data <- cbind(   seurat_query@meta.data,   projected_MEs )  # plot with Seurat's DotPlot function p <- DotPlot(     seurat_query,     features = colnames(projected_MEs),     group.by = 'cell_type' )  # flip the x/y axes, rotate the axis labels, and change color scheme: p <- p +   RotatedAxis() +   scale_color_gradient2(high='red', mid='grey95', low='blue') +   xlab('') + ylab('')  p"},{"path":"https://smorabit.github.io/hdWGCNA/articles/projecting_modules.html","id":"next-steps","dir":"Articles","previous_headings":"","what":"Next steps","title":"Projecting modules to new datasets","text":"encourage users explore projected modules using hdWGCNA’s various visualization analysis functions. next tutorial, cover statistical methods determine preservation reproducibility co-expression modules reference query datasets. Additionally, include another tutorial projet modules special cases two datasets come different species, different -omic modalities scATAC-seq. Module preservation tutorial Cross-species cross-modality tutorial","code":""},{"path":"https://smorabit.github.io/hdWGCNA/articles/projecting_modules_cross.html","id":"project-modules-from-rna-seq-to-atac-seq","dir":"Articles","previous_headings":"","what":"Project modules from RNA-seq to ATAC-seq","title":"Cross-species and cross-modality analysis","text":"section, project snRNA-seq co-expression modules onto snATAC-seq dataset Nature Genetics paper. analysis requires fully processed snRNA-seq dataset run hdWGCNA , fully processed snATAC-seq dataset. snATAC-seq processing data formatting, suggest using Signac, extension Seurat performing single-cell chromatin accessibility analysis. Signac offers several tutorials processing snATAC-seq data scratch, projecting co-expression modules snATAC-seq data need following analysis steps: Quality control filtering. Term frequency inverse document frequency (TF-IDF) normalization (RunTFIDF). Feature Selection (FindTopFeatures). Linear dimensionality reduction (RunSVD). Non-linear dimensionality reduction (RunUMAP) visualizations. Group cells clusters (FindNeighbors FindClusters). Create gene activity matrix (GeneActivity).","code":""},{"path":"https://smorabit.github.io/hdWGCNA/articles/projecting_modules_cross.html","id":"load-snatac-seq-dataset","dir":"Articles","previous_headings":"Project modules from RNA-seq to ATAC-seq","what":"Load snATAC-seq dataset","title":"Cross-species and cross-modality analysis","text":"following code loads Signac snATAC-seq dataset R. ensure loaded dataset, indeed chromatin dataset, plot snATAC-seq UMAP chromatin accessibility coverage plot GAD2, inhibitory neuron marker gene.","code":"# single-cell chromatin analysis package: library(Signac)  # load dataset seurat_atac <- readRDS('/dfs3b/swaruplab/smorabit/analysis/AD_NucSeq_2019/atac_analysis/all_data/celltype-analysis/data/NucSeq_processed_activity_qc_batch_correct.rds') # plot the snATAC-seq clusters: p1 <- DimPlot(seurat_atac, group.by='cell_type', label=TRUE, raster=FALSE) +    umap_theme() +    ggtitle('') +    NoLegend()   p2 <- CoveragePlot(   object = signac_atac,   group.by='cell_type',   region = \"GAD2\",   annotation = TRUE, peaks = FALSE, tile = FALSE, links = FALSE )   png(paste0(fig_dir, 'atac_umap_covplot.png'), width=12, height=4, res=400, units='in') p1 + p2 +   plot_layout(widths=c(1,3)) dev.off()"},{"path":"https://smorabit.github.io/hdWGCNA/articles/projecting_modules_cross.html","id":"project-modules","dir":"Articles","previous_headings":"Project modules from RNA-seq to ATAC-seq","what":"Project modules","title":"Cross-species and cross-modality analysis","text":"previous examples, reference query datasets transcriptomics datasets, trying investigate co-expression modules epigenome using chromatin accessibility data. use ProjectModules function done , ensure using Gene Activity matrix snATAC-seq dataset rather chromatin accessibility matrix. Using gene activity matrix computed module eigengenes snATAC-seq dataset, harmonizing based sequencing batch. Additionally, computed module hub gene expression scores projected modules, now ready visualization downstream analysis.","code":"# set assay to RNA (Gene Activity matrix) DefaultAssay(seurat_atac) <- 'RNA'  # project modules seurat_atac <- ProjectModules(   seurat_obj = seurat_atac,   seurat_ref = seurat_ref,   group.by.vars = 'Batch',   wgcna_name = \"INH\",   wgcna_name_proj=\"Zhou_projected\" )  # compute module hub scores for projected modules: seurat_atac <- ModuleExprScore(   seurat_atac,   n_genes = 25,   method='Seurat' )  # save the results: saveRDS(seurat_atac, file='mm2021_atac_hdWGCNA.rds')"},{"path":"https://smorabit.github.io/hdWGCNA/articles/projecting_modules_cross.html","id":"visualize-modules-in-snatac-seq","dir":"Articles","previous_headings":"Project modules from RNA-seq to ATAC-seq","what":"Visualize modules in snATAC-seq","title":"Cross-species and cross-modality analysis","text":"visualize hub gene expression scores projected modules snATAC-seq dataset using ModuleFeaturePlot Seurat’s DotPlot function.","code":"# only show a handful of selected modules selected_mods <- paste0('INH-M', c(4,5,7,8,9,10))  # make a featureplot of hub scores for each module plot_list <- ModuleFeaturePlot(   seurat_atac,   features='scores',   order=\"shuffle\",   module_names = selected_mods )  # stitch together with patchwork wrap_plots(plot_list, ncol=3) # get the projected hMEs mod_scores <-  GetModuleScores(seurat_atac) mod_scores <- mod_scores[,colnames(mod_scores) != 'grey']  # add hMEs to Seurat meta-data: seurat_atac@meta.data <- cbind(   seurat_atac@meta.data,   mod_scores )  # plot with Seurat's DotPlot function p <- DotPlot(     seurat_atac,     features = colnames(mod_scores),     group.by = 'cell_type' )  # flip the x/y axes, rotate the axis labels, and change color scheme: p <- p +   RotatedAxis() +   scale_color_gradient2(high='darkorchid4', mid='grey95', low='seagreen') +   xlab('') + ylab('')   p"},{"path":"https://smorabit.github.io/hdWGCNA/articles/projecting_modules_cross.html","id":"module-preservation-in-snatac-seq","dir":"Articles","previous_headings":"Project modules from RNA-seq to ATAC-seq","what":"Module preservation in snATAC-seq","title":"Cross-species and cross-modality analysis","text":"section, compute module preservation statistics snATAC-seq dataset. analysis tell us co-expression modules conserved epigenome level, specifically network properties, density connectiviy, preserved across modalities. code similar previous module preservation analysis, take specific steps snATAC-seq . Note code can take hours run large query dataset. Now visualize results using PlotModulePreservation function.","code":"# set dat expr for single-cell dataset: seurat_atac <- SetDatExpr(   seurat_atac,   group_name = \"INH\",   group.by = \"cell_type\",   use_metacells = FALSE )  # run module preservation function seurat_atac <- ModulePreservation(   seurat_atac,   seurat_ref = seurat_ref,   name=\"Zhou-INH\",   verbose=3 )  # save the results again since this step takes a while to run: saveRDS(seurat_atac, file='mm2021_atac_hdWGCNA.rds') # plot the summary stats plot_list <- PlotModulePreservation(   seurat_atac,   name=\"Zhou-INH\",   statistics = \"summary\" )  wrap_plots(plot_list, ncol=2) # plot all of the stats togehter plot_list <- PlotModulePreservation(   seurat_atac,   name=\"Zhou-INH\",   statistics = \"all\",   plot_labels=FALSE )  wrap_plots(plot_list, ncol=6)"},{"path":"https://smorabit.github.io/hdWGCNA/articles/projecting_modules_cross.html","id":"project-modules-from-hg38-to-mm10","dir":"Articles","previous_headings":"","what":"Project modules from hg38 to mm10","title":"Cross-species and cross-modality analysis","text":"","code":"# load Zhou et al 5xFAD dataset: seurat_mouse <- readRDS('/dfs3b/swaruplab/smorabit/analysis/AD_NucSeq_2019/batch_correction/liger/update/mouse_integration/data/zhou_5xFAD_ProcessedSeuratFinal.rds') seurat_mouse <- subset(seurat_mouse, Cell.Types != 'OTHER') seurat_mouse$cell_type <- seurat_mouse$Cell.Types seurat_mouse$cell_type <- ifelse(as.character(seurat_mouse$seurat_clusters) == 13, 'OPC', as.character(seurat_mouse$cell_type)) seurat_mouse$cell_type <- ifelse(as.character(seurat_mouse$seurat_clusters) %in% c(26,27), 'PER', as.character(seurat_mouse$cell_type))   p <- DimPlot(seurat_mouse, group.by = 'cell_type', label = TRUE) +   umap_theme() +   NoLegend() + ggtitle('Zhou et al 5xFAD')  png(paste0(fig_dir, 'mouse_umap.png'), units='in', res=400, width=5, height=5) p dev.off()"},{"path":"https://smorabit.github.io/hdWGCNA/articles/projecting_modules_cross.html","id":"project-modules-to-5xfad-data","dir":"Articles","previous_headings":"Project modules from hg38 to mm10","what":"Project modules to 5xFAD data","title":"Cross-species and cross-modality analysis","text":"","code":"# load mouse <-> human gene name table: hg38_mm10_genes <- read.table(   \"/dfs3b/swaruplab/smorabit/resources/hg38_mm10_orthologs_2021.txt\",   sep='\\t',   header=TRUE ) colnames(hg38_mm10_genes) <-c('hg38_id', 'mm10_id', 'mm10_name', 'hg38_name') hg38_mm10_genes <- dplyr::select(hg38_mm10_genes, c(hg38_name, mm10_name, hg38_id, mm10_id))   seurat_mouse <- ProjectModules(   seurat_mouse,   seurat_ref = seurat_ref,   gene_mapping=hg38_mm10_genes,   genome1_col=\"hg38_name\", # genome of reference data   genome2_col=\"mm10_name\", # genome of query data   wgcna_name_proj = \"Zhou-INH\" )  # compute module hub scores for projected modules: seurat_mouse <- ModuleExprScore(   seurat_mouse,   n_genes = 25,   method='Seurat' )"},{"path":"https://smorabit.github.io/hdWGCNA/articles/projecting_modules_cross.html","id":"visualize-modules-in-5xfad-snrna-seq","dir":"Articles","previous_headings":"Project modules from hg38 to mm10","what":"Visualize modules in 5xFAD snRNA-seq","title":"Cross-species and cross-modality analysis","text":"Visualize FeaturePlots  Visualize DotPlots","code":"# only show a handful of selected modules selected_mods <- paste0('INH-M', c(4,5,7,8,9,10))  # make a featureplot of hub scores for each module plot_list <- ModuleFeaturePlot(   seurat_mouse,   features='scores',   order=\"order\",   module_names = selected_mods )  # stitch together with patchwork png(paste0(fig_dir, 'mouse_featureplot.png'), width=12, height=6, units='in', res=400) wrap_plots(plot_list, ncol=3) dev.off() # get the projected hMEs mod_scores <-  GetModuleScores(seurat_mouse) mod_scores <- mod_scores[,colnames(mod_scores) != 'grey']  # add hMEs to Seurat meta-data: seurat_mouse@meta.data <- cbind(   seurat_mouse@meta.data,   mod_scores )  # plot with Seurat's DotPlot function p <- DotPlot(     seurat_mouse,     features = colnames(mod_scores),     group.by = 'cell_type' )  # flip the x/y axes, rotate the axis labels, and change color scheme: p <- p +   RotatedAxis() +   scale_color_gradient2(high='red', mid='grey95', low='blue') +   xlab('') + ylab('')  png(paste0(fig_dir, 'mouse_dotplot.png'), width=10, height=5, units='in', res=400) p dev.off()"},{"path":"https://smorabit.github.io/hdWGCNA/articles/projecting_modules_cross.html","id":"module-preservation","dir":"Articles","previous_headings":"Project modules from hg38 to mm10","what":"Module preservation","title":"Cross-species and cross-modality analysis","text":"Now visualize results using PlotModulePreservation function.","code":"# set dat expr for single-cell dataset: seurat_mouse <- SetDatExpr(   seurat_mouse,   group_name = \"INH\",   group.by = \"cell_type\",   use_metacells = FALSE )  # run module preservation function seurat_mouse <- ModulePreservation(   seurat_mouse,   seurat_ref = seurat_ref,   name=\"Zhou-INH\",   gene_mapping=hg38_mm10_genes,   genome1_col=\"hg38_name\", # genome of reference data   genome2_col=\"mm10_name\", # genome of query data   verbose=3 )  saveRDS(seurat_mouse, file='../data/5xFAD_zhou_hdWGCNA.rds') # plot the summary stats plot_list <- PlotModulePreservation(   seurat_mouse,   name=\"Zhou-INH\",   statistics = \"summary\" )  png(paste0(fig_dir, 'mouse_preservation_summary.png'), width=10, height=5, res=400, units='in') wrap_plots(plot_list, ncol=2) dev.off() # plot all of the stats togehter plot_list <- PlotModulePreservation(   seurat_mouse,   name=\"Zhou-INH\",   statistics = \"all\",   plot_labels=FALSE )  png(paste0(fig_dir, 'mouse_preservation_all.png'), width=20, height=20*(2/3), res=400, units='in') wrap_plots(plot_list, ncol=6) dev.off()"},{"path":[]},{"path":"https://smorabit.github.io/hdWGCNA/articles/projecting_modules_cross.html","id":"download-and-process-visium-brain-dataset","dir":"Articles","previous_headings":"Project modules to visium data","what":"Download and process Visium brain dataset","title":"Cross-species and cross-modality analysis","text":"","code":"# load 10X genomics visium dataset SeuratData::InstallData(\"stxBrain\") seurat_vis <- SeuratData::LoadData(\"stxBrain\", type = \"anterior1\")  # process the Visium dataset with Seurat: seurat_vis <- seurat_vis %>%   NormalizeData() %>%   FindVariableFeatures() %>%   ScaleData() %>%   RunPCA() %>%   RunUMAP(dims=1:30) %>%   FindNeighbors(dims=1:30) %>%   FindClusters(res=0.75)   p1 <- DimPlot(seurat_vis, reduction = \"umap\", label = TRUE) +   umap_theme() +   NoLegend()  p2 <- SpatialDimPlot(seurat_vis, label = TRUE, label.size = 3) +   NoLegend()  png(paste0(fig_dir, 'vis_umap.png'), units='in', res=400, width=10, height=5) p1 | p2 dev.off()"},{"path":"https://smorabit.github.io/hdWGCNA/articles/projecting_modules_cross.html","id":"project-modules-to-visium-dataset","dir":"Articles","previous_headings":"Project modules to visium data","what":"Project modules to visium dataset:","title":"Cross-species and cross-modality analysis","text":"Load mouse human gene table Project Modules Spatial Feature Plot:","code":"# load mouse <-> human gene name table: hg38_mm10_genes <- read.table(   \"/dfs3b/swaruplab/smorabit/resources/hg38_mm10_orthologs_2021.txt\",   sep='\\t',   header=TRUE ) colnames(hg38_mm10_genes) <-c('hg38_id', 'mm10_id', 'mm10_name', 'hg38_name') hg38_mm10_genes <- dplyr::select(hg38_mm10_genes, c(hg38_name, mm10_name, hg38_id, mm10_id)) seurat_vis <- ProjectModules(   seurat_vis,   seurat_ref = seurat_ref,   gene_mapping=hg38_mm10_genes,   genome1_col=\"hg38_name\", # genome of reference data   genome2_col=\"mm10_name\", # genome of query data   wgcna_name_proj = \"Zhou-INH\" )  # compute module hub scores for projected modules: seurat_vis <- ModuleExprScore(   seurat_vis,   n_genes = 25,   method='Seurat' ) # get all of the image coordinates for BayesSpace image_df <- do.call(rbind, lapply(names(seurat_vis@images), function(cur_image){seurat_vis@images[[cur_image]]@coordinates}))  # re-order the rows of image_df to match the seurat_obj image_df <- image_df[colnames(seurat_vis),] all.equal(rownames(image_df), colnames(seurat_vis))  # make a spatial \"reduction\" image_emb <- as.matrix(image_df[,c('col', 'row')]) colnames(image_emb) <- c(\"Spatial_1\", \"Spatial_2\") seurat_vis@reductions$spatial <- CreateDimReducObject(   image_emb,   key = 'Spatial' )    # only show a handful of selected modules selected_mods <- paste0('INH-M', c(4,5,7,8,9,10))  # make a featureplot of hub scores for each module plot_list <- ModuleFeaturePlot(   seurat_vis,   features='scores',   order=\"order\",   module_names = selected_mods,   reduction='spatial' )  # stitch together with patchwork png(paste0(fig_dir, 'visium_featureplot.png'), width=12, height=6, units='in', res=400) wrap_plots(plot_list, ncol=3) dev.off() # make a featureplot of hub scores for each module plot_list <- ModuleFeaturePlot(   seurat_vis,   features='scores',   order=\"order\",   module_names = selected_mods,   reduction='umap' )  # stitch together with patchwork png(paste0(fig_dir, 'visium_featureplot_umap.png'), width=12, height=6, units='in', res=400) wrap_plots(plot_list, ncol=3) dev.off()"},{"path":"https://smorabit.github.io/hdWGCNA/articles/projecting_modules_cross.html","id":"module-preservation-in-visium","dir":"Articles","previous_headings":"Project modules to visium data","what":"Module preservation in Visium:","title":"Cross-species and cross-modality analysis","text":"Now visualize results using PlotModulePreservation function.","code":"# set dat expr for single-cell dataset: seurat_vis <- SetDatExpr(   seurat_vis,   use_metacells = FALSE )  # run module preservation function seurat_vis <- ModulePreservation(   seurat_vis,   seurat_ref = seurat_ref,   name=\"Zhou-INH\",   verbose=3 )  seurat_vis <- ModulePreservation(   seurat_vis,   seurat_ref = seurat_ref,   name=\"Zhou-INH\",   gene_mapping=hg38_mm10_genes,   genome1_col=\"hg38_name\", # genome of reference data   genome2_col=\"mm10_name\", # genome of query data   verbose=3 )  saveRDS(seurat_vis, file='../data/10x_visium_hdWGCNA.rds') # plot the summary stats plot_list <- PlotModulePreservation(   seurat_vis,   name=\"Zhou-INH\",   statistics = \"summary\" )  png(paste0(fig_dir, 'visium_preservation_summary.png'), width=10, height=5, res=400, units='in') wrap_plots(plot_list, ncol=2) dev.off() # plot all of the stats togehter plot_list <- PlotModulePreservation(   seurat_vis,   name=\"Zhou-INH\",   statistics = \"all\",   plot_labels=FALSE )  png(paste0(fig_dir, 'visium_preservation_all.png'), width=20, height=20*(2/3), res=400, units='in') wrap_plots(plot_list, ncol=6) dev.off()"},{"path":"https://smorabit.github.io/hdWGCNA/articles/pseudobulk.html","id":"considerations-and-motivation-for-pseudobulk-hdwgcna","dir":"Articles","previous_headings":"","what":"Considerations and motivation for pseudobulk hdWGCNA","title":"hdWGCNA with pseudobulk data","text":"“Pseudobulk” refers aggregating gene expression profiles cells particular group (cluster, cell type, etc) single biological replicate. somewhat comparable sorting cell population interest (ie via FACS) performing bulk RNA-seq, thus name “pseudobulk”. However, worth noting pseudobulk aggregates single-cell data still somewhat different actual bulk RNA-seq data. pseudobulk procedure helps alleviate sparsity single-cell data similar way previous aggregation approaches. used pseduobulking approach recent spatial transcriptomic study Alzheimer’s Disease. Due cost performing single-cell spatial RNA-seq experiments, number biological replicates tends low many studies. thoroughly tested number replicates required pseudobulk hdWGCNA, original WGCNA FAQ page recommends least 20 samples. Without sufficient number samples, gene-gene correlations essentially noisy meaningful reproducible. example dataset, N=11 samples. Therefore, compute pseudobulk replicates sample across 6 major cell types, end 66 replicates. Based advice original WGCNA authors, enough replicates case perform pseudobulk hdWGCNA individual cell type. Therefore purpose tutorial construct network using pseudobulk data 6 cell types together.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/articles/pseudobulk.html","id":"load-the-dataset-and-required-libraries","dir":"Articles","previous_headings":"","what":"Load the dataset and required libraries","title":"hdWGCNA with pseudobulk data","text":"First need load required libraries R.","code":"# single-cell analysis package library(Seurat)  # plotting and data science packages library(tidyverse) library(cowplot) library(patchwork)  # co-expression network analysis packages: library(WGCNA) library(hdWGCNA)  # using the cowplot theme for ggplot theme_set(theme_cowplot())  # set random seed for reproducibility set.seed(12345)  # optionally enable multithreading enableWGCNAThreads(nThreads = 8)  # load the Zhou et al snRNA-seq dataset seurat_obj <- readRDS('Zhou_2020.rds')"},{"path":"https://smorabit.github.io/hdWGCNA/articles/pseudobulk.html","id":"create-the-pseudobulk-data-matrix","dir":"Articles","previous_headings":"","what":"Create the pseudobulk data matrix","title":"hdWGCNA with pseudobulk data","text":"make pseudobulk data matrix using hdWGCNA function ConstructPseudobulk. function adds UMI counts cells given group based group.biological replicate based replicate_col, metadata columns seurat_obj@meta.data. compute log CPM normalization matrix, normalization methods can used instead desired. Finally allow hdWGCNA use matrix downstream processing passing matrix directly SetDatExpr function. setting pseudobulk matrix, can continue use hdWGCNA functions normally . Since recommend least 20 replicates analysis, ConstructPseudobulk parameter called min_reps control minimum number allowed replicates. set min_reps=10 give us error message. Note ConstructPseudobulk gives us important warning number replicates. 11 samples dataset, case, total number “replicates” network analysis actually higher since performing network analysis 6 cell types together, therefore giving us 66 pseudobulk “replicates”. Since often want perform hdWGCNA one cell type time, can easily subset pseudobulk matrix just contain one cell type downstream analysis. Note example run tutorial.","code":"seurat_obj <- SetupForWGCNA(   seurat_obj,   gene_select = \"fraction\",    fraction = 0.05,    wgcna_name = \"pseudobulk\" ) length(GetWGCNAGenes(seurat_obj))  # Construt the pseudobulk expression profiles datExpr <- ConstructPseudobulk(   seurat_obj,   group.by = 'cell_type',   replicate_col = 'Sample',   assay = 'RNA',   slot = 'counts', # this should always be counts!   min_reps = 10 )  # compute log2CPM normalization # You can substitute this with another normalization of your choosing. cpm <- t(apply(datExpr, 1, function(x){     y <- (x) / sum(x) * 1000000     log2(y + 1) }))  seurat_obj <- SetDatExpr(   seurat_obj,   mat = cpm ) Warning message: In ConstructPseudobulk(seurat_obj, group.by = \"cell_type\", replicate_col = \"Sample\",  :   We strongly recommend at least 20 replicates for pseudobulk hdWGCNA, and there are only 11 replicates detected. Results may not be reproducible or informative with low numbers of replicates so proceed at your own risk. # we only want the data from the astrocytes  cur_group <- 'ASC'  # subset the matrix for just this cell type cur_cpm <- cpm[grepl(cur_group, rownames(cpm)),]  seurat_obj <- SetDatExpr(   seurat_obj,   mat = cur_cpm )"},{"path":"https://smorabit.github.io/hdWGCNA/articles/pseudobulk.html","id":"co-expression-network-analysis","dir":"Articles","previous_headings":"","what":"Co-expression network analysis","title":"hdWGCNA with pseudobulk data","text":"Now pseudobulk matrix, can perform co-expression network analysis.  can see analysis resulted 36 co-expression modules across six cell types. Next compute module eigengenes (MEs) eigengene-based connectivity (kMEs) single-cell level, can plot MEs module different cell types.  Next use UMAP project co-expression network two dimensions, visualize results using ggplot2.  can see, co-expression network derived pseudobulk data can used downstream analysis metacell/metaspot data.","code":"# select the soft power threshold seurat_obj <- TestSoftPowers(seurat_obj)  # construct the co-expression network and identify gene modules seurat_obj <- ConstructNetwork(     seurat_obj,      tom_name='pseudobulk',      overwrite_tom=TRUE,     mergeCutHeight=0.15 )  PlotDendrogram(seurat_obj, main='pseudobulk dendrogram') # compute the MEs and kMEs seurat_obj <- ModuleEigengenes(seurat_obj) seurat_obj <- ModuleConnectivity(seurat_obj)  # get MEs from seurat object MEs <- GetMEs(seurat_obj) mods <- colnames(MEs); mods <- mods[mods != 'grey']  # add MEs to Seurat meta-data for plotting: meta <- seurat_obj@meta.data seurat_obj@meta.data <- cbind(meta, MEs)  # plot with Seurat's DotPlot function p <- DotPlot(seurat_obj, features=mods, group.by = 'cell_type')  # reset the metadata seurat_obj@meta.data <- meta  # flip the x/y axes, rotate the axis labels, and change color scheme: p <- p +   RotatedAxis() +   scale_color_gradient(high='red', low='grey95') +    xlab('') + ylab('')   p # compute the co-expression network umap  seurat_obj <- RunModuleUMAP(   seurat_obj,   n_hubs = 5,   n_neighbors=10,   min_dist=0.4,   spread=3,   supervised=TRUE,   target_weight=0.3 )  # get the hub gene UMAP table from the seurat object umap_df <- GetModuleUMAP(seurat_obj)  # plot with ggplot p <- ggplot(umap_df, aes(x=UMAP1, y=UMAP2)) +   geom_point(    color=umap_df$color,    size=umap_df$kME*2   ) +    umap_theme()   # add the module names to the plot by taking the mean coordinates centroid_df <- umap_df %>%    dplyr::group_by(module) %>%   dplyr::summarise(UMAP1 = mean(UMAP1), UMAP2 = mean(UMAP2))   p <- p + geom_label(   data = centroid_df,    label=as.character(centroid_df$module),    fontface='bold', size=2) +    theme(panel.background = element_rect(fill='black'))  p"},{"path":"https://smorabit.github.io/hdWGCNA/articles/pseudobulk.html","id":"consensus-network-analysis-with-pseudobulk-data","dir":"Articles","previous_headings":"","what":"Consensus network analysis with pseudobulk data","title":"hdWGCNA with pseudobulk data","text":"can also run consensus network analysis using pseudobulk data. already familiar consensus co-expression network analysis, please visit tutorial page describing detail. use cell types , run consensus network analysis biological sex variable interest. run ConstructPseudobulk, provide function information cell groupings, biological samples, variable using consensus network analysis (sex case). rownames expression matrix denote different pseudobulk replicates. default named group.variable, replicate_col variable, label_col variable. consensus network analysis, need provide list gene expression matrices group interest (male female case), ConstructPseudobulk returns single matrix. next use SetMultiExpr properly format cpm matrix. Importantly, provide SetMultiExpr multi.group.parameter telling split apart matrix consensus network analysis, group chose label_col ConstructPseudobulk function. consensus network analysis, need perform soft power threshold testing group, next use TestSoftPowersConsensus.  now proceed network construction, ensure set consensus=TRUE.  Finally compute MEs kMEs, visualize expression level 54 modules 6 major cell types.  tutorial ends pseudobulk consensus modules can explored using tutorials.","code":"# set up a new wgcna experiment for the consensus analysis seurat_obj <- SetupForWGCNA(   seurat_obj,   gene_select = \"fraction\",   fraction = 0.05,   wgcna_name = \"pseudobulk_consensus\" )  # casting sex to a factor or else it will give an error!! seurat_obj$msex <- as.factor(seurat_obj$msex)  # make the pseudobulk matrix datExpr <- ConstructPseudobulk(   seurat_obj,   group.by = 'cell_type',   replicate_col = 'Sample',   label_col = 'msex',   min_reps = 10 )  # compute CPM normalized matrix: cpm <- t(apply(datExpr, 1, function(x){     y <- (x) / sum(x) * 1000000     log2(y + 1) }))  print(head(rownames(cpm))) [1] \"ASC:C1:0\" \"ASC:C3:0\" \"ASC:C5:0\" \"ASC:C6:0\" \"ASC:C7:0\" \"ASC:C8:0\" seurat_obj <- SetMultiExpr(   seurat_obj,   multi.group.by='msex',   mat = cpm # provide the normalized pseudobulk matrix ) seurat_obj <- TestSoftPowersConsensus(seurat_obj)  # generate plots plot_list <-  PlotSoftPowers(seurat_obj)  # get just the scale-free topology fit plot for each group consensus_groups <- unique(seurat_obj$msex) p_list <- lapply(1:length(consensus_groups), function(i){   cur_group <- consensus_groups[[i]]   plot_list[[i]][[1]] + ggtitle(paste0('Sex: ', cur_group)) + theme(plot.title=element_text(hjust=0.5)) })  wrap_plots(p_list, ncol=2) seurat_obj <- ConstructNetwork(   seurat_obj,   consensus=TRUE,   tom_name = \"pseudobulk_consensus\",   overwrite_tom=TRUE,   mergeCutHeight=0.1 )  # plot the dendrogram PlotDendrogram(seurat_obj, main='pseudobulk consensus dendrogram') # compute the MEs and kMEs seurat_obj <- ModuleEigengenes(seurat_obj) seurat_obj <- ModuleConnectivity(seurat_obj)  # get MEs from seurat object MEs <- GetMEs(seurat_obj) mods <- colnames(MEs); mods <- mods[mods != 'grey']  # add MEs to Seurat meta-data for plotting: meta <- seurat_obj@meta.data seurat_obj@meta.data <- cbind(meta, MEs)  # plot with Seurat's DotPlot function p <- DotPlot(seurat_obj, features=mods, group.by = 'cell_type')  # reset the metadata to remove the MEs seurat_obj@meta.data <- meta  # flip the x/y axes, rotate the axis labels, and change color scheme: p <- p +   RotatedAxis() +   scale_color_gradient(high='red', low='grey95') +    xlab('') + ylab('')  p"},{"path":"https://smorabit.github.io/hdWGCNA/articles/pseudotime.html","id":"download-the-tutorial-data","dir":"Articles","previous_headings":"","what":"Download the tutorial data","title":"Co-expression module dynamics with pseudotime","text":"First, download .rds file Google Drive link containing processed hematopoetic stem cell scRNA-seq Seurat object. Next, load dataset R necessary packages hdWGCNA Monocle3.","code":"# single-cell analysis package library(Seurat)  # plotting and data science packages library(tidyverse) library(cowplot) library(patchwork)  # co-expression network analysis packages: library(WGCNA) library(hdWGCNA)  # using the cowplot theme for ggplot theme_set(theme_cowplot())  # set random seed for reproducibility set.seed(12345)  # optionally enable multithreading enableWGCNAThreads(nThreads = 8)  # load the dataset  seurat_obj <- readRDS('hematopoetic_stem.rds')  # plot the UMAP colored by cluster p <- DimPlot(seurat_obj, group.by='celltype', label=TRUE) +   umap_theme() + coord_equal() + NoLegend() + theme(plot.title=element_blank())  p"},{"path":"https://smorabit.github.io/hdWGCNA/articles/pseudotime.html","id":"monocle3-pseudotime-analysis","dir":"Articles","previous_headings":"","what":"Monocle3 pseudotime analysis","title":"Co-expression module dynamics with pseudotime","text":"section, use Monocle3 perform pseudotime trajectory analysis dataset. Follow instructions install Monocle3.  Monocle3 learn_graph function builds principal graph dimensionally reduced space dataset. can see principal graph overlaid UMAP. principal graph serve basis pseudotime trajectories. Next, select starting node, principal node, graph origin pseudotime. select node Y_26 prinicipal node since overlaps stem cell population.","code":"library(monocle3) library(SeuratWrappers)  # convert the seurat object to CDS cds <- as.cell_data_set(seurat_obj)  # run the monocle clustering cds <- cluster_cells(cds, reduction_method='UMAP')  # learn graph for pseudotime cds <- learn_graph(cds)  # plot the pseudotime graph: p1 <- plot_cells(   cds = cds,   color_cells_by = \"celltype\",   show_trajectory_graph = TRUE,   label_principal_points = TRUE )   # plot the UMAP partitions from the clustering algorithm p2 <- plot_cells(   cds = cds,   color_cells_by = \"partition\",   show_trajectory_graph = FALSE )  p1 + p2 # get principal node & order cells principal_node <- 'Y_26' cds <- order_cells(cds,root_pr_nodes = principal_node)  # add pseudotime to seurat object: seurat_obj$pseudotime <- pseudotime(cds)  # separate pseudotime trajectories by the different mature cells seurat_obj$ery_pseudotime <- ifelse(seurat_obj$celltype %in% c(\"HSC\", \"MEP\", 'Ery'), seurat_obj$pseudotime, NA) seurat_obj$mono_pseudotime <- ifelse(seurat_obj$celltype %in% c(\"HSC\", \"HMP\", 'Mono'), seurat_obj$pseudotime, NA) seurat_obj$dc_pseudotime <- ifelse(seurat_obj$celltype %in% c(\"HSC\", \"HMP\", 'DCPre', 'cDC', 'pDC'), seurat_obj$pseudotime, NA) seurat_obj$clp_pseudotime <- ifelse(seurat_obj$celltype %in% c(\"HSC\", \"HMP\", 'CLP'), seurat_obj$pseudotime, NA) seurat_obj$UMAP1 <- seurat_obj@reductions$umap@cell.embeddings[,1] seurat_obj$UMAP2 <- seurat_obj@reductions$umap@cell.embeddings[,2]  p1 <- seurat_obj@meta.data %>%   ggplot(aes(x=UMAP1, y=UMAP2, color=ery_pseudotime)) +   ggrastr::rasterise(geom_point(size=1), dpi=500, scale=0.75) +   coord_equal() +   scale_color_gradientn(colors=plasma(256), na.value='grey') +   umap_theme()  p2 <- seurat_obj@meta.data %>%   ggplot(aes(x=UMAP1, y=UMAP2, color=mono_pseudotime)) +   ggrastr::rasterise(geom_point(size=1), dpi=500, scale=0.75) +   coord_equal() +   scale_color_gradientn(colors=viridis(256), na.value='grey') +   umap_theme()  p3 <- seurat_obj@meta.data %>%   ggplot(aes(x=UMAP1, y=UMAP2, color=dc_pseudotime)) +   ggrastr::rasterise(geom_point(size=1), dpi=500, scale=0.75) +   coord_equal() +   scale_color_gradientn(colors=inferno(256), na.value='grey') +   umap_theme()  p4 <- seurat_obj@meta.data %>%   ggplot(aes(x=UMAP1, y=UMAP2, color=clp_pseudotime)) +   ggrastr::rasterise(geom_point(size=1), dpi=500, scale=0.75) +   coord_equal() +   scale_color_gradientn(colors=mako(256), na.value='grey') +   umap_theme()  # assemble with patchwork (p1 | p2) / (p3 + p4) + plot_layout(ncol=1, guides='collect')"},{"path":"https://smorabit.github.io/hdWGCNA/articles/pseudotime.html","id":"co-expression-network-analysis","dir":"Articles","previous_headings":"","what":"Co-expression network analysis","title":"Co-expression module dynamics with pseudotime","text":"section, perform essential steps co-expression network analysis dataset. See tutorial detailed explaination steps.","code":"# set up the WGCNA experiment in the Seurat object seurat_obj <- SetupForWGCNA(   seurat_obj,   gene_select = \"fraction\",   fraction = 0.05,   wgcna_name = 'trajectory' )  # construct metacells  seurat_obj <- MetacellsByGroups(   seurat_obj = seurat_obj,   group.by = \"all_cells\",   k = 50,   target_metacells=250,   ident.group = 'all_cells',   min_cells=0,   max_shared=5, ) seurat_obj <- NormalizeMetacells(seurat_obj)  # setup expression matrix seurat_obj <- SetDatExpr(   seurat_obj,   group.by='all_cells',   group_name = 'all' )  # test soft power parameter seurat_obj <- TestSoftPowers(seurat_obj)  # construct the co-expression network seurat_obj <- ConstructNetwork(     seurat_obj,      tom_name='trajectory',      overwrite_tom=TRUE )  # compute module eigengenes & connectivity seurat_obj <- ModuleEigengenes(seurat_obj) seurat_obj <- ModuleConnectivity(seurat_obj)  # plot dendro PlotDendrogram(seurat_obj, main='hdWGCNA Dendrogram') ####################################################################### # DotPlot of MEs by clusters #######################################################################  MEs <- GetMEs(seurat_obj) modules <- GetModules(seurat_obj) mods <- levels(modules$module) mods <- mods[mods!='grey']  meta <- seurat_obj@meta.data seurat_obj@meta.data <- cbind(meta, MEs)   # make dotplot p <- DotPlot(   seurat_obj,   group.by='celltype',   features = rev(mods) ) + RotatedAxis() +   scale_color_gradient2(high='red', mid='grey95', low='blue') + xlab('') + ylab('') +   theme(     plot.title = element_text(hjust = 0.5),     axis.line.x = element_blank(),     axis.line.y = element_blank(),     panel.border = element_rect(colour = \"black\", fill=NA, size=1)   )  seurat_obj@meta.data <- meta  p"},{"path":"https://smorabit.github.io/hdWGCNA/articles/pseudotime.html","id":"module-dynamics","dir":"Articles","previous_headings":"","what":"Module dynamics","title":"Co-expression module dynamics with pseudotime","text":"section use hdWGCNA function PlotModuleTrajectory visualize module eigengenes change throughout pseudotime trajectories co-expression module. function requires specify name column Seurat object’s meta data pseudotime information stored. Since split pseudotime four different trajectories, first plot trajectory dynamics erythrocytes. Importantly, note module dynamics can studied using different pseudotime inference approaches, simply chose run Monocle3 example.  Based dynamics, can see co-expression modules turning expression programs throughout transition stem cells mature erythrocytes. can also compare module dynamics multiple trajectories simultaneously passing one pseudotime_col parameters PlotModuleTrajectory.","code":"seurat_obj$ery_pseudotime <- NA  p  <- PlotModuleTrajectory(     seurat_obj,     pseudotime_col = 'ery_pseudotime' )  p # loading this package for color schemes, purely optional library(MetBrewer)  p  <- PlotModuleTrajectory(     seurat_obj,     pseudotime_col = c('ery_pseudotime', 'dc_pseudotime', 'mono_pseudotime', 'clp_pseudotime'),     group_colors = paste0(met.brewer(\"Lakota\", n=4, type='discrete')) )  p"},{"path":"https://smorabit.github.io/hdWGCNA/articles/sctransform.html","id":"run-sctransform","dir":"Articles","previous_headings":"","what":"Run SCTransform","title":"Using SCTransform normalized data","text":"run SCTransform normalization tutorial dataset, regressing percent.mt. important note SCTransform pearson residuals typically output highly variable features. can check extracting expression matrix. see seurat_obj 36,601 genes, 3,000 SCTransform scale.data slot. Therefore, want use hdWGCNA SCTransform pearson residuals, must include highly variable genes. Alternatively, SCTransform output counts normalized data slot may also used.","code":"# load the tutorial dataset seurat_obj <- readRDS('data/Zhou_control.rds')  # subset just one cell type for the sake of speed seurat_subset <- seurat_obj %>% subset(cell_type == 'ASC')  # compute percentage mitochondrial genes seurat_subset <- PercentageFeatureSet(seurat_subset, pattern = \"^MT-\", col.name = \"percent.mt\")  # run SCTransform seurat_subset <- SCTransform(seurat_subset, vars.to.regress = \"percent.mt\", verbose = FALSE) # extract sct expression data sct_data <- GetAssayData(seurat_subset, slot='scale.data', assay='SCT')  # print the shape of this matrix (genes by cells) print(dim(sct_data)) [1] 3000 3162 # print the shape of the seurat object (genes by cells) print(dim(sct_data)) [1] 36601  3162"},{"path":"https://smorabit.github.io/hdWGCNA/articles/sctransform.html","id":"option-1-sctransform-on-single-cell-data","dir":"Articles","previous_headings":"","what":"Option 1: SCTransform on single-cell data","title":"Using SCTransform normalized data","text":"demonstrate run standard hdWGCNA workflow SCTransform normalized single-cell data. First set hdWGCNA experiment, ensuring include genes used SCTransform. Next, construct metacells specifying slot='scale.data' assay='SCT' order use SCTransform normalized data. Next, run rest main steps hdWGCNA pipeline.  Interestingly, none soft power thresholds tested scale-free topology moddel fit 0.8 higher. network construction, choose soft_power=14 since model fit starts plateau.","code":"# only supply features that were used for SCTransform!!! seurat_subset <- SetupForWGCNA(   seurat_subset,   features = VariableFeatures(seurat_subset),   wgcna_name = \"SCT\" ) seurat_subset <- MetacellsByGroups(   seurat_obj = seurat_subset,   group.by = c(\"Sample\"),   k = 25,   max_shared=12,   min_cells = 50,   reduction = 'harmony',   ident.group = 'Sample',   slot = 'scale.data',   assay = 'SCT' ) # set expression matrix for hdWGCNA seurat_subset <- SetDatExpr(seurat_subset)  # test different soft power thresholds seurat_subset <- TestSoftPowers(seurat_subset) plot_list <- PlotSoftPowers(seurat_subset)  print(wrap_plots(plot_list, ncol=2)) seurat_subset <- ConstructNetwork(   seurat_subset,   soft_power = 14,   tom_name = \"SCT_cells\",   overwrite_tom = TRUE )  # compute module eigengenes and connectivity seurat_subset <- ModuleEigengenes(seurat_subset) seurat_subset <- ModuleConnectivity(seurat_subset)  # plot the dendrogram PlotDendrogram(seurat_subset, main='hdWGCNA SCT Dendrogram')"},{"path":"https://smorabit.github.io/hdWGCNA/articles/sctransform.html","id":"option-2-sctransform-on-metacell-data","dir":"Articles","previous_headings":"","what":"Option 2: SCTransform on metacell data","title":"Using SCTransform normalized data","text":"Alternatively, can apply SCTransform constructed metacells. , extract metacell Seurat object, run SCTransform . Importantly, give us different set genes used previously. Next continue hdWGCNA pipeline using metacell object.","code":"seurat_subset <- SetupForWGCNA(   seurat_subset,   features = GetWGCNAGenes(seurat_subset, 'SCT'),   wgcna_name = \"SCT_meta\" )  seurat_subset <- MetacellsByGroups(   seurat_obj = seurat_subset,   group.by = c(\"Sample\"),   k = 25,   max_shared=12,   min_cells = 50,   reduction = 'harmony',   ident.group = 'Sample',   slot = 'counts',   assay = 'RNA' ) # get metacell object and run SCTransform mobj <- GetMetacellObject(seurat_subset) mobj <- PercentageFeatureSet(mobj, pattern = \"^MT-\", col.name = \"percent.mt\")  # run SCTransform mobj <- SCTransform(mobj, vars.to.regress = \"percent.mt\", verbose = FALSE, return.only.var.genes=FALSE)  # only keep genes that were used for SCTransform sct_data <- GetAssayData(mobj, slot='scale.data', assay='SCT') sct_genes <- rownames(sct_data) gene_list <- GetWGCNAGenes(seurat_subset) gene_list <- gene_list[gene_list %in% sct_genes]  # update the genes used for WGCNA, and reset the metacell object seurat_subset <- SetWGCNAGenes(seurat_subset, gene_list) seurat_subset <- SetMetacellObject(seurat_subset, mobj) # specify SCT assay and scale.data slot seurat_subset <- SetDatExpr(seurat_subset, assay = 'SCT', slot='scale.data') seurat_subset <- TestSoftPowers(seurat_subset)  plot_list <- PlotSoftPowers(seurat_subset)  # assemble with patchwork print(wrap_plots(plot_list, ncol=2)) # construct wgcna network: seurat_subset <- ConstructNetwork(   seurat_subset,   tom_name = \"SCT_meta\",   overwrite_tom = TRUE )  seurat_subset <- ModuleEigengenes(seurat_subset) seurat_subset <- ModuleConnectivity(seurat_subset)  PlotDendrogram(seurat_subset, main='hdWGCNA SCT-meta Dendrogram')"},{"path":"https://smorabit.github.io/hdWGCNA/articles/sctransform.html","id":"comparing-to-the-standard-hdwgcna-workflow","dir":"Articles","previous_headings":"","what":"Comparing to the standard hdWGCNA workflow","title":"Using SCTransform normalized data","text":", run standard hdWGCNA workflow without SCTransform can make comparisons later. Note using set genes using SCTransform.   Now can plot modules RNA modules SCT compare.","code":"# set default assay to RNA so we don't use SCTransform data DefaultAssay(seurat_subset) <- 'RNA'  # setup hdWGCNA experiment seurat_subset <- SetupForWGCNA(   seurat_subset,   features = GetWGCNAGenes(seurat_subset, 'SCT'),   wgcna_name = \"RNA\" )  # construct metacells seurat_subset <- MetacellsByGroups(   seurat_obj = seurat_subset,   group.by = c(\"Sample\"),   k = 25,   max_shared=12,   min_cells = 50,   reduction = 'harmony',   ident.group = 'Sample',   slot = 'counts',   assay = 'RNA' ) seurat_subset <- NormalizeMetacells(seurat_subset)  seurat_subset <- SetDatExpr(seurat_subset) seurat_subset <- TestSoftPowers(seurat_subset) plot_list <- PlotSoftPowers(seurat_subset)  # plot softpowers print(wrap_plots(plot_list, ncol=2)) # construct wgcna network: seurat_subset <- ConstructNetwork(   seurat_subset,   tom_name = \"RNA\",   overwrite_tom = TRUE )  seurat_subset <- ModuleEigengenes(seurat_subset) seurat_subset <- ModuleConnectivity(seurat_subset)  PlotDendrogram(seurat_subset, main='hdWGCNA RNA Dendrogram') # get both sets of modules m1 <- GetModules(seurat_subset, 'SCT') m2 <- GetModules(seurat_subset, 'RNA')  # get consensus dendrogram net <- GetNetworkData(seurat_subset, wgcna_name=\"SCT\") dendro <- net$dendrograms[[1]]  # get the gene and module color for consensus m2_genes <- m2$gene_name m2_colors <- m2$color names(m2_colors) <- m2_genes  # get the gene and module color for standard genes <- m1$gene_name colors <- m1$color names(colors) <- genes  # re-order the genes to match the consensus genes colors <- colors[m2_genes]  # set up dataframe for plotting color_df <- data.frame(   SCT = colors,   RNA = m2_colors )  # plot dendrogram using WGCNA function WGCNA::plotDendroAndColors(   net$dendrograms[[1]],   color_df,   groupLabels=colnames(color_df),   dendroLabels = FALSE, hang = 0.03, addGuide = TRUE, guideHang = 0.05,   main = \"SCT Dendrogram vs RNA modules\", ) # get both sets of modules m1 <- GetModules(seurat_subset, 'RNA') m2 <- GetModules(seurat_subset, 'SCT')  # get consensus dendrogram net <- GetNetworkData(seurat_subset, wgcna_name=\"RNA\") dendro <- net$dendrograms[[1]]  # get the gene and module color for consensus m2_genes <- m2$gene_name m2_colors <- m2$color names(m2_colors) <- m2_genes  # get the gene and module color for standard genes <- m1$gene_name colors <- m1$color names(colors) <- genes  # re-order the genes to match the consensus genes colors <- colors[m2_genes]  # set up dataframe for plotting color_df <- data.frame(   RNA = colors,   SCT = m2_colors )  # plot dendrogram using WGCNA function WGCNA::plotDendroAndColors(   net$dendrograms[[1]],   color_df,   groupLabels=colnames(color_df),   dendroLabels = FALSE, hang = 0.03, addGuide = TRUE, guideHang = 0.05,   main = \"RNA Dendrogram vs SCT modules\", )"},{"path":"https://smorabit.github.io/hdWGCNA/articles/tf_network.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Transcription factor regulatory network analysis","text":"tutorial demonstrate transcription factor (TF) regulatory network analysis hdWGCNA. additional type network analysis beyond standard co-expression network analysis hdWGCNA. hdWGCNA co-expression networks undirected networks, explicit information genes regulate , TF regulatory networks leverage TF binding motif information build directed networks TFs downstream target genes. analysis concepts used similar approaches, TF regulatory network analysis included hdWGCNA distinct approach key differences, example use metacells. , demonstrate analysis dataset human prefrontal cortex, keep mind analysis must modified appropriately different species. first described TF regulatory network method paper Childs & Morabito et al., Cell Reports (2024). use TF regulatory network analysis research, please cite paper original hdWGCNA paper Morabito et al., Cell Reports Methods (2023).","code":"# single-cell analysis package library(Seurat)  # plotting and data science packages library(tidyverse) library(cowplot) library(patchwork) library(magrittr)  # co-expression network analysis packages: library(WGCNA) library(hdWGCNA)  # network analysis & visualization package: library(igraph)  # using the cowplot theme for ggplot theme_set(theme_cowplot())  # set random seed for reproducibility set.seed(12345)  # re-load the Zhou et al snRNA-seq dataset seurat_obj <- readRDS('data/Zhou_control.rds')"},{"path":"https://smorabit.github.io/hdWGCNA/articles/tf_network.html","id":"install-additional-packages","dir":"Articles","previous_headings":"Introduction","what":"Install additional packages","title":"Transcription factor regulatory network analysis","text":"analysis, need install additional R packages work TF binding motifs. broadly fall two categories, tools working TF motifs genomic coordinates, database tools provide us information TF motifs genomic features. Two databases using specific human data (EnsDb.Hsapiens.v86, BSgenome.Hsapiens.UCSC.hg38), JASPAR database includes motif information multiple species. also need install xgboost, includes algorithm use model TF regulation gene.","code":"# install packages for dealing with TF motifs and genomic coordinates BiocManager::install(c(   'motifmatchr',   'TFBSTools',   'GenomicRanges' ))  # install database packages for human motifs & genomic features BiocManager::install(c(   'JASPAR2020',   'EnsDb.Hsapiens.v86',   'BSgenome.Hsapiens.UCSC.hg38' ))   # install xgboost  install('xgboost')  # load these packages into R: library(JASPAR2020) library(motifmatchr) library(TFBSTools) library(EnsDb.Hsapiens.v86) library(BSgenome.Hsapiens.UCSC.hg38) library(GenomicRanges) library(xgboost)"},{"path":[]},{"path":"https://smorabit.github.io/hdWGCNA/articles/tf_network.html","id":"identify-tfs-in-promoter-regions","dir":"Articles","previous_headings":"Transcription Factor Network Analysis","what":"Identify TFs in promoter regions","title":"Transcription factor regulatory network analysis","text":"first main step TF regulatory network analysis determine genes potentially regulated TF. provide function MotifScan uses algorithm motifmatchr search occurrences different TF motifs within gene promoter regions. function store information seurat_obj TF motifs present gene’s promoter.","code":"seurat_obj <- readRDS(file='data/zhou_tutorial.rds')  # use TFBSTools to get the motif position weight matrices  # for the JASPAR 2020 database pfm_core <- TFBSTools::getMatrixSet(   x = JASPAR2020,   opts = list(collection = \"CORE\", tax_group = 'vertebrates', all_versions = FALSE) )  # run the motif scan seurat_obj <- MotifScan(   seurat_obj,   species_genome = 'hg38',   pfm = pfm_core,   EnsDb = EnsDb.Hsapiens.v86 )"},{"path":"https://smorabit.github.io/hdWGCNA/articles/tf_network.html","id":"construct-tf-regulatory-network","dir":"Articles","previous_headings":"Transcription Factor Network Analysis","what":"Construct TF Regulatory Network","title":"Transcription factor regulatory network analysis","text":"Now information TFs potentially regulate gene based TF motif presence, basis constructing TF regulatory network. section, use function ConstructTFNetwork construct network TFs putative target genes. function leverages extreme gradient boosting (XGBoost) algorithm, powerful ensemble learning approach use predict expression given gene based expression TFs matching motif gene’s promoter. analysis reveal ranking TFs best predicting expression target gene, consider likely regulators particular gene. Please read methods section paper information. Similar standard hdWGCNA co-expression network analysis, need define set genes used analysis, need explicitly define expression matrix used function SetDatExpr. user may decide genes want use analysis, use genes assigned co-expression module based co-expression network analysis, genes corresponding TF. Now ready run ConstructTFNetwork. Since function models gene, runtime scale wth number genes selected previous step scale number metacells / metaspots used analysis. function results table showing information potential TF-gene pair, can access using GetTFNetwork. table shows inferred relationships network TFs target genes XGBoost model, regarding importance strength relationships. Gain represents improvement accuracy model branches used feature. Cover represents quantity observations affected feature trees used. Frequency represents often feature appears trees. Cover Frequency trees shallow depths. Cor simply represents pearson correlation coefficient. can use parameter model_params pass list arguments XGBoost. See webpage full list parameters.","code":"# get the motif df: motif_df <- GetMotifs(seurat_obj)  # keep all TFs, and then remove all genes from the grey module tf_genes <- unique(motif_df$gene_name) modules <- GetModules(seurat_obj) nongrey_genes <- subset(modules, module != 'grey') %>% .$gene_name genes_use <- c(tf_genes, nongrey_genes)  # update the gene list and re-run SetDatExpr seurat_obj <- SetWGCNAGenes(seurat_obj, genes_use) seurat_obj <- SetDatExpr(seurat_obj, group.by = 'cell_type', group_name='INH') seurat_obj <- ConstructTFNetwork(seurat_obj) results <- GetTFNetwork(seurat_obj) head(results) tf gene       Gain Cover Frequency         Cor 1  STAT3 IRF2 0.16588128 0.066     0.066 -0.08774167 2   CTCF IRF2 0.08142991 0.070     0.070  0.33443582 3   KLF5 IRF2 0.07912151 0.046     0.046 -0.29397638 4  PROX1 IRF2 0.07632654 0.032     0.032  0.22904364 5 ZNF140 IRF2 0.05930269 0.050     0.050 -0.16171536 6  ESRRA IRF2 0.04564704 0.056     0.056 -0.09254805 seurat_obj <- ConstructTFNetwork(     seurat_obj,     model_params=list(         objective = 'reg:squarederror',         max_depth = 1,         eta = 0.1,         nthread=16,         alpha=0.5     ) )"},{"path":"https://smorabit.github.io/hdWGCNA/articles/tf_network.html","id":"define-tf-regulons","dir":"Articles","previous_headings":"Transcription Factor Network Analysis","what":"Define TF Regulons","title":"Transcription factor regulatory network analysis","text":"step, use whole TF network previous step define “regulons” TF. Regulons similar co-expression modules, genes regulon comprised highly confident target genes TF. Essentially, step pruning TF regulatory network keep strongest TF-gene connections. offer several strategies defining TF regulons. Strategy “” selects top TFs gene. Strategy “B” selects top genes TF. Strategy “C” retains TF-gene pairs certain regulatory score (reg_thresh). analysis, employ Strategy “”, selecting top 10 TFs gene. resulting table TF regulons filtered version previous TF network table, containing pairs TFs target genes meet filtering criteria defined call AssignTFRegulons.","code":"seurat_obj <- AssignTFRegulons(     seurat_obj,     strategy = \"A\",     reg_thresh = 0.01,     n_tfs = 10 ) tf   gene       Gain      Cover  Frequency        Cor 1 ARGFX  PITX1 0.45472037 0.12828582 0.12828582 0.32824384 2 ARGFX   MYF6 0.31286043 0.25862570 0.25862570 0.17616153 3 ARGFX SNAP91 0.07103855 0.06703947 0.06703947 0.19616570 4 ARGFX   KLC4 0.06418233 0.02600000 0.02600000 0.21036974 5 ARGFX  PPWD1 0.05068363 0.04400000 0.04400000 0.06973992 6 ARGFX ZRANB3 0.04465245 0.05000000 0.05000000 0.21549817 seurat_obj <- AssignTFRegulons(     seurat_obj,     strategy = \"B\",     reg_thresh = 0.01,     n_genes = 50 ) seurat_obj <- AssignTFRegulons(     seurat_obj,     strategy = \"C\",     reg_thresh = 0.1 )"},{"path":"https://smorabit.github.io/hdWGCNA/articles/tf_network.html","id":"visualize-regulons","dir":"Articles","previous_headings":"Transcription Factor Network Analysis","what":"Visualize regulons","title":"Transcription factor regulatory network analysis","text":"can visualize top target genes within TF regulons using function RegulonBarPlot. bar plot, regulatory importance score XGBoost plotted x-axis, target genes ranked importance scores. shows us top predicted target genes TF, split whether target gene positively (right side) negatively (left side) correlated TF based gene expression.","code":"p1 <- RegulonBarPlot(seurat_obj, selected_tf='RUNX2') p2 <- RegulonBarPlot(seurat_obj, selected_tf='ETV1', cutoff=0.15)  p1 | p2"},{"path":"https://smorabit.github.io/hdWGCNA/articles/tf_network.html","id":"calculate-regulon-expression-signatures","dir":"Articles","previous_headings":"Transcription Factor Network Analysis","what":"Calculate regulon expression signatures","title":"Transcription factor regulatory network analysis","text":"hdWGCNA co-expression analysis, compute aggregated expression scores module, called Module Eigengenes. TF regulatory network analysis, also groups genes (regulons) can calculate gene expression scores. inform us cells express genes likely regulated specific TFs. use function RegulonScores compute scores TF regulon. Importantly, TF network analysis, TF-gene pairs positive co-expression, TF-gene pairs negative co-expression. regulon scoring, provide option target_type select ‘positive’, ‘negative’, ‘’, making possible separately analyze signatures genes activated repressed given TF. can use various approaches visualize regulon scores. compare regulon scores side--side expression RUNX2 using Seurat FeaturePlot. functions like VlnPlot DotPlot can used visualize regulon scores similar way, can create custom visualizations.","code":"# positive regulons seurat_obj <- RegulonScores(     seurat_obj,     target_type = 'positive',     ncores=8 )  # negative regulons seurat_obj <- RegulonScores(     seurat_obj,     target_type = 'negative',     cor_thresh = -0.05,     ncores=8 )  # access the results: pos_regulon_scores <- GetRegulonScores(seurat_obj, target_type='positive') neg_regulon_scores <- GetRegulonScores(seurat_obj, target_type='negative') # select a TF of interest cur_tf <- 'RUNX2'  # add the regulon scores to the Seurat metadata seurat_obj$pos_regulon_score <- pos_regulon_scores[,cur_tf] seurat_obj$neg_regulon_score <- pos_regulon_scores[,cur_tf]  # plot using FeaturePlot p1 <- FeaturePlot(seurat_obj, feature=cur_tf) + umap_theme() p2 <- FeaturePlot(seurat_obj, feature='pos_regulon_score', cols=c('lightgrey', 'red')) + umap_theme() p3 <- FeaturePlot(seurat_obj, feature='neg_regulon_score', cols=c('lightgrey', 'seagreen')) + umap_theme()  p1 | p2 | p3"},{"path":[]},{"path":"https://smorabit.github.io/hdWGCNA/articles/tf_network.html","id":"tfnetworkplot","dir":"Articles","previous_headings":"Network Visualization","what":"TFNetworkPlot","title":"Transcription factor regulatory network analysis","text":"Based specific research project biological question, many different ways one visualize TF network. section use TFNetworkPlot, built-funciton within hdWGCNA plot network centered around specified TFs. First, use TFNetworkPlot default settings using TF interest, RUNX2. select interesting TFs, look TFs specifically expressed cell type interest (INH), TFs hub genes co-expression modules. plot directed network showing regulatory links originating TF interest. nodes (dots) network represent TFs genes, edges (arrows) represent inferred regulatory relationships. selected TF shown diamond, TFs shown triangles, genes shown circles. size node corresponds outdegree network (number outgoing connections). color edges represent strength TF-gene interaction based pearson correlation gene expression. color node represents number links selected TFs, case showing us “primary” “secondary” targets RUNX2. default, genes labeled selected TFs primary TF targets. TFNetworkPlot function contains many options modify network plot, show options. First, show different plots based network “depth”. network complexity increases drastically use depth=3, general recommend using depth=1 plot primary targets depth=2 plot primary secondary targes (default). can also use TFNetworkPlot multiple selected TFs. show network plot three selected TFs. also use option target_type show different plots positive negative TF-gene relationships based sign correlations. two options change edge weights, either based TF-gene pearson correlations (edge_weight='Cor') based importance XGBoost model (edge_weight='Gain'). show options, also show Finally show options: plotting TFs, adding custom gene labels, changing color scheme.","code":"# select TF of interest cur_tf <- 'RUNX2'  # plot with default settings p <- TFNetworkPlot(seurat_obj, selected_tfs=cur_tf)  p # get the TF regulons tf_regulons <- GetTFRegulons(seurat_obj)  # get hub genes and subset by TFs hub_df <- GetHubGenes(seurat_obj, n_hubs=25) %>%     subset(gene_name %in% tf_regulons$tf)  # identify marker TFs Idents(seurat_obj) <- seurat_obj$cell_type marker_tfs <- FindAllMarkers(     seurat_obj,      features = unique(tf_regulons$tf) )  # get top 25 TFs top_tfs <- marker_tfs %>% subset(cluster == 'INH') %>% slice_max(n=25, order_by=avg_log2FC)  # intersect marker TFs and hub genes: intersect(top_tfs$gene, hub_df$gene_name) [1] \"PKNOX2\" \"RARB\"   \"RUNX2\" # plot the RUNX2 network with primary, secondary, and tertiary targets p1 <- TFNetworkPlot(seurat_obj, selected_tfs=cur_tf, depth=1, no_labels=TRUE) p2 <- TFNetworkPlot(seurat_obj, selected_tfs=cur_tf, depth=2, no_labels=TRUE) p3 <- TFNetworkPlot(seurat_obj, selected_tfs=cur_tf, depth=3, no_labels=TRUE)  p1 | p2 | p3 # select TF of interest cur_tfs <- c('RUNX2', 'RXRA', 'TCF4')  # plot with default settings p1 <- TFNetworkPlot(     seurat_obj, selected_tfs=cur_tfs,      target_type='positive',      label_TFs=0, depth=1 ) + ggtitle(\"positive targets\") p2 <- TFNetworkPlot(     seurat_obj, selected_tfs=cur_tfs,      target_type = 'both',      label_TFs=0, depth=1 ) + ggtitle(\"pos & neg targets\")  p3 <- TFNetworkPlot(     seurat_obj, selected_tfs=cur_tfs,      target_type = 'negative',      label_TFs=0, depth=1 ) + ggtitle(\"negative targets\")  p1 | p2 | p3 cur_tf <- 'RUNX2' p1 <- TFNetworkPlot(     seurat_obj, selected_tfs=cur_tf,      edge_weight = 'Cor', cutoff=0.05 ) + ggtitle(\"edge_weight='Cor'\")  p2 <- TFNetworkPlot(     seurat_obj, selected_tfs=cur_tf,      edge_weight = 'Gain', cutoff=0.05, ) + ggtitle(\"edge_weight='Gain'\")  p1 | p2 cur_tf <- 'RUNX2'  # get a list of hub genes in the same module as RUNX2 tf_regulons <- GetTFRegulons(seurat_obj) hub_df <- GetHubGenes(seurat_obj) cur_mod <- subset(hub_df, gene_name == cur_tf) %>% .$module %>% as.character cur_mod_genes <- subset(hub_df, module == cur_mod) %>% .$gene_name  # plot TFs only p1 <- TFNetworkPlot(     seurat_obj, selected_tfs=cur_tf,     TFs_only=TRUE,  ) + ggtitle('TFs only')  # plot with custom gene labels p2 <- TFNetworkPlot(     seurat_obj, selected_tfs=cur_tf,     label_TFs=0, label_genes=cur_mod_genes  ) + ggtitle('Custom gene labels')  # custom colors p3 <- TFNetworkPlot(     seurat_obj, selected_tfs=cur_tf,     label_TFs=0,      high_color='hotpink', mid_color='grey98', low_color='seagreen',     node_colors = c('grey30', 'grey60', 'grey90') ) + ggtitle('Custom colors')  p1 | p2 | p3"},{"path":"https://smorabit.github.io/hdWGCNA/articles/tf_network.html","id":"custom-network-visualizations","dir":"Articles","previous_headings":"Network Visualization","what":"Custom network visualizations","title":"Transcription factor regulatory network analysis","text":"Next demonstrate different ways visualize TF regulatory network beyond TFNetworkPlot using ggraph tidygraph, similar tutorial customized network plots. recommend custom network plots advanced users want create plot made TFNetworkPlot. example, want custom network layout, want show interactions within specific module set modules, want edit shape aesthetics, etc. example, plot RUNX2 TF regulatory network using co-expression UMAP graph layout, color genes co-expression module assignment. encourage users use example template creating fully custom network visualizations.","code":"# Need to do this if not already run seurat_obj <- RunModuleUMAP(   seurat_obj,   n_hubs = 5,   n_neighbors=15,    min_dist=0.1 )  #------------------------------------------------# # Part 1: get relevant data to plot #------------------------------------------------#  # select TF cur_tf <- 'RUNX2'  # get the modules table modules <- GetModules(seurat_obj) umap_df <- GetModuleUMAP(seurat_obj)  # get module color scheme mods <- levels(modules$module) mod_colors <- dplyr::select(modules, c(module, color)) %>%   distinct %>% arrange(module) %>% .$color cp <- mod_colors; names(cp) <- mods  # get top 10 hub genes per module: hub_df <- GetHubGenes(seurat_obj, n_hubs=10)  # get TF regulons tf_net <- GetTFNetwork(seurat_obj) tf_regulons <- GetTFRegulons(seurat_obj) %>%    subset(gene %in% umap_df$gene & tf %in% umap_df$gene) all(tf_regulons$gene %in% umap_df$gene)  # get the target genes cur_network <- GetTFTargetGenes(     seurat_obj,     selected_tfs=cur_tf,      depth=2,      target_type='both' ) %>% subset(gene %in% umap_df$gene & tf %in% umap_df$gene)  # get the max depth of each gene gene_depths <- cur_network %>%      group_by(gene) %>%      slice_min(n=1, order_by=depth) %>%      select(c(gene, depth)) %>% distinct()  #------------------------------------------------# # Part 2: Format data for ggraph / tidygraph #------------------------------------------------#  # rename columns cur_network <- cur_network %>%     dplyr::rename(c(source=tf, target=gene))   # only include connections between TFs: cur_network <- subset(cur_network, target %in% unique(tf_net$tf) | target %in% hub_df$gene_name)  # make a tidygraph object graph <- tidygraph::as_tbl_graph(cur_network) %>%      tidygraph::activate(nodes) %>%      mutate(degree = centrality_degree())    # compute the degree for each TF: tf_degrees <- table(tf_regulons$tf) tmp <- tf_degrees[names(V(graph))]; tmp <- tmp[!is.na(tmp)] V(graph)[names(tmp)]$degree <- as.numeric(tmp)  # specify the selected TFs vs TFs vs genes V(graph)$gene_type <- ifelse(names(V(graph)) %in% unique(tf_regulons$tf), 'TF', 'Gene') V(graph)$gene_type <- ifelse(names(V(graph)) == cur_tf, 'selected', V(graph)$gene_type)  # make the layout table using the umap coords: umap_layout <- umap_df[names(V(graph)),] %>% dplyr::rename(c(x=UMAP1, y = UMAP2, name=gene)) rownames(umap_layout) <- 1:nrow(umap_layout) lay <- create_layout(graph, umap_layout)  # add the depth info: gene_depths <- subset(gene_depths, gene %in% lay$name) tmp <- dplyr::left_join(lay, gene_depths, by = c('name' = 'gene')) lay$depth <- tmp$depth lay$depth <- ifelse(lay$name %in% cur_tf, 0, lay$depth) lay$depth <- factor(lay$depth, levels=0:max(as.numeric(lay$depth)))  # shape layout: cur_shapes <- c(23, 24, 25); names(cur_shapes) <- levels(lay$depth)  # set up plotting labels label_tfs <- subset(cur_network, target %in% tf_regulons$tf) %>% .$target %>% unique lay$lab <- ifelse(lay$name %in% c(cur_tf, label_tfs), lay$name, NA)  #------------------------------------------------# # Part 3: make the plot #------------------------------------------------#  p <- ggraph(lay)   # 1: the full module umap showing all genes p <- p + geom_point(inherit.aes=FALSE, data=umap_df, aes(x=UMAP1, y=UMAP2), color=umap_df$color, alpha=0.3, size=2)  # 2: Network edges p <- p + geom_edge_fan(     aes(color=Cor, alpha=abs(Cor)),     arrow = arrow(length = unit(2, 'mm'), type='closed'),      end_cap = circle(3, 'mm')   )   # 3: Network nodes (hub genes) p <- p + geom_node_point(   data=subset(lay, gene_type == 'Gene'), aes(fill=module), shape=21, color='black', size=2 )  # 4: Network nodes (TFs) p <- p + geom_node_point(   data=subset(lay, gene_type == 'TF'),   aes(fill=module, size=degree, shape=depth), color='black' )   # 5: add labels p <- p + geom_node_label(   aes(label=lab), repel=TRUE, max.overlaps=Inf,    fontface='italic', color='black' )   # 6: set colors, shapes, clean up legends p <- p +  scale_edge_colour_gradient2(high='orange2', mid='white', low='dodgerblue')  +    scale_colour_manual(values=cp) +    scale_fill_manual(values=cp) +    scale_shape_manual(values=cur_shapes) +    guides(         edge_alpha=\"none\",          size = \"none\",         shape = \"none\",         fill = \"none\"     )   p"},{"path":[]},{"path":"https://smorabit.github.io/hdWGCNA/articles/tf_network.html","id":"finddifferentialregulons","dir":"Articles","previous_headings":"Differential regulon analysis","what":"FindDifferentialRegulons","title":"Transcription factor regulatory network analysis","text":"Similar differential expression analysis differential module eigengene analysis, can perform differential regulon analysis compare TF regulon scores two groups using FindDifferentialRegulons function. function performs differential analysis based positive negative regulon scores, gene expression level corresponding TFs. run FindDifferentialRegulons compare female vs. male inhibitory neuron cell population. resulting table contains effect size significance level difference two groups positive regulon scores, negative regulon scores, gene expression TFs network. module assignment TF kME included convenience.","code":"# get the cell barcodes for the groups of interest  group1 <- seurat_obj@meta.data %>% subset(cell_type == 'INH' & msex == 0) %>% rownames group2 <- seurat_obj@meta.data %>% subset(cell_type == 'INH' & msex != 0) %>% rownames  # calculate differential regulons dregs <- FindDifferentialRegulons(   seurat_obj,   barcodes1 = group1,   barcodes2 = group2 )  # show the table head(dregs) tf p_val_positive avg_log2FC_positive p_val_adj_positive p_val_negative 1 TCF7L2   1.207455e-62          -0.3421176       8.572930e-61   7.105807e-21 2  NR2C1   1.835241e-61          -0.3747572       1.303021e-59   3.803810e-08 3    TBP   1.199167e-44          -0.3630856       8.514085e-43   5.298521e-19 4 ZNF682   5.916022e-32          -0.2712451       4.200375e-30   1.441206e-08 5 TFAP2E   7.645554e-27          -0.1822518       5.428343e-25   8.017671e-14 6 ZNF449   1.276234e-26          -0.2703349       9.061259e-25   2.865893e-09   avg_log2FC_negative p_val_adj_negative avg_log2FC_deg p_val_adj_deg  module 1          0.17744670       5.045123e-19     -0.2709456    1.00000000  INH-M3 2          0.08154737       2.700705e-06     -0.3078851    0.03085842  INH-M3 3          0.15949878       3.761950e-17     -0.5854185    0.13673349  INH-M2 4          0.11242609       1.023256e-06     -0.3163022    1.00000000 INH-M10 5          0.18148616       5.692546e-12     -0.2233587    1.00000000 INH-M14 6          0.12186969       2.034784e-07     -0.4360043    1.00000000  INH-M2         kME 1 0.1255949 2 0.2838355 3 0.2625859 4 0.2031141 5 0.1351454 6 0.1867791"},{"path":"https://smorabit.github.io/hdWGCNA/articles/tf_network.html","id":"visualize-and-interpret-the-results","dir":"Articles","previous_headings":"Differential regulon analysis","what":"Visualize and interpret the results","title":"Transcription factor regulatory network analysis","text":"TF regulon scores describe overall expression levels predicted target genes given TF, split target genes positively negatively correlated TF. Intuitively, specific TF expressed higher one group, positive target genes -regulated negative target genes -regulated. Therefore, expect inverse relationship effect sizes positive negative regulons TFs differentially regulating two groups. provide plotting function PlotDifferentialRegulons visualize differential regulon data, summarizing point. PlotDifferentialRegulons shows scatter plot comparing effect sizes differential regulon test positive (x-axis) negative (y-axis) regulons. point represents TF, colored module assignment. Diamonds represent TFs also significantly differentially expressed, circles differentially expressed. TFs reach significance opaque significant TFs black outline. linear regression line also shown (optional). number significantly differentially expressed regulons quadrant plot labeled corners. plot, want focus TFs bottom right top left corners. TFs bottom right corner, positively-correlated target genes -regulated group1 relative group2, negatively-correlated target genes -regulated comparison. opposite true TFs upper left corner. labeled TFs comprise differential TF regulons groups.","code":"# use the dregs which we obtained above p <- PlotDifferentialRegulons(seurat_obj, dregs)  # show the plot p"},{"path":"https://smorabit.github.io/hdWGCNA/articles/tf_network.html","id":"enrichment-analysis","dir":"Articles","previous_headings":"","what":"Enrichment analysis","title":"Transcription factor regulatory network analysis","text":"perform pathway enrichment analysis using EnrichR set target genes TF using function RunEnrichrRegulons. function can take run performing separate query enrichR server TF. can specify subset TFs query speed runtime. time, provide plotting function regulon enrichR results, demonstrate make simple bar plot using ggplot2.","code":"library(enrichR)  seurat_obj <- RunEnrichrRegulons(seurat_obj, wait_time=1) # get the enrichr results table  enrich_df <- GetEnrichrRegulonTable(seurat_obj)  # select a TF to plot  cur_tf <- 'RUNX2'   plot_df <- subset(enrich_df, tf == cur_tf & P.value < 0.05) table(plot_df$target_type)  # barplot for negatively-correlated target gene enrichment p1 <- plot_df %>%    subset(target_type == 'negative') %>%   slice_max(n=10, order_by=Combined.Score) %>%   mutate(Term = stringr::str_replace(Term, \" \\\\s*\\\\([^\\\\)]+\\\\)\", \"\")) %>% head(10) %>%   ggplot(aes(x=-log(Combined.Score), y=reorder(Term, Combined.Score)))+   geom_bar(stat='identity', position='identity', fill='lightgrey') +   geom_text(aes(label=Term), x=-.1, color='black', size=3.5, hjust='right') +   xlab('log(Enrichment)') +   scale_x_continuous(expand = c(0, 0), limits = c(NA, 0)) +   ggtitle('Negatively correlated target genes') +   theme(     panel.grid.major=element_blank(),     panel.grid.minor=element_blank(),     legend.title = element_blank(),     axis.ticks.y=element_blank(),     axis.text.y=element_blank(),     axis.line.y=element_blank(),     plot.title = element_text(hjust = 0.5),     axis.title.y = element_blank()   )   # barplot for positively-correlated target gene enrichment p2 <- plot_df %>%    subset(target_type == 'positive') %>%   slice_max(n=10, order_by=Combined.Score) %>%   mutate(Term = stringr::str_replace(Term, \" \\\\s*\\\\([^\\\\)]+\\\\)\", \"\")) %>% head(10) %>%   ggplot(aes(x=log(Combined.Score), y=reorder(Term, Combined.Score)))+   geom_bar(stat='identity', position='identity', fill='lightgrey') +   geom_text(aes(label=Term), x=.1, color='black', size=3.5, hjust='left') +   xlab('log(Enrichment)') +   scale_x_continuous(expand = c(0, 0), limits = c(0, NA)) +   ggtitle('Positively correlated target genes') +   theme(     panel.grid.major=element_blank(),     panel.grid.minor=element_blank(),     legend.title = element_blank(),     axis.ticks.y=element_blank(),     axis.text.y=element_blank(),     axis.line.y=element_blank(),     plot.title = element_text(hjust = 0.5),     axis.title.y = element_blank()   )  p1 | p2"},{"path":"https://smorabit.github.io/hdWGCNA/articles/tf_network.html","id":"module-regulatory-networks","dir":"Articles","previous_headings":"","what":"Module regulatory networks","title":"Transcription factor regulatory network analysis","text":"Transcription factors make genes within co-expression modules. Due complexity TF regulatory network, TF within one co-expression module likely regulates genes across co-expression modules. can summarize patterns across TFs infer describe co-expression modules may regulate via constituent TFs. section use two functions visualize regulatory dynamics: ModuleRegulatoryHeatmap ModuleRegulatoryNetworkPlot.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/articles/tf_network.html","id":"moduleregulatoryheatmap","dir":"Articles","previous_headings":"Module regulatory networks","what":"ModuleRegulatoryHeatmap","title":"Transcription factor regulatory network analysis","text":"demonstrate function ModuleRegulatoryHeatmap show summarized regulatory relationships co-expression modules based underlying relationships TFs predicted target genes modules. First, plot “positive” “negative” regulatory relationships separately. heatmaps summarize TF-mediated regulatory relationships pair co-expression modules. x-axis shows “source” module containing TFs, y-axis shows “target” module containing target genes. regulatory scores (heatmap color) calculated counting number TF-gene links going source target module, normalized total number TFs found source module. labels heatmap show actual number regulatory links pair modules. default, plot shows relationships TFs TFs, target genes excluded. can use option TFs_only=FALSE show plot genes. can also use function plot difference positive negative regulatory scores, helps us understand one module overall activating repressing another module. accomplish , use option feature='delta' (default behavior). can also avoid using dendrogram setting dendrogram=FALSE orange color indicates positive regulation stronger negative, blue color indicates negative regulation stronger. example, can see module INH-M8 contains TFs positively regulate modules INH-M5 INH-M18, TFs negatively regulate module INH-M13.","code":"p1 <- ModuleRegulatoryHeatmap(   seurat_obj, feature='positive',    high_color='orange2') p2 <- ModuleRegulatoryHeatmap(   seurat_obj, feature='negative',    high_color='dodgerblue')  p1 | p2 p1 <- ModuleRegulatoryHeatmap(   seurat_obj, feature='positive',    high_color='orange2') p2 <- ModuleRegulatoryHeatmap(   seurat_obj, feature='negative',    high_color='dodgerblue')  p1 | p2 p1 <- ModuleRegulatoryHeatmap(   seurat_obj, feature='delta', dendrogram=FALSE ) + ggtitle('TFs only') p2 <- ModuleRegulatoryHeatmap(   seurat_obj, feature='delta',TFs_only=FALSE,    max_val=5, dendrogram=FALSE ) + ggtitle('All target genes')  p1 | p2"},{"path":"https://smorabit.github.io/hdWGCNA/articles/tf_network.html","id":"moduleregulatorynetworkplot","dir":"Articles","previous_headings":"Module regulatory networks","what":"ModuleRegulatoryNetworkPlot","title":"Transcription factor regulatory network analysis","text":"can plot module regulatory information network plot rather heatmap using ModuleRegulatoryNetworkPlot. network shows information previous heatmap shown . can also make similar network plots split positive negative regulatory relationships. directed network plots show positive (right) negative (left) regulatory relationships modules. Nodes represent modules, directed edges represent regulatory relationship source module target module (heatmap color ModuleRegulatoryHeatmap). default, layout nodes based module UMAP (RunModuleUMAP), layouts can used well. Next set TFs_only=FALSE show regulatory relationships TFs target genes. Similar ModuleRegulatoryHeatmap, can also show edge weights difference positive negative regulatory scores. also show additional options. use cutoff=0.5 remove weak relationships, use umap_background=TRUE show individual genes co-expression UMAP, use label_modules=FALSE remove module labels. can also make network plots focus specific modules source targets.","code":"p <- ModuleRegulatoryNetworkPlot(     seurat_obj, cutoff=0.5, max_val=1.5)    p p1 <- ModuleRegulatoryNetworkPlot(   seurat_obj, feature='positive', high_color='orange2') p2 <- ModuleRegulatoryNetworkPlot(   seurat_obj, feature='negative', high_color='dodgerblue')  p1 | p2 p1 <- ModuleRegulatoryNetworkPlot(     seurat_obj, layout='circle', loops=FALSE ) + ggtitle(\"layout='circle'\")  p2 <- ModuleRegulatoryNetworkPlot(     seurat_obj, layout='stress', loops=FALSE ) + ggtitle(\"layout='stress'\")  p1 | p2 # set max_val=50 to stop the color scale at 50 p1 <- ModuleRegulatoryNetworkPlot(   seurat_obj, feature='positive', high_color='orange2',   TFs_only=FALSE, max_val=50)  p2 <- ModuleRegulatoryNetworkPlot(   seurat_obj, feature='negative', high_color='dodgerblue',   TFs_only=FALSE, max_val=50)  p1 | p2 p1 <- ModuleRegulatoryNetworkPlot(     seurat_obj, feature='delta',      cutoff=0.5, max_val=1.5)  # same plot with additional options p2 <- ModuleRegulatoryNetworkPlot(     seurat_obj, feature='delta',      cutoff=0.5, max_val=1.5,     umap_background=TRUE, label_modules=FALSE)   p1 | p2 # source p1 <- ModuleRegulatoryNetworkPlot(     seurat_obj, feature='positive',      umap_background=TRUE,     high_color='black',     cutoff=0.1,     loops=FALSE,     focus_source = 'INH-M1') + ggtitle('Focus on INH-M1 as the source')  # target p2 <- ModuleRegulatoryNetworkPlot(     seurat_obj, feature='positive',      umap_background=TRUE,     high_color='black',     loops=FALSE,     cutoff=0.1,     focus_target = 'INH-M1') + ggtitle('Focus on INH-M1 as the target')  p1 | p2"},{"path":"https://smorabit.github.io/hdWGCNA/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Sam Morabito. Author, maintainer. Zechuan Shi. Contributor. Swarup Lab. Funder.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Morabito et al. hdWGCNA identifies co-expression networks high-dimensional transcriptomics data. Cell Reports Methods (2023) [hdWGCNA] Transcription Factor Regulatory Network Analysis hdWGCNA Original implementation single-cell WGCNA (scWGCNA)","code":"@Article{,   title = {hdWGCNA identifies co-expression networks in high-dimensional transcriptomics data.},   author = {Samuel Morabito and Fairlie Reese and Negin Rahimzadeh and Emily Miyoshi and Vivek Swarup},   journal = {Cell Reports Methods},   year = {2023},   url = {https://www.cell.com/cell-reports-methods/fulltext/S2667-2375(23)00127-3}, } @Article{,   title = {Relapse to cocaine seeking is regulated by medial habenula NR4A2/NURR1 in mice},   author = {Jessica E. Childs and Samuel Morabito and Sudeshna Das and Caterina Santelli and Victoria Pham and Kelly Kusche and Vanessa Alizo Vera and Fairlie Reese and Rianne R. Campbell and Dina P. Matheos and Vivek Swarup and Marcelo A. Wood},   journal = {Cell Reports},   year = {2024},   url = {https://www.sciencedirect.com/science/article/pii/S2211124724002845}, } @Article{,   title = {Single-nucleus chromatin accessibility and transcriptomic characterization of Alzheimer’s disease},   author = {Samuel Morabito and Emily Miyoshi and Neethu Michael and Saba Shahin and Alessandra Cadete Martini and Elizabeth Head and Justine Silva and Kelsey Leavy and Mari Perez-Rosendahl and Vivek Swarup},   journal = {Nature Genetics},   year = {2021},   url = {https://doi.org/10.1038/s41588-021-00894-z}, }"},{"path":"https://smorabit.github.io/hdWGCNA/index.html","id":"high-dimensional-wgcna-","dir":"","previous_headings":"","what":"hdWGCNA","title":"hdWGCNA","text":"hdWGCNA R package performing weighted gene co-expression network analysis (WGCNA) high dimensional transcriptomics data single-cell RNA-seq spatial transcriptomics. hdWGCNA highly modular can construct context-specific co-expression networks across cellular spatial hierarchies. hdWGNCA identifies modules highly co-expressed genes provides context modules via statistical testing biological knowledge sources. hdWGCNA uses datasets formatted Seurat objects. Check hdWGCNA single-cell data tutorial hdWGCNA spatial transcriptomics data tutorial get started. New functionality hdWGCNA now able perform Transcription Factor Regulatory Network Analysis. functionality introduced publication Childs & Morabito et al., Cell Reports (2024). use hdWGCNA research, please cite following papers addition original WGCNA publication: Morabito et al., Cell Reports Methods (2023) Morabito & Miyoshi et al., Nature Genetics (2021)","code":""},{"path":"https://smorabit.github.io/hdWGCNA/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"hdWGCNA","text":"recommend creating R conda environment environment hdWGCNA. Next open R install required dependencies: Bioconductor, R-based software ecosystem bioinformatics biostatistics. devtools, package package development R. Seurat, general-purpose toolkit single-cell data science. Now can install hdWGCNA package using devtools.","code":"# create new conda environment for R conda create -n hdWGCNA -c conda-forge r-base r-essentials  # activate conda environment conda activate hdWGCNA # install BiocManager install.packages(\"BiocManager\")  # install Bioconductor core packages BiocManager::install()  # install devtools BiocManager::install(\"devtools\")  # install latest version of Seurat from CRAN install.packages(\"Seurat\")  # alternatively, install Seurat v4 install.packages(\"Seurat\", repos = c(\"https://satijalab.r-universe.dev', 'https://cloud.r-project.org\")) devtools::install_github('smorabit/hdWGCNA', ref='dev')"},{"path":"https://smorabit.github.io/hdWGCNA/index.html","id":"suggested-reading","dir":"","previous_headings":"","what":"Suggested Reading","title":"hdWGCNA","text":"Check paper describing hdWGCNA, paper introducing transcription factor regulatory network analysis hdWGCNA, original description applying WGCNA single-nucleus RNA-seq data. additional reading, suggest original WGCNA publication papers describing relevant algorithms co-expression network analysis. hdWGCNA identifies co-expression networks high-dimensional transcriptomics data Relapse cocaine seeking regulated medial habenula NR4A2/NURR1 mice Single-nucleus chromatin accessibility transcriptomic characterization Alzheimer’s disease WGCNA related algorithms: WGCNA: R package weighted correlation network analysis Defining clusters hierarchical cluster tree: Dynamic Tree Cut package R Eigengene networks studying relationships co-expression modules Geometric Interpretation Gene Coexpression Network Analysis Network Module Preserved Reproducible? Note package development: hdWGCNA active development, may run errors small typos. welcome users write GitHub issues report bugs, ask help, request potential enhancements.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/AssignTFRegulons.html","id":null,"dir":"Reference","previous_headings":"","what":"AssignTFRegulons — AssignTFRegulons","title":"AssignTFRegulons — AssignTFRegulons","text":"Define set likely target genes (Regulons) transcrition factor","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/AssignTFRegulons.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"AssignTFRegulons — AssignTFRegulons","text":"","code":"AssignTFRegulons(   seurat_obj,   strategy = \"A\",   reg_thresh = 0.01,   n_tfs = 10,   n_genes = 50,   wgcna_name = NULL )"},{"path":"https://smorabit.github.io/hdWGCNA/reference/AssignTFRegulons.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"AssignTFRegulons — AssignTFRegulons","text":"seurat_obj Seurat object strategy method defining regulons, \"\", \"B\", \"C\". See Details info. reg_thresh threshold regulatory score strategies , B, C n_tfs strategy , number top TFs keep gene n_genes strategy B, number top target genes keep TF wgcna_name name WGCNA experiment","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/AssignTFRegulons.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"AssignTFRegulons — AssignTFRegulons","text":"seurat_obj TF Regulon information added","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/AssignTFRegulons.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"AssignTFRegulons — AssignTFRegulons","text":"AssignTFRegulons uses TF network information ConstructTFNetwork define sets confident TF-gene pairs. \"regulon\" set target genes given TF, function provides three different strategies define TF regulons. Strategy \"\" selects top TFs gene, strategy \"B\" selects top genes TF, strategy \"C\" retains TF-gene pairs certain regulatory score (reg_thresh).","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/AvgModuleExpr.html","id":null,"dir":"Reference","previous_headings":"","what":"AverageModuleExpr — AvgModuleExpr","title":"AverageModuleExpr — AvgModuleExpr","text":"Computes module eigengenes WGCNA co-expression modules","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/AvgModuleExpr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"AverageModuleExpr — AvgModuleExpr","text":"","code":"AvgModuleExpr(seurat_obj, n_genes = 25, wgcna_name = NULL, ...)"},{"path":"https://smorabit.github.io/hdWGCNA/reference/AvgModuleExpr.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"AverageModuleExpr — AvgModuleExpr","text":"seurat_obj Seurat object","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/BinPseudotime.html","id":null,"dir":"Reference","previous_headings":"","what":"BinPseudotime — BinPseudotime","title":"BinPseudotime — BinPseudotime","text":"Makes evenly-spaced bins cells along pseudotime trajectory.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/BinPseudotime.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"BinPseudotime — BinPseudotime","text":"","code":"BinPseudotime(seurat_obj, n_bins = 50, pseudotime_col = \"pseudotime\")"},{"path":"https://smorabit.github.io/hdWGCNA/reference/BinPseudotime.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"BinPseudotime — BinPseudotime","text":"seurat_obj Seurat object n_bins number hub genes use UMAP computation pseudotime_col name column seurat_obj@meta.data containing pseudotime information","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/CheckSeurat5.html","id":null,"dir":"Reference","previous_headings":"","what":"CheckSeurat5 — CheckSeurat5","title":"CheckSeurat5 — CheckSeurat5","text":"Function check Seurat version v5","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/CheckSeurat5.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"CheckSeurat5 — CheckSeurat5","text":"","code":"CheckSeurat5()"},{"path":"https://smorabit.github.io/hdWGCNA/reference/CheckWGCNAName.html","id":null,"dir":"Reference","previous_headings":"","what":"CheckWGCNAName — CheckWGCNAName","title":"CheckWGCNAName — CheckWGCNAName","text":"CheckWGCNAName","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/CheckWGCNAName.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"CheckWGCNAName — CheckWGCNAName","text":"","code":"CheckWGCNAName(seurat_obj, wgcna_name)"},{"path":"https://smorabit.github.io/hdWGCNA/reference/CheckWGCNAName.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"CheckWGCNAName — CheckWGCNAName","text":"seurat_obj Seurat object","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/ComputeModuleEigengene.html","id":null,"dir":"Reference","previous_headings":"","what":"ComputeModuleEigengene — ComputeModuleEigengene","title":"ComputeModuleEigengene — ComputeModuleEigengene","text":"Internal helper function computes module eigengene single module.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/ComputeModuleEigengene.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"ComputeModuleEigengene — ComputeModuleEigengene","text":"","code":"ComputeModuleEigengene(   seurat_obj,   cur_mod,   modules,   group.by.vars = NULL,   verbose = TRUE,   vars.to.regress = NULL,   scale.model.use = \"linear\",   pc_dim = 1,   assay = NULL,   wgcna_name = NULL,   ... )"},{"path":"https://smorabit.github.io/hdWGCNA/reference/ComputeModuleEigengene.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"ComputeModuleEigengene — ComputeModuleEigengene","text":"seurat_obj Seurat object cur_mod name module found seurat_obj@misc[seurat_obj@misc$active_wgcna]$wgcna_net$colors modules table containing module / gene assignments, GetModules(seurat_obj). group..vars groups harmonize verbose logical indicating whether print messages vars..regress character vector variables seurat_obj@meta.data regress running ScaleData scale.model.use model scale data running ScaleData choices \"linear\", \"poisson\", \"negbinom\" pc_dim PC use module eigengene? Default 1. assay Assay seurat_obj compute module eigengenes. Default DefaultAssay(seurat_obj) wgcna_name name WGCNA experiment","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/ConstructMetacells.html","id":null,"dir":"Reference","previous_headings":"","what":"ConstructMetacells — ConstructMetacells","title":"ConstructMetacells — ConstructMetacells","text":"function takes Seurat object constructs averaged 'metacells' based neighboring cells.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/ConstructMetacells.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"ConstructMetacells — ConstructMetacells","text":"","code":"ConstructMetacells(   seurat_obj,   name = \"agg\",   ident.group = \"seurat_clusters\",   k = 25,   reduction = \"pca\",   dims = NULL,   assay = \"RNA\",   cells.use = NULL,   slot = \"counts\",   layer = \"counts\",   meta = NULL,   return_metacell = FALSE,   mode = \"average\",   max_shared = 15,   target_metacells = 1000,   max_iter = 5000,   verbose = FALSE,   wgcna_name = NULL )"},{"path":"https://smorabit.github.io/hdWGCNA/reference/ConstructMetacells.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"ConstructMetacells — ConstructMetacells","text":"seurat_obj Seurat object name string appended resulting metalcells. Default = 'agg' k Number nearest neighbors aggregate. Default = 50 reduction dimensionality reduction stored Seurat object. Default = 'umap' dims vector represnting dimensions reduction use. Either specify names dimensions indices. Default = NULL include dims. assay Assay extract data aggregation. Default = 'RNA' slot Slot extract data aggregation. Default = 'counts'. Slot used Seurat v4 instead layer. layer Layer extract data aggregation. Default = 'counts'. Layer used Seurat v5 instead slot. return_metacell Logical determine return metacell seurat object (TRUE), add misc original Seurat object (FALSE). Default FALSE. mode determines make gene expression profiles metacells constituent single cells. Options \"average\" \"sum\". max_shared maximum number cells shared across two metacells target_metacells maximum target number metacells construct max_iter maximum number iterations metacells bootstrapping loop verbose logical indicating whether print additional information wgcna_name name WGCNA experiment","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/ConstructMetaspots.html","id":null,"dir":"Reference","previous_headings":"","what":"ConstructMetaspots — ConstructMetaspots","title":"ConstructMetaspots — ConstructMetaspots","text":"Computes metaspots given Seurat object containing spatial transcriptomics data. function called MetaspotsByGroups run directly!","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/ConstructMetaspots.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"ConstructMetaspots — ConstructMetaspots","text":"","code":"ConstructMetaspots(   cur_seurat,   mode = \"sum\",   assay = \"Spatial\",   slot = \"counts\",   layer = \"counts\" )"},{"path":"https://smorabit.github.io/hdWGCNA/reference/ConstructMetaspots.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"ConstructMetaspots — ConstructMetaspots","text":"cur_seurat Seurat object mode \"sum\" \"average\" assay Assay extract data aggregation. Default = 'Spatial' slot Slot extract data aggregation. Default = 'counts' layer Layer extract data aggregation. Default = 'counts'. Layer used Seurat v5 instead slot.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/ConstructNetwork.html","id":null,"dir":"Reference","previous_headings":"","what":"ConstructNetwork — ConstructNetwork","title":"ConstructNetwork — ConstructNetwork","text":"Constructs co-expression network groups genes modules given Seurat object prepared network analysis.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/ConstructNetwork.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"ConstructNetwork — ConstructNetwork","text":"","code":"ConstructNetwork(   seurat_obj,   soft_power = NULL,   min_power = 3,   tom_outdir = \"TOM\",   tom_name = NULL,   consensus = FALSE,   overwrite_tom = FALSE,   wgcna_name = NULL,   blocks = NULL,   maxBlockSize = 30000,   randomSeed = 12345,   corType = \"pearson\",   consensusQuantile = 0.3,   networkType = \"signed\",   TOMType = \"signed\",   TOMDenom = \"min\",   scaleTOMs = TRUE,   calibrationQuantile = 0.8,   sampleForCalibration = TRUE,   sampleForCalibrationFactor = 1000,   useDiskCache = TRUE,   chunkSize = NULL,   deepSplit = 4,   pamStage = FALSE,   detectCutHeight = 0.995,   minModuleSize = 50,   mergeCutHeight = 0.2,   saveConsensusTOMs = TRUE,   ... )"},{"path":"https://smorabit.github.io/hdWGCNA/reference/ConstructNetwork.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"ConstructNetwork — ConstructNetwork","text":"seurat_obj Seurat object soft_power soft power used network construction. Automatically selected default. min_power smallest soft power selected soft_power=NULL tom_outdir path directory TOM written tom_name prefix name given TOM output file consensus flag indicating whether perform Consensus network analysis wgcna_name name WGCNA experiment ... additional parameters passed blockwiseConsensusModules","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/ConstructNetwork.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"ConstructNetwork — ConstructNetwork","text":"seurat_obj co-expression network gene modules computed selected wgcna experiment","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/ConstructNetwork.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"ConstructNetwork — ConstructNetwork","text":"ConstructNetwork builds co-expression network identifies clusters highly co-expressed genes (modules) metacell metaspot expression matrix stored Seurat object. running function, following functions must run input Seurat object: SetupForWGCNA MetacellsByGroups MetaspotsByGroups, NormalizeMetacells SetDatExpr SetMultiExpr TestSoftPowers TestSoftPowersConsensus function can also used perform consensus network analysis consensus=TRUE selected. ConstructNetwork calls WGCNA function blockwiseConsensusModules compute adjacency matrix, topological overlap matrix, run Dynamic Tree Cut algorithm identify gene modules. blockwiseConsensusModules numerous parameters selected default parameters found provide reasonable results variety single-cell spatial transcriptomic datasets.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/ConstructPseudobulk.html","id":null,"dir":"Reference","previous_headings":"","what":"ConstructPseudobulk — ConstructPseudobulk","title":"ConstructPseudobulk — ConstructPseudobulk","text":"Constructs \"pseudobulk\" gene expression matrix summarizing expression levels gene across grouping variable (cell types example) biological replicate.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/ConstructPseudobulk.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"ConstructPseudobulk — ConstructPseudobulk","text":"","code":"ConstructPseudobulk(   seurat_obj,   group.by,   replicate_col,   label_col = NULL,   assay = \"RNA\",   slot = \"counts\",   layer = \"counts\",   min_reps = 20,   wgcna_name = NULL )"},{"path":"https://smorabit.github.io/hdWGCNA/reference/ConstructPseudobulk.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"ConstructPseudobulk — ConstructPseudobulk","text":"seurat_obj Seurat object group.column seurat_obj@meta.data containing grouping info, ie clusters celltypes replicate_col column seurat_obj@meta.data denoting replicate / sample label_col column seurat_obj@meta.data denoting additional label interest, example disease status biological sex. required argument typically used consensus WGCNA assay Assay seurat_obj containing isoform expression information. slot Slot extract data aggregation. Default = 'counts' layer Layer extract data aggregation. Default = 'counts'. Layer used Seurat v5 instead slot. min_reps minimum number different biological replicates allowed. Error thrown number reps low. wgcna_name name hdWGCNA experiment seurat_obj@misc slot","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/ConstructPseudobulk.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"ConstructPseudobulk — ConstructPseudobulk","text":"matrix containing pseudobulk expression profiles","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/ConstructPseudobulk.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"ConstructPseudobulk — ConstructPseudobulk","text":"function constructs pseudobulk gene expression profiles across provided cell groups provided biological replicates. note low numbers replicates typical single-cell spatial transcriptomics due large monetary cost running experiments, pseudobulk-ing data hdWGCNA recommended case sufficient number replicates. set minimum recommended number 20. Using fewer 20 replicates risks results reproducible robust, therefore biologically meaningful due spurious noisy correlations.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/ConstructTFNetwork.html","id":null,"dir":"Reference","previous_headings":"","what":"ConstructTFNetwork — ConstructTFNetwork","title":"ConstructTFNetwork — ConstructTFNetwork","text":"Construct network transcription factors target genes based gene co-expression","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/ConstructTFNetwork.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"ConstructTFNetwork — ConstructTFNetwork","text":"","code":"ConstructTFNetwork(seurat_obj, model_params, nfold = 5, wgcna_name = NULL)"},{"path":"https://smorabit.github.io/hdWGCNA/reference/ConstructTFNetwork.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"ConstructTFNetwork — ConstructTFNetwork","text":"seurat_obj Seurat object model_params list model parameters pass xgboost nfold number folds cross validation wgcna_name name WGCNA experiment","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/ConstructTFNetwork.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"ConstructTFNetwork — ConstructTFNetwork","text":"seurat_obj TF network added","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/ConstructTFNetwork.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"ConstructTFNetwork — ConstructTFNetwork","text":"ConstructTFNetwork uses motif-gene information build directed network transcription factors (TFs) target genes. XGBoost regression leveraged model expression gene based candidate TF regulators. analysis gives us information important TF predicting gene, allowing us prioritize likely regulators gene. process done gene expression matrix stored SetDatExpr, typically hdWGCNA metacell gene expression matrix.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/DimPlotMetacells.html","id":null,"dir":"Reference","previous_headings":"","what":"DimPlotMetacells — DimPlotMetacells","title":"DimPlotMetacells — DimPlotMetacells","text":"Wrapper function run Seurat's DimPlot function metacell object.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/DimPlotMetacells.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"DimPlotMetacells — DimPlotMetacells","text":"","code":"DimPlotMetacells(seurat_obj, ...)"},{"path":"https://smorabit.github.io/hdWGCNA/reference/DimPlotMetacells.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"DimPlotMetacells — DimPlotMetacells","text":"seurat_obj Seurat object","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/DoHubGeneHeatmap.html","id":null,"dir":"Reference","previous_headings":"","what":"Plots gene expression of hub genes as a heatmap — DoHubGeneHeatmap","title":"Plots gene expression of hub genes as a heatmap — DoHubGeneHeatmap","text":"function makes expression heatmap top n hub genes per module using Seurat's DoHeatmap, assembles one big heatmap.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/DoHubGeneHeatmap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plots gene expression of hub genes as a heatmap — DoHubGeneHeatmap","text":"","code":"DoHubGeneHeatmap(   seurat_obj,   n_hubs = 10,   n_cells = 200,   group.by = NULL,   module_names = NULL,   combine = TRUE,   draw.lines = TRUE,   disp.min = -2.5,   disp.max = 2.5,   wgcna_name = NULL )"},{"path":"https://smorabit.github.io/hdWGCNA/reference/DoHubGeneHeatmap.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plots gene expression of hub genes as a heatmap — DoHubGeneHeatmap","text":"seurat_obj Seurat object wgcna_name name hdWGCNA experiment seurat_obj@misc slot","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/DoHubGeneHeatmap.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plots gene expression of hub genes as a heatmap — DoHubGeneHeatmap","text":"","code":"DoHubGeneHeatmap #> function (seurat_obj, n_hubs = 10, n_cells = 200, group.by = NULL,  #>     module_names = NULL, combine = TRUE, draw.lines = TRUE, disp.min = -2.5,  #>     disp.max = 2.5, wgcna_name = NULL)  #> { #>     if (is.null(wgcna_name)) { #>         wgcna_name <- seurat_obj@misc$active_wgcna #>     } #>     if (is.null(group.by)) { #>         group.by <- \"temp_ident\" #>         seurat_obj$temp_ident <- Idents(seurat_obj) #>     } #>     seurat_obj@meta.data[[group.by]] <- droplevels(seurat_obj@meta.data[[group.by]]) #>     modules <- GetModules(seurat_obj, wgcna_name) #>     modules <- modules %>% subset(module != \"grey\") %>% mutate(module = droplevels(module)) #>     mods <- levels(modules$module) #>     if (!is.null(module_names)) { #>         print(\"here\") #>         mods <- module_names #>         modules <- modules %>% subset(module %in% mods) #>     } #>     mod_colors <- modules %>% dplyr::select(c(module, color)) %>%  #>         dplyr::distinct() #>     hub_list <- lapply(mods, function(cur_mod) { #>         cur <- subset(modules, module == cur_mod) #>         cur <- cur[, c(\"gene_name\", paste0(\"kME_\", cur_mod))] %>%  #>             top_n(n_hubs) #>         colnames(cur)[2] <- \"var\" #>         cur %>% arrange(desc(var)) %>% .$gene_name #>     }) #>     names(hub_list) <- mods #>     print(hub_list) #>     seurat_obj$barcode <- colnames(seurat_obj) #>     temp <- table(seurat_obj@meta.data[[group.by]]) #>     df <- data.frame() #>     for (i in 1:length(temp)) { #>         if (temp[[i]] < n_cells) { #>             cur_df <- seurat_obj@meta.data %>% subset(get(group.by) ==  #>                 names(temp)[i]) #>         } #>         else { #>             cur_df <- seurat_obj@meta.data %>% subset(get(group.by) ==  #>                 names(temp)[i]) %>% sample_n(n_cells) #>         } #>         df <- rbind(df, cur_df) #>     } #>     seurat_plot <- seurat_obj %>% subset(barcode %in% df$barcode) #>     plot_list <- list() #>     for (i in 1:length(hub_list)) { #>         print(i) #>         cur_mod <- names(hub_list)[i] #>         print(i) #>         print(hub_list[[i]]) #>         print(i) #>         if (i == 1) { #>             plot_list[[i]] <- DoHeatmap(seurat_plot, features = hub_list[[i]],  #>                 group.by = group.by, raster = TRUE, slot = \"scale.data\",  #>                 disp.min = disp.min, disp.max = disp.max, label = FALSE,  #>                 group.bar = FALSE, draw.lines = draw.lines) #>         } #>         else { #>             plot_list[[i]] <- DoHeatmap(seurat_plot, features = hub_list[[i]],  #>                 group.by = group.by, raster = TRUE, slot = \"scale.data\",  #>                 group.bar.height = 0, label = FALSE, group.bar = FALSE,  #>                 draw.lines = draw.lines, disp.min = disp.min,  #>                 disp.max = disp.max) + NoLegend() #>         } #>         print(i) #>         plot_list[[i]] <- plot_list[[i]] + theme(plot.margin = margin(0,  #>             0, 0, 0), axis.text.y = element_text(face = \"italic\")) +  #>             scale_y_discrete(position = \"right\") #>         print(i) #>     } #>     n_total_cells <- ncol(seurat_plot) #>     width_cbar <- n_total_cells/50 #>     mod_colors$value <- n_hubs #>     mod_colors$dummy <- \"colorbar\" #>     cbar_list <- list() #>     for (i in 1:nrow(mod_colors)) { #>         cbar_list[[i]] <- mod_colors[i, ] %>% ggplot(aes(y = value,  #>             x = dummy)) + geom_bar(position = \"stack\", stat = \"identity\",  #>             fill = mod_colors[i, ]$color) + umap_theme() + theme(plot.margin = margin(0,  #>             0, 0, 0)) #>     } #>     p_cbar <- wrap_plots(cbar_list, ncol = 1) #>     if (combine) { #>         out <- wrap_plots(plot_list, ncol = 1) + plot_layout(guides = \"collect\") #>         out <- (p_cbar | out) + plot_layout(widths = c(width_cbar,  #>             n_total_cells)) #>     } #>     else { #>         out <- plot_list #>     } #>     out #> } #> <bytecode: 0x7f962e6ffa00> #> <environment: namespace:hdWGCNA>"},{"path":"https://smorabit.github.io/hdWGCNA/reference/EnrichrBarPlot.html","id":null,"dir":"Reference","previous_headings":"","what":"EnrichrBarPlot — EnrichrBarPlot","title":"EnrichrBarPlot — EnrichrBarPlot","text":"Makes barplots RunEnrichr output.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/EnrichrBarPlot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"EnrichrBarPlot — EnrichrBarPlot","text":"","code":"EnrichrBarPlot(   seurat_obj,   outdir = \"enrichr_plots\",   n_terms = 25,   plot_size = c(6, 15),   logscale = FALSE,   plot_bar_color = NULL,   plot_text_color = NULL,   wgcna_name = NULL,   ... )"},{"path":"https://smorabit.github.io/hdWGCNA/reference/EnrichrBarPlot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"EnrichrBarPlot — EnrichrBarPlot","text":"seurat_obj Seurat object outdir directory place output .pdf files n_terms number terms plot barplot plot_size size output .pdf files (width, height) logscale logical controlling whether plot enrichment log scale plot_bar_color color bars bar plots. Default option (NULL) makes bars colored using module's assigned color. plot_text_color color text labels bar plots wgcna_name name hdWGCNA experiment seurat_obj@misc slot","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/EnrichrBarPlot.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"EnrichrBarPlot — EnrichrBarPlot","text":"","code":"EnrichrBarPlot #> function (seurat_obj, outdir = \"enrichr_plots\", n_terms = 25,  #>     plot_size = c(6, 15), logscale = FALSE, plot_bar_color = NULL,  #>     plot_text_color = NULL, wgcna_name = NULL, ...)  #> { #>     if (is.null(wgcna_name)) { #>         wgcna_name <- seurat_obj@misc$active_wgcna #>     } #>     modules <- GetModules(seurat_obj, wgcna_name) #>     mods <- levels(modules$module) #>     mods <- mods[mods != \"grey\"] #>     enrichr_df <- GetEnrichrTable(seurat_obj, wgcna_name) #>     wrapText <- function(x, len) { #>         sapply(x, function(y) paste(strwrap(y, len), collapse = \"\\n\"),  #>             USE.NAMES = FALSE) #>     } #>     if (!dir.exists(outdir)) { #>         dir.create(outdir) #>     } #>     for (i in 1:length(mods)) { #>         cur_mod <- mods[i] #>         cur_terms <- subset(enrichr_df, module == cur_mod) #>         print(cur_mod) #>         cur_color <- modules %>% subset(module == cur_mod) %>%  #>             .$color %>% unique %>% as.character #>         if (!is.null(plot_bar_color)) { #>             cur_color <- plot_bar_color #>         } #>         if (nrow(cur_terms) == 0) { #>             next #>         } #>         cur_terms$wrap <- wrapText(cur_terms$Term, 45) #>         plot_list <- list() #>         for (cur_db in dbs) { #>             plot_df <- subset(cur_terms, db == cur_db) %>% top_n(n_terms,  #>                 wt = Combined.Score) #>             if (is.null(plot_text_color)) { #>                 if (cur_color == \"black\") { #>                   text_color = \"grey\" #>                 } #>                 else { #>                   text_color = \"black\" #>                 } #>             } #>             else { #>                 text_color <- plot_text_color #>             } #>             if (logscale) { #>                 plot_df$Combined.Score <- log(plot_df$Combined.Score) #>                 lab <- \"Enrichment log(combined score)\" #>                 x <- 0.2 #>             } #>             else { #>                 lab <- \"Enrichment (combined score)\" #>                 x <- 5 #>             } #>             plot_list[[cur_db]] <- ggplot(plot_df, aes(x = Combined.Score,  #>                 y = reorder(wrap, Combined.Score))) + geom_bar(stat = \"identity\",  #>                 position = \"identity\", color = \"white\", fill = cur_color) +  #>                 geom_text(aes(label = wrap), x = x, color = text_color,  #>                   size = 3.5, hjust = \"left\") + ylab(\"Term\") +  #>                 xlab(lab) + ggtitle(cur_db) + theme(panel.grid.major = element_blank(),  #>                 panel.grid.minor = element_blank(), legend.title = element_blank(),  #>                 axis.ticks.y = element_blank(), axis.text.y = element_blank(),  #>                 plot.title = element_text(hjust = 0.5)) #>         } #>         pdf(paste0(outdir, \"/\", cur_mod, \".pdf\"), width = plot_size[1],  #>             height = plot_size[2]) #>         for (plot in plot_list) { #>             print(plot) #>         } #>         dev.off() #>     } #> } #> <bytecode: 0x7f962fdbb2d0> #> <environment: namespace:hdWGCNA>"},{"path":"https://smorabit.github.io/hdWGCNA/reference/EnrichrDotPlot.html","id":null,"dir":"Reference","previous_headings":"","what":"EnrichrDotPlot — EnrichrDotPlot","title":"EnrichrDotPlot — EnrichrDotPlot","text":"Makes barplots Enrichr data","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/EnrichrDotPlot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"EnrichrDotPlot — EnrichrDotPlot","text":"","code":"EnrichrDotPlot(   seurat_obj,   database,   mods = \"all\",   n_terms = 3,   break_ties = TRUE,   logscale = TRUE,   wgcna_name = NULL,   ... )"},{"path":"https://smorabit.github.io/hdWGCNA/reference/EnrichrDotPlot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"EnrichrDotPlot — EnrichrDotPlot","text":"seurat_obj Seurat object database name enrichr database plot. mods names modules plot. modules plotted mods='' (default) n_terms number enriched terms plot module break_ties logical controlling whether randomly select terms equal enrichments precisely enforce n_terms. logscale logical controlling whether plot enrichment log scale. wgcna_name name hdWGCNA experiment seurat_obj@misc slot","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/EnrichrDotPlot.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"EnrichrDotPlot — EnrichrDotPlot","text":"","code":"EnrichrDotPlot #> function (seurat_obj, database, mods = \"all\", n_terms = 3, break_ties = TRUE,  #>     logscale = TRUE, wgcna_name = NULL, ...)  #> { #>     if (is.null(wgcna_name)) { #>         wgcna_name <- seurat_obj@misc$active_wgcna #>     } #>     modules <- GetModules(seurat_obj, wgcna_name) #>     if (mods == \"all\") { #>         mods <- levels(modules$module) #>         mods <- mods[mods != \"grey\"] #>     } #>     enrichr_df <- GetEnrichrTable(seurat_obj, wgcna_name) #>     mod_colors <- dplyr::select(modules, c(module, color)) %>%  #>         dplyr::distinct() #>     enrichr_df$color <- mod_colors[match(enrichr_df$module, mod_colors$module),  #>         \"color\"] #>     wrapText <- function(x, len) { #>         sapply(x, function(y) paste(strwrap(y, len), collapse = \"\\n\"),  #>             USE.NAMES = FALSE) #>     } #>     plot_df <- enrichr_df %>% subset(db == database & module %in%  #>         mods) %>% group_by(module) %>% top_n(n_terms, wt = Combined.Score) #>     if (break_ties) { #>         plot_df <- do.call(rbind, lapply(plot_df %>% group_by(module) %>%  #>             group_split, function(x) { #>             x[sample(n_terms), ] #>         })) #>     } #>     plot_df$Term <- wrapText(plot_df$Term, 45) #>     plot_df$module <- factor(as.character(plot_df$module), levels = levels(modules$module)) #>     plot_df <- arrange(plot_df, module) #>     plot_df$Term <- factor(as.character(plot_df$Term), levels = unique(as.character(plot_df$Term))) #>     if (logscale) { #>         plot_df$Combined.Score <- log(plot_df$Combined.Score) #>         lab <- \"Enrichment\\nlog(combined score)\" #>         x <- 0.2 #>     } #>     else { #>         lab <- \"Enrichment\\n(combined score)\" #>         x <- 5 #>     } #>     p <- plot_df %>% ggplot(aes(x = module, y = Term)) + geom_point(aes(size = Combined.Score),  #>         color = plot_df$color) + RotatedAxis() + ylab(\"\") + xlab(\"\") +  #>         labs(size = lab) + scale_y_discrete(limits = rev) + ggtitle(database) +  #>         theme(plot.title = element_text(hjust = 0.5), axis.line.x = element_blank(),  #>             axis.line.y = element_blank(), panel.border = element_rect(colour = \"black\",  #>                 fill = NA, size = 1)) #>     p #> } #> <bytecode: 0x7f96312257b8> #> <environment: namespace:hdWGCNA>"},{"path":"https://smorabit.github.io/hdWGCNA/reference/FindAllDMEs.html","id":null,"dir":"Reference","previous_headings":"","what":"FindAllDMEs — FindAllDMEs","title":"FindAllDMEs — FindAllDMEs","text":"Function compare expression levels co-expression modules two sets cell barcodes.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/FindAllDMEs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"FindAllDMEs — FindAllDMEs","text":"","code":"FindAllDMEs(   seurat_obj,   group.by,   features = \"MEs\",   harmonized = TRUE,   add_missing = FALSE,   wgcna_name = NULL,   test.use = \"wilcox\",   only.pos = FALSE,   logfc.threshold = 0,   min.pct = 0,   verbose = FALSE,   pseudocount.use = 0,   ... )"},{"path":"https://smorabit.github.io/hdWGCNA/reference/FindAllDMEs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"FindAllDMEs — FindAllDMEs","text":"seurat_obj Seurat object group.column seurat_obj@meta.data containing cell grouping information features indicate whether use \"MEs\" \"ModuleScores\" comparison harmonized logical determining whether use harmonized MEs add_missing logical determining whether add missing modules back resulting dataframe NA values. wgcna_name name hdWGCNA experiment seurat_obj@misc slot ... Additional parameters FindMarkers function","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/FindAllDMEs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"FindAllDMEs — FindAllDMEs","text":"dataframe contaning differential results","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/FindAllDMEs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"FindAllDMEs — FindAllDMEs","text":"","code":"FindAllDMEs #> function (seurat_obj, group.by, features = \"MEs\", harmonized = TRUE,  #>     add_missing = FALSE, wgcna_name = NULL, test.use = \"wilcox\",  #>     only.pos = FALSE, logfc.threshold = 0, min.pct = 0, verbose = FALSE,  #>     pseudocount.use = 0, ...)  #> { #>     if (is.null(wgcna_name)) { #>         wgcna_name <- seurat_obj@misc$active_wgcna #>     } #>     CheckWGCNAName(seurat_obj, wgcna_name) #>     groups <- as.character(unique(seurat_obj@meta.data[[group.by]])) #>     if (features == \"MEs\") { #>         MEs <- GetMEs(seurat_obj, harmonized, wgcna_name) #>     } #>     else if (features == \"ModuleScores\") { #>         MEs <- GetModuleScores(seurat_obj, wgcna_name) #>     } #>     else { #>         stop(\"Invalid selection for features. Valid choices are MEs or ModuleScores.\") #>     } #>     MEs <- MEs[, colnames(MEs) != \"grey\"] #>     MEs[MEs < 0] <- 0 #>     MEs <- t(MEs) #>     ME_assay <- Seurat::CreateAssayObject(MEs) #>     DMEs_list <- list() #>     for (cur_group in groups) { #>         print(cur_group) #>         barcodes1 <- colnames(seurat_obj)[seurat_obj@meta.data[[group.by]] ==  #>             cur_group] #>         barcodes2 <- colnames(seurat_obj)[seurat_obj@meta.data[[group.by]] !=  #>             cur_group] #>         DMEs <- FindMarkers(ME_assay, cells.1 = barcodes1, cells.2 = barcodes2,  #>             slot = \"counts\", test.use = test.use, only.pos = only.pos,  #>             logfc.threshold = logfc.threshold, min.pct = min.pct,  #>             verbose = verbose, pseudocount.use = pseudocount.use,  #>             ...) #>         DMEs$module <- rownames(DMEs) #>         DMEs$group <- cur_group #>         if (add_missing) { #>             missing_mods <- rownames(MEs)[!(rownames(MEs) %in%  #>                 DMEs$module)] #>             for (cur_mod in missing_mods) { #>                 DMEs[cur_mod, ] <- NA #>                 DMEs[cur_mod, \"module\"] <- cur_mod #>             } #>         } #>         DMEs_list[[cur_group]] <- DMEs #>     } #>     DMEs <- do.call(rbind, DMEs_list) #>     DMEs #> } #> <bytecode: 0x7f9618254dd0> #> <environment: namespace:hdWGCNA>"},{"path":"https://smorabit.github.io/hdWGCNA/reference/FindDMEs.html","id":null,"dir":"Reference","previous_headings":"","what":"FindDMEs — FindDMEs","title":"FindDMEs — FindDMEs","text":"Function compare expression levels co-expression modules two sets cell barcodes.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/FindDMEs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"FindDMEs — FindDMEs","text":"","code":"FindDMEs(   seurat_obj,   barcodes1,   barcodes2,   features = \"MEs\",   harmonized = TRUE,   wgcna_name = NULL,   add_missing = FALSE,   test.use = \"wilcox\",   only.pos = FALSE,   logfc.threshold = 0,   min.pct = 0,   verbose = FALSE,   pseudocount.use = 0,   ... )"},{"path":"https://smorabit.github.io/hdWGCNA/reference/FindDMEs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"FindDMEs — FindDMEs","text":"seurat_obj Seurat object barcodes1 character vector containing cell barcodes first group test. Positive fold-change means -regulated group. barcodes2 character vector containing cell barcodes second group test. Negative fold-change means -regulated group. features indicate whether use \"MEs\" \"ModuleScores\" comparison harmonized logical determining whether use harmonized MEs wgcna_name name hdWGCNA experiment seurat_obj@misc slot add_missing logical determining whether add missing modules back resulting dataframe NA values. ... Additional parameters FindMarkers function","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/FindDMEs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"FindDMEs — FindDMEs","text":"dataframe contaning differential results","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/FindDMEs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"FindDMEs — FindDMEs","text":"","code":"FindDMEs #> function (seurat_obj, barcodes1, barcodes2, features = \"MEs\",  #>     harmonized = TRUE, wgcna_name = NULL, add_missing = FALSE,  #>     test.use = \"wilcox\", only.pos = FALSE, logfc.threshold = 0,  #>     min.pct = 0, verbose = FALSE, pseudocount.use = 0, ...)  #> { #>     if (is.null(wgcna_name)) { #>         wgcna_name <- seurat_obj@misc$active_wgcna #>     } #>     CheckWGCNAName(seurat_obj, wgcna_name) #>     if (!(all(barcodes1 %in% colnames(seurat_obj)))) { #>         stop(\"Some barcodes in barcodes1 not found in colnames(seurat_obj).\") #>     } #>     if (!(all(barcodes2 %in% colnames(seurat_obj)))) { #>         stop(\"Some barcodes in barcodes2 not found in colnames(seurat_obj).\") #>     } #>     if (length(intersect(barcodes1, barcodes2)) > 0) { #>         stop(\"Some barcodes overlap in barcodes1 and barcodes2\") #>     } #>     if (features == \"MEs\") { #>         MEs <- GetMEs(seurat_obj, harmonized, wgcna_name) #>     } #>     else if (features == \"ModuleScores\") { #>         MEs <- GetModuleScores(seurat_obj, wgcna_name) #>     } #>     else { #>         stop(\"Invalid selection for features. Valid choices are MEs or ModuleScores.\") #>     } #>     MEs <- MEs[, colnames(MEs) != \"grey\"] #>     MEs[MEs < 0] <- 0 #>     MEs <- t(MEs) #>     ME_assay <- Seurat::CreateAssayObject(MEs) #>     DMEs <- FindMarkers(ME_assay, cells.1 = barcodes1, cells.2 = barcodes2,  #>         slot = \"counts\", test.use = test.use, only.pos = only.pos,  #>         logfc.threshold = logfc.threshold, min.pct = min.pct,  #>         verbose = verbose, pseudocount.use = pseudocount.use,  #>         ...) #>     DMEs$module <- rownames(DMEs) #>     if (add_missing) { #>         missing_mods <- rownames(MEs)[!(rownames(MEs) %in% DMEs$module)] #>         for (cur_mod in missing_mods) { #>             DMEs[cur_mod, ] <- NA #>             DMEs[cur_mod, \"module\"] <- cur_mod #>         } #>     } #>     DMEs #> } #> <bytecode: 0x7f9628d0a878> #> <environment: namespace:hdWGCNA>"},{"path":"https://smorabit.github.io/hdWGCNA/reference/FindDifferentialRegulons.html","id":null,"dir":"Reference","previous_headings":"","what":"FindDifferentialRegulons — FindDifferentialRegulons","title":"FindDifferentialRegulons — FindDifferentialRegulons","text":"Function compare TF regulon scores two sets cell barcodes.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/FindDifferentialRegulons.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"FindDifferentialRegulons — FindDifferentialRegulons","text":"","code":"FindDifferentialRegulons(   seurat_obj,   barcodes1,   barcodes2,   assay = \"RNA\",   slot = \"data\",   layer = \"data\",   wgcna_name = NULL,   test.use = \"wilcox\",   only.pos = FALSE,   logfc.threshold = 0,   min.pct = 0,   verbose = FALSE,   pseudocount.use = 0,   ... )"},{"path":"https://smorabit.github.io/hdWGCNA/reference/FindDifferentialRegulons.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"FindDifferentialRegulons — FindDifferentialRegulons","text":"seurat_obj Seurat object barcodes1 character vector containing cell barcodes first group test. Positive fold-change means -regulated group. barcodes2 character vector containing cell barcodes second group test. Negative fold-change means -regulated group. assay Assay extract data aggregation. Default = 'RNA' slot Slot extract data aggregation. Default = 'counts'. Slot used Seurat v4 instead layer. layer Layer extract data aggregation. Default = 'counts'. Layer used Seurat v5 instead slot. wgcna_name name hdWGCNA experiment seurat_obj@misc slot ... Additional parameters Seurat FindMarkers function","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/FindDifferentialRegulons.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"FindDifferentialRegulons — FindDifferentialRegulons","text":"dataframe contaning differential regulon results","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/FindDifferentialRegulons.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"FindDifferentialRegulons — FindDifferentialRegulons","text":"FindDifferentialRegulons compares two groups based TF regulon scores. Three comparisons made different sets features: positive regulon scores, negative regulon scores, gene expression. settings test used three tests.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/FindMajorIsoforms.html","id":null,"dir":"Reference","previous_headings":"","what":"FindMajorIsoforms — FindMajorIsoforms","title":"FindMajorIsoforms — FindMajorIsoforms","text":"Finds set \"major isoforms\" gene cell population. set major isoforms consists isoforms accounting desired proportion gene's expression. Pseudobulk replicates sample cell population used calculation.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/FindMajorIsoforms.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"FindMajorIsoforms — FindMajorIsoforms","text":"","code":"FindMajorIsoforms(   seurat_obj,   group.by,   replicate_col,   isoform_delim = \"[.]\",   proportion_thresh = 0.8,   low_thresh = 25,   assay = \"iso\",   slot = \"counts\",   cluster_markers = NULL,   wgcna_name = NULL )"},{"path":"https://smorabit.github.io/hdWGCNA/reference/FindMajorIsoforms.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"FindMajorIsoforms — FindMajorIsoforms","text":"seurat_obj Seurat object group.column seurat_obj@meta.data containing grouping info, ie clusters celltypes replicate_col column seurat_obj@meta.data denoting replicate / sample isoform_delim  proportion_thresh desired proportion expression define set major isoforms. Default = 0.8. low_thresh lower bound expression level considering isoform part major isoform set. assay Assay seurat_obj containing isoform expression information. slot Slot seurat_obj, default counts slot. cluster_markers Cell population marker gene table Seurat FindAllMarkers cell populations specified group.. Optional parameter, exclude isoforms marker genes. wgcna_name name hdWGCNA experiment seurat_obj@misc slot","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/FindMajorIsoforms.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"FindMajorIsoforms — FindMajorIsoforms","text":"list major isoforms cell population","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/FindMajorIsoforms.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"FindMajorIsoforms — FindMajorIsoforms","text":"FindMajorIsoforms computes set major isoforms given Seurat object contains isoform-level expression information. First, pseudobulk replicates computed given cell populations samples present Seurat object. gene cell population, rank gene's isoforms expression level take top expressing isoforms make desired proportion gene's total expression, making sure exclude lowly expressed isoforms. Optionally, user may supply marker gene table cell population (formatted like output Seurat FindAllMarkers), algorithm return major isoforms given marker genes.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/GetActiveWGCNA.html","id":null,"dir":"Reference","previous_headings":"","what":"GetActiveWGCNA — GetActiveWGCNA","title":"GetActiveWGCNA — GetActiveWGCNA","text":"GetActiveWGCNA","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/GetActiveWGCNA.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"GetActiveWGCNA — GetActiveWGCNA","text":"","code":"GetActiveWGCNA(seurat_obj)"},{"path":"https://smorabit.github.io/hdWGCNA/reference/GetActiveWGCNA.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"GetActiveWGCNA — GetActiveWGCNA","text":"seurat_obj Seurat object","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/GetActiveWGCNAName.html","id":null,"dir":"Reference","previous_headings":"","what":"GetActiveWGCNAName — GetActiveWGCNAName","title":"GetActiveWGCNAName — GetActiveWGCNAName","text":"GetActiveWGCNAName","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/GetActiveWGCNAName.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"GetActiveWGCNAName — GetActiveWGCNAName","text":"","code":"GetActiveWGCNAName(seurat_obj)"},{"path":"https://smorabit.github.io/hdWGCNA/reference/GetActiveWGCNAName.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"GetActiveWGCNAName — GetActiveWGCNAName","text":"seurat_obj Seurat object","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/GetAvgModuleExpr.html","id":null,"dir":"Reference","previous_headings":"","what":"GetAvgModuleExpr — GetAvgModuleExpr","title":"GetAvgModuleExpr — GetAvgModuleExpr","text":"GetAvgModuleExpr","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/GetAvgModuleExpr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"GetAvgModuleExpr — GetAvgModuleExpr","text":"","code":"GetAvgModuleExpr(seurat_obj, wgcna_name = NULL)"},{"path":"https://smorabit.github.io/hdWGCNA/reference/GetAvgModuleExpr.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"GetAvgModuleExpr — GetAvgModuleExpr","text":"seurat_obj Seurat object wgcna_name name hdWGCNA experiment seurat_obj@misc slot","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/GetDatExpr.html","id":null,"dir":"Reference","previous_headings":"","what":"GetDatExpr — GetDatExpr","title":"GetDatExpr — GetDatExpr","text":"function gets WGCNA expression matrix.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/GetDatExpr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"GetDatExpr — GetDatExpr","text":"","code":"GetDatExpr(seurat_obj, wgcna_name = NULL)"},{"path":"https://smorabit.github.io/hdWGCNA/reference/GetDatExpr.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"GetDatExpr — GetDatExpr","text":"seurat_obj Seurat object","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/GetDegrees.html","id":null,"dir":"Reference","previous_headings":"","what":"GetDegrees — GetDegrees","title":"GetDegrees — GetDegrees","text":"GetDegrees","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/GetDegrees.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"GetDegrees — GetDegrees","text":"","code":"GetDegrees(seurat_obj, wgcna_name = NULL)"},{"path":"https://smorabit.github.io/hdWGCNA/reference/GetDegrees.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"GetDegrees — GetDegrees","text":"seurat_obj Seurat object wgcna_name name hdWGCNA experiment seurat_obj@misc slot","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/GetEnrichrRegulonTable.html","id":null,"dir":"Reference","previous_headings":"","what":"GetEnrichrRegulonTable — GetEnrichrRegulonTable","title":"GetEnrichrRegulonTable — GetEnrichrRegulonTable","text":"GetEnrichrRegulonTable","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/GetEnrichrRegulonTable.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"GetEnrichrRegulonTable — GetEnrichrRegulonTable","text":"","code":"GetEnrichrRegulonTable(seurat_obj, wgcna_name = NULL)"},{"path":"https://smorabit.github.io/hdWGCNA/reference/GetEnrichrRegulonTable.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"GetEnrichrRegulonTable — GetEnrichrRegulonTable","text":"seurat_obj Seurat object wgcna_name name hdWGCNA experiment seurat_obj@misc slot","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/GetEnrichrTable.html","id":null,"dir":"Reference","previous_headings":"","what":"GetEnrichrTable — GetEnrichrTable","title":"GetEnrichrTable — GetEnrichrTable","text":"GetEnrichrTable","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/GetEnrichrTable.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"GetEnrichrTable — GetEnrichrTable","text":"","code":"GetEnrichrTable(seurat_obj, wgcna_name = NULL)"},{"path":"https://smorabit.github.io/hdWGCNA/reference/GetEnrichrTable.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"GetEnrichrTable — GetEnrichrTable","text":"seurat_obj Seurat object wgcna_name name hdWGCNA experiment seurat_obj@misc slot","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/GetHubGenes.html","id":null,"dir":"Reference","previous_headings":"","what":"GetHubGenes — GetHubGenes","title":"GetHubGenes — GetHubGenes","text":"Extract top N hub genes given set modules. function outputs table gene name, module, kME module top N hub genes.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/GetHubGenes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"GetHubGenes — GetHubGenes","text":"","code":"GetHubGenes(seurat_obj, n_hubs = 10, mods = NULL, wgcna_name = NULL)"},{"path":"https://smorabit.github.io/hdWGCNA/reference/GetHubGenes.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"GetHubGenes — GetHubGenes","text":"seurat_obj Seurat object n_hubs number hub genes select module mods list modules, selects modules default wgcna_name name hdWGCNA experiment seurat_obj@misc slot","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/GetMELoadings.html","id":null,"dir":"Reference","previous_headings":"","what":"GetMELoadings — GetMELoadings","title":"GetMELoadings — GetMELoadings","text":"Function retrieve module eigengens Seurat object.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/GetMELoadings.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"GetMELoadings — GetMELoadings","text":"","code":"GetMELoadings(seurat_obj, harmonized = TRUE, wgcna_name = NULL)"},{"path":"https://smorabit.github.io/hdWGCNA/reference/GetMELoadings.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"GetMELoadings — GetMELoadings","text":"seurat_obj Seurat object harmonized logical indicating whether MEs harmonized wgcna_name name hdWGCNA experiment seurat_obj@misc slot","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/GetMEs.html","id":null,"dir":"Reference","previous_headings":"","what":"GetMEs — GetMEs","title":"GetMEs — GetMEs","text":"Function retrieve module eigengens Seurat object.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/GetMEs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"GetMEs — GetMEs","text":"","code":"GetMEs(seurat_obj, harmonized = TRUE, wgcna_name = NULL)"},{"path":"https://smorabit.github.io/hdWGCNA/reference/GetMEs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"GetMEs — GetMEs","text":"seurat_obj Seurat object harmonized logical indicating whether MEs harmonized wgcna_name name hdWGCNA experiment seurat_obj@misc slot","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/GetMetacellObject.html","id":null,"dir":"Reference","previous_headings":"","what":"GetMetacellObject — GetMetacellObject","title":"GetMetacellObject — GetMetacellObject","text":"GetMetacellObject","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/GetMetacellObject.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"GetMetacellObject — GetMetacellObject","text":"","code":"GetMetacellObject(seurat_obj, wgcna_name = NULL)"},{"path":"https://smorabit.github.io/hdWGCNA/reference/GetMetacellObject.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"GetMetacellObject — GetMetacellObject","text":"seurat_obj Seurat object wgcna_name name hdWGCNA experiment seurat_obj@misc slot","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/GetMetacellParams.html","id":null,"dir":"Reference","previous_headings":"","what":"GetMetacellParams — GetMetacellParams","title":"GetMetacellParams — GetMetacellParams","text":"GetMetacellParams","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/GetMetacellParams.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"GetMetacellParams — GetMetacellParams","text":"","code":"GetMetacellParams(seurat_obj, wgcna_name = NULL)"},{"path":"https://smorabit.github.io/hdWGCNA/reference/GetMetacellParams.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"GetMetacellParams — GetMetacellParams","text":"seurat_obj Seurat object wgcna_name name hdWGCNA experiment seurat_obj@misc slot","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/GetModulePreservation.html","id":null,"dir":"Reference","previous_headings":"","what":"GetModulePreservation — GetModulePreservation","title":"GetModulePreservation — GetModulePreservation","text":"GetModulePreservation","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/GetModulePreservation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"GetModulePreservation — GetModulePreservation","text":"","code":"GetModulePreservation(seurat_obj, mod_name, wgcna_name = NULL)"},{"path":"https://smorabit.github.io/hdWGCNA/reference/GetModulePreservation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"GetModulePreservation — GetModulePreservation","text":"seurat_obj Seurat object mod_name name module preservation test store wgcna_name name hdWGCNA experiment seurat_obj@misc slot","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/GetModuleScores.html","id":null,"dir":"Reference","previous_headings":"","what":"GetModuleScores — GetModuleScores","title":"GetModuleScores — GetModuleScores","text":"GetModuleScores","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/GetModuleScores.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"GetModuleScores — GetModuleScores","text":"","code":"GetModuleScores(seurat_obj, wgcna_name = NULL)"},{"path":"https://smorabit.github.io/hdWGCNA/reference/GetModuleScores.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"GetModuleScores — GetModuleScores","text":"seurat_obj Seurat object wgcna_name name hdWGCNA experiment seurat_obj@misc slot","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/GetModuleTraitCorrelation.html","id":null,"dir":"Reference","previous_headings":"","what":"GetModuleTraitCorrelation — GetModuleTraitCorrelation","title":"GetModuleTraitCorrelation — GetModuleTraitCorrelation","text":"GetModuleTraitCorrelation","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/GetModuleTraitCorrelation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"GetModuleTraitCorrelation — GetModuleTraitCorrelation","text":"","code":"GetModuleTraitCorrelation(seurat_obj, wgcna_name = NULL)"},{"path":"https://smorabit.github.io/hdWGCNA/reference/GetModuleTraitCorrelation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"GetModuleTraitCorrelation — GetModuleTraitCorrelation","text":"seurat_obj Seurat object wgcna_name name hdWGCNA experiment seurat_obj@misc slot","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/GetModuleUMAP.html","id":null,"dir":"Reference","previous_headings":"","what":"GetModuleUMAP — GetModuleUMAP","title":"GetModuleUMAP — GetModuleUMAP","text":"GetModuleUMAP","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/GetModuleUMAP.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"GetModuleUMAP — GetModuleUMAP","text":"","code":"GetModuleUMAP(seurat_obj, wgcna_name = NULL)"},{"path":"https://smorabit.github.io/hdWGCNA/reference/GetModuleUMAP.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"GetModuleUMAP — GetModuleUMAP","text":"seurat_obj Seurat object wgcna_name name hdWGCNA experiment seurat_obj@misc slot","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/GetModules.html","id":null,"dir":"Reference","previous_headings":"","what":"GetModules — GetModules","title":"GetModules — GetModules","text":"GetModules","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/GetModules.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"GetModules — GetModules","text":"","code":"GetModules(seurat_obj, wgcna_name = NULL)"},{"path":"https://smorabit.github.io/hdWGCNA/reference/GetModules.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"GetModules — GetModules","text":"seurat_obj Seurat object wgcna_name name hdWGCNA experiment seurat_obj@misc slot","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/GetMotifMatrix.html","id":null,"dir":"Reference","previous_headings":"","what":"GetMotifMatrix — GetMotifMatrix","title":"GetMotifMatrix — GetMotifMatrix","text":"GetMotifMatrix","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/GetMotifMatrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"GetMotifMatrix — GetMotifMatrix","text":"","code":"GetMotifMatrix(seurat_obj)"},{"path":"https://smorabit.github.io/hdWGCNA/reference/GetMotifMatrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"GetMotifMatrix — GetMotifMatrix","text":"seurat_obj Seurat object","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/GetMotifMatrix.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"GetMotifMatrix — GetMotifMatrix","text":"","code":"GetMotifMatrix #> function (seurat_obj)  #> { #>     seurat_obj@misc$motifs$tf_match_matrix #> } #> <bytecode: 0x7f96135f8ee8> #> <environment: namespace:hdWGCNA>"},{"path":"https://smorabit.github.io/hdWGCNA/reference/GetMotifOverlap.html","id":null,"dir":"Reference","previous_headings":"","what":"GetMotifOverlap — GetMotifOverlap","title":"GetMotifOverlap — GetMotifOverlap","text":"GetMotifOverlap","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/GetMotifOverlap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"GetMotifOverlap — GetMotifOverlap","text":"","code":"GetMotifOverlap(seurat_obj, wgcna_name = NULL)"},{"path":"https://smorabit.github.io/hdWGCNA/reference/GetMotifOverlap.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"GetMotifOverlap — GetMotifOverlap","text":"seurat_obj Seurat object wgcna_name name hdWGCNA experiment seurat_obj@misc slot","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/GetMotifScores.html","id":null,"dir":"Reference","previous_headings":"","what":"GetMotifScores — GetMotifScores","title":"GetMotifScores — GetMotifScores","text":"GetMotifScores","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/GetMotifScores.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"GetMotifScores — GetMotifScores","text":"","code":"GetMotifScores(seurat_obj, wgcna_name = NULL)"},{"path":"https://smorabit.github.io/hdWGCNA/reference/GetMotifScores.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"GetMotifScores — GetMotifScores","text":"seurat_obj Seurat object wgcna_name name hdWGCNA experiment seurat_obj@misc slot","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/GetMotifTargets.html","id":null,"dir":"Reference","previous_headings":"","what":"GetMotifTargets — GetMotifTargets","title":"GetMotifTargets — GetMotifTargets","text":"GetMotifTargets","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/GetMotifTargets.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"GetMotifTargets — GetMotifTargets","text":"","code":"GetMotifTargets(seurat_obj)"},{"path":"https://smorabit.github.io/hdWGCNA/reference/GetMotifTargets.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"GetMotifTargets — GetMotifTargets","text":"seurat_obj Seurat object","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/GetMotifTargets.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"GetMotifTargets — GetMotifTargets","text":"","code":"GetMotifTargets #> function (seurat_obj)  #> { #>     seurat_obj@misc$motifs$motif_targets #> } #> <bytecode: 0x7f962828f678> #> <environment: namespace:hdWGCNA>"},{"path":"https://smorabit.github.io/hdWGCNA/reference/GetMotifs.html","id":null,"dir":"Reference","previous_headings":"","what":"GetMotifs — GetMotifs","title":"GetMotifs — GetMotifs","text":"GetMotifs","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/GetMotifs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"GetMotifs — GetMotifs","text":"","code":"GetMotifs(seurat_obj)"},{"path":"https://smorabit.github.io/hdWGCNA/reference/GetMotifs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"GetMotifs — GetMotifs","text":"seurat_obj Seurat object","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/GetMotifs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"GetMotifs — GetMotifs","text":"","code":"GetMotifs #> function (seurat_obj)  #> { #>     seurat_obj@misc$motifs$motif_df #> } #> <bytecode: 0x7f963f00d008> #> <environment: namespace:hdWGCNA>"},{"path":"https://smorabit.github.io/hdWGCNA/reference/GetMultiExpr.html","id":null,"dir":"Reference","previous_headings":"","what":"GetMultiExpr — GetMultiExpr","title":"GetMultiExpr — GetMultiExpr","text":"function gets expression matrix metacell object.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/GetMultiExpr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"GetMultiExpr — GetMultiExpr","text":"","code":"GetMultiExpr(seurat_obj, wgcna_name = NULL)"},{"path":"https://smorabit.github.io/hdWGCNA/reference/GetMultiExpr.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"GetMultiExpr — GetMultiExpr","text":"seurat_obj Seurat object","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/GetNetworkData.html","id":null,"dir":"Reference","previous_headings":"","what":"GetNetworkData — GetNetworkData","title":"GetNetworkData — GetNetworkData","text":"GetNetworkData","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/GetNetworkData.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"GetNetworkData — GetNetworkData","text":"","code":"GetNetworkData(seurat_obj, wgcna_name = NULL)"},{"path":"https://smorabit.github.io/hdWGCNA/reference/GetNetworkData.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"GetNetworkData — GetNetworkData","text":"seurat_obj Seurat object wgcna_name name hdWGCNA experiment seurat_obj@misc slot","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/GetPFMList.html","id":null,"dir":"Reference","previous_headings":"","what":"GetPFMList — GetPFMList","title":"GetPFMList — GetPFMList","text":"GetPFMList","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/GetPFMList.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"GetPFMList — GetPFMList","text":"","code":"GetPFMList(seurat_obj)"},{"path":"https://smorabit.github.io/hdWGCNA/reference/GetPFMList.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"GetPFMList — GetPFMList","text":"seurat_obj Seurat object","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/GetPFMList.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"GetPFMList — GetPFMList","text":"","code":"GetPFMList #> function (seurat_obj)  #> { #>     seurat_obj@misc$motifs$pfm_list #> } #> <bytecode: 0x7f962fad6ef0> #> <environment: namespace:hdWGCNA>"},{"path":"https://smorabit.github.io/hdWGCNA/reference/GetPowerTable.html","id":null,"dir":"Reference","previous_headings":"","what":"GetPowerTable — GetPowerTable","title":"GetPowerTable — GetPowerTable","text":"GetPowerTable","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/GetPowerTable.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"GetPowerTable — GetPowerTable","text":"","code":"GetPowerTable(seurat_obj, wgcna_name = NULL)"},{"path":"https://smorabit.github.io/hdWGCNA/reference/GetPowerTable.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"GetPowerTable — GetPowerTable","text":"seurat_obj Seurat object wgcna_name name hdWGCNA experiment seurat_obj@misc slot","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/GetRegulonScores.html","id":null,"dir":"Reference","previous_headings":"","what":"GetRegulonScores — GetRegulonScores","title":"GetRegulonScores — GetRegulonScores","text":"GetRegulonScores","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/GetRegulonScores.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"GetRegulonScores — GetRegulonScores","text":"","code":"GetRegulonScores(seurat_obj, target_type, wgcna_name = NULL)"},{"path":"https://smorabit.github.io/hdWGCNA/reference/GetRegulonScores.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"GetRegulonScores — GetRegulonScores","text":"seurat_obj Seurat object target_type dataframe storing TF regulon scores wgcna_name name hdWGCNA experiment seurat_obj@misc slot","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/GetTFEval.html","id":null,"dir":"Reference","previous_headings":"","what":"GetTFEval — GetTFEval","title":"GetTFEval — GetTFEval","text":"GetTFEval","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/GetTFEval.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"GetTFEval — GetTFEval","text":"","code":"GetTFEval(seurat_obj, wgcna_name = NULL)"},{"path":"https://smorabit.github.io/hdWGCNA/reference/GetTFEval.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"GetTFEval — GetTFEval","text":"seurat_obj Seurat object wgcna_name name hdWGCNA experiment seurat_obj@misc slot","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/GetTFNetwork.html","id":null,"dir":"Reference","previous_headings":"","what":"GetTFNetwork — GetTFNetwork","title":"GetTFNetwork — GetTFNetwork","text":"GetTFNetwork","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/GetTFNetwork.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"GetTFNetwork — GetTFNetwork","text":"","code":"GetTFNetwork(seurat_obj, wgcna_name = NULL)"},{"path":"https://smorabit.github.io/hdWGCNA/reference/GetTFNetwork.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"GetTFNetwork — GetTFNetwork","text":"seurat_obj Seurat object wgcna_name name hdWGCNA experiment seurat_obj@misc slot","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/GetTFRegulons.html","id":null,"dir":"Reference","previous_headings":"","what":"GetTFRegulons — GetTFRegulons","title":"GetTFRegulons — GetTFRegulons","text":"GetTFRegulons","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/GetTFRegulons.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"GetTFRegulons — GetTFRegulons","text":"","code":"GetTFRegulons(seurat_obj, wgcna_name = NULL)"},{"path":"https://smorabit.github.io/hdWGCNA/reference/GetTFRegulons.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"GetTFRegulons — GetTFRegulons","text":"seurat_obj Seurat object wgcna_name name hdWGCNA experiment seurat_obj@misc slot","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/GetTFTargetGenes.html","id":null,"dir":"Reference","previous_headings":"","what":"GetTFTargetGenes — GetTFTargetGenes","title":"GetTFTargetGenes — GetTFTargetGenes","text":"Retrieve target genes set transcription factors (TFs) Seurat object, based either regulons full TF network. function allows exploration direct targets extending network adding target genes TFs downstream network.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/GetTFTargetGenes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"GetTFTargetGenes — GetTFTargetGenes","text":"","code":"GetTFTargetGenes(   seurat_obj,   selected_tfs,   depth = 1,   target_type = \"both\",   use_regulons = TRUE,   wgcna_name = NULL )"},{"path":"https://smorabit.github.io/hdWGCNA/reference/GetTFTargetGenes.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"GetTFTargetGenes — GetTFTargetGenes","text":"seurat_obj Seurat object containing TF network regulon information. must include WGCNA results @misc slot. selected_tfs list transcription factors (TFs) use starting point network exploration. depth Integer value specifying number layers extend TF network selected TFs. example, depth=2, target genes selected_tfs shown, additional target genes shown TFs targets original selected_tfs. target_type type target genes include output. Options \"positive\" (genes expression positively correlated TFs), \"negative\" (genes expression negatively correlated TFs), \"\" (default, includes targets). use_regulons Logical flag indicating whether use regulons (default = TRUE) entire TF network target gene discovery. wgcna_name Character string specifying name WGCNA experiment. stored @misc slot Seurat object.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/GetTFTargetGenes.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"GetTFTargetGenes — GetTFTargetGenes","text":"data frame containing TF-target interactions specified depth level, additional information regulatory score, correlation, depth.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/GetTFTargetGenes.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"GetTFTargetGenes — GetTFTargetGenes","text":"function retrieves direct extended targets set TFs based regulatory network stored Seurat object. depth parameter controls many layers TF-target interactions explore, target_type parameter allows filtering based correlation direction. use_regulons flag specifies whether use regulon data, may provide confident set interactions, full TF network.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/GetTOM.html","id":null,"dir":"Reference","previous_headings":"","what":"GetTOM — GetTOM","title":"GetTOM — GetTOM","text":"GetTOM","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/GetTOM.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"GetTOM — GetTOM","text":"","code":"GetTOM(seurat_obj, wgcna_name = NULL)"},{"path":"https://smorabit.github.io/hdWGCNA/reference/GetTOM.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"GetTOM — GetTOM","text":"seurat_obj Seurat object wgcna_name name hdWGCNA experiment seurat_obj@misc slot","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/GetWGCNAGenes.html","id":null,"dir":"Reference","previous_headings":"","what":"GetWGCNAGenes — GetWGCNAGenes","title":"GetWGCNAGenes — GetWGCNAGenes","text":"GetWGCNAGenes","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/GetWGCNAGenes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"GetWGCNAGenes — GetWGCNAGenes","text":"","code":"GetWGCNAGenes(seurat_obj, wgcna_name = NULL)"},{"path":"https://smorabit.github.io/hdWGCNA/reference/GetWGCNAGenes.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"GetWGCNAGenes — GetWGCNAGenes","text":"seurat_obj Seurat object wgcna_name name hdWGCNA experiment seurat_obj@misc slot","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/GetWGCNAParams.html","id":null,"dir":"Reference","previous_headings":"","what":"GetWGCNAParams — GetWGCNAParams","title":"GetWGCNAParams — GetWGCNAParams","text":"GetWGCNAParams","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/GetWGCNAParams.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"GetWGCNAParams — GetWGCNAParams","text":"","code":"GetWGCNAParams(seurat_obj, wgcna_name = NULL)"},{"path":"https://smorabit.github.io/hdWGCNA/reference/GetWGCNAParams.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"GetWGCNAParams — GetWGCNAParams","text":"seurat_obj Seurat object wgcna_name name hdWGCNA experiment seurat_obj@misc slot","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/HubGeneNetworkPlot.html","id":null,"dir":"Reference","previous_headings":"","what":"HubGeneNetworkPlot — HubGeneNetworkPlot","title":"HubGeneNetworkPlot — HubGeneNetworkPlot","text":"Construct unified network plot comprising hub genes multiple modules.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/HubGeneNetworkPlot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"HubGeneNetworkPlot — HubGeneNetworkPlot","text":"","code":"HubGeneNetworkPlot(   seurat_obj,   mods = \"all\",   n_hubs = 6,   n_other = 3,   sample_edges = TRUE,   edge_prop = 0.5,   return_graph = FALSE,   edge.alpha = 0.25,   vertex.label.cex = 0.5,   hub.vertex.size = 4,   other.vertex.size = 1,   wgcna_name = NULL,   ... )"},{"path":"https://smorabit.github.io/hdWGCNA/reference/HubGeneNetworkPlot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"HubGeneNetworkPlot — HubGeneNetworkPlot","text":"seurat_obj Seurat object mods Names modules plot. mods = \"\", modules plotted. n_hubs number hub genes plot module. n_other number non-hub genes sample module edge_prop proportion edges graph sample. return_graph logical determining whether return graph (TRUE) plot graph (FALSE) edge.alpha Scaling factor edge opacity vertex.label.cex font size gene labels hub.vertex.size size hub gene nodes .vertex.size size gene nodes wgcna_name name hdWGCNA experiment seurat_obj@misc slot","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/HubGeneNetworkPlot.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"HubGeneNetworkPlot — HubGeneNetworkPlot","text":"","code":"HubGeneNetworkPlot #> function (seurat_obj, mods = \"all\", n_hubs = 6, n_other = 3,  #>     sample_edges = TRUE, edge_prop = 0.5, return_graph = FALSE,  #>     edge.alpha = 0.25, vertex.label.cex = 0.5, hub.vertex.size = 4,  #>     other.vertex.size = 1, wgcna_name = NULL, ...)  #> { #>     if (is.null(wgcna_name)) { #>         wgcna_name <- seurat_obj@misc$active_wgcna #>     } #>     MEs <- GetMEs(seurat_obj, wgcna_name) #>     modules <- GetModules(seurat_obj, wgcna_name) #>     if (all(\"all\" %in% mods)) { #>         mods <- levels(modules$module) #>         mods <- mods[mods != \"grey\"] #>     } #>     else { #>         if (!all(mods %in% unique(as.character(modules$module)))) { #>             stop(paste0(\"Some selected modules are not found in wgcna_name: \",  #>                 wgcna_name)) #>         } #>         modules <- modules %>% subset(module %in% mods) #>     } #>     TOM <- GetTOM(seurat_obj, wgcna_name) #>     hub_list <- lapply(mods, function(cur_mod) { #>         cur <- subset(modules, module == cur_mod) #>         cur[, c(\"gene_name\", paste0(\"kME_\", cur_mod))] %>% top_n(n_hubs) %>%  #>             .$gene_name #>     }) #>     names(hub_list) <- mods #>     other_genes <- modules %>% subset(!(gene_name %in% unlist(hub_list))) %>%  #>         group_by(module) %>% sample_n(n_other, replace = TRUE) %>%  #>         .$gene_name %>% unique #>     selected_genes <- c(unlist(hub_list), other_genes) #>     selected_modules <- modules %>% subset(gene_name %in% selected_genes) #>     subset_TOM <- TOM[selected_genes, selected_genes] #>     selected_modules$geneset <- ifelse(selected_modules$gene_name %in%  #>         other_genes, \"other\", \"hub\") #>     selected_modules$size <- ifelse(selected_modules$geneset ==  #>         \"hub\", hub.vertex.size, other.vertex.size) #>     selected_modules$label <- ifelse(selected_modules$geneset ==  #>         \"hub\", as.character(selected_modules$gene_name), \"\") #>     selected_modules$fontcolor <- ifelse(selected_modules$color ==  #>         \"black\", \"gray50\", \"black\") #>     edge_cutoff <- min(sapply(1:nrow(subset_TOM), function(i) { #>         max(subset_TOM[i, ]) #>     })) #>     edge_df <- reshape2::melt(subset_TOM) %>% subset(value >=  #>         edge_cutoff) #>     edge_df$color <- future.apply::future_sapply(1:nrow(edge_df),  #>         function(i) { #>             gene1 = as.character(edge_df[i, \"Var1\"]) #>             gene2 = as.character(edge_df[i, \"Var2\"]) #>             col1 <- modules %>% subset(gene_name == gene1) %>%  #>                 .$color #>             col2 <- modules %>% subset(gene_name == gene2) %>%  #>                 .$color #>             if (col1 == col2) { #>                 col = col1 #>             } #>             else { #>                 col = \"grey90\" #>             } #>             col #>         }) #>     groups <- unique(edge_df$color) #>     print(groups) #>     if (sample_edges) { #>         temp <- do.call(rbind, lapply(groups, function(cur_group) { #>             cur_df <- edge_df %>% subset(color == cur_group) #>             n_edges <- nrow(cur_df) #>             cur_sample <- sample(1:n_edges, round(n_edges * edge_prop)) #>             cur_df[cur_sample, ] #>         })) #>     } #>     else { #>         temp <- do.call(rbind, lapply(groups, function(cur_group) { #>             cur_df <- edge_df %>% subset(color == cur_group) #>             n_edges <- nrow(cur_df) #>             cur_df %>% dplyr::top_n(round(n_edges * edge_prop),  #>                 wt = value) #>         })) #>     } #>     edge_df <- temp #>     edge_df <- edge_df %>% group_by(color) %>% mutate(value = scale01(value)) #>     edge_df$color <- sapply(1:nrow(edge_df), function(i) { #>         a = edge_df$value[i] #>         alpha(edge_df$color[i], alpha = a) #>     }) #>     g <- igraph::graph_from_data_frame(edge_df, directed = FALSE,  #>         vertices = selected_modules) #>     l <- igraph::layout_with_fr(g, ...) #>     if (return_graph) { #>         return(g) #>     } #>     plot(g, layout = l, edge.color = adjustcolor(igraph::E(g)$color,  #>         alpha.f = edge.alpha), vertex.size = igraph::V(g)$size,  #>         edge.curved = 0, edge.width = 0.5, vertex.color = igraph::V(g)$color,  #>         vertex.frame.color = igraph::V(g)$color, vertex.label = igraph::V(g)$label,  #>         vertex.label.family = \"Helvetica\", vertex.label.font = 3,  #>         vertex.label.color = igraph::V(g)$fontcolor, vertex.label.cex = vertex.label.cex,  #>         ...) #> } #> <bytecode: 0x7f9617afda08> #> <environment: namespace:hdWGCNA>"},{"path":"https://smorabit.github.io/hdWGCNA/reference/MetacellsByGroups.html","id":null,"dir":"Reference","previous_headings":"","what":"MetacellsByGroups — MetacellsByGroups","title":"MetacellsByGroups — MetacellsByGroups","text":"function takes Seurat object constructs averaged 'metacells' based neighboring cells provided groupings, cluster cell type.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/MetacellsByGroups.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"MetacellsByGroups — MetacellsByGroups","text":"","code":"MetacellsByGroups(   seurat_obj,   group.by = c(\"seurat_clusters\"),   ident.group = \"seurat_clusters\",   k = 25,   reduction = \"pca\",   dims = NULL,   assay = NULL,   slot = \"counts\",   layer = \"counts\",   mode = \"average\",   cells.use = NULL,   min_cells = 100,   max_shared = 15,   target_metacells = 1000,   max_iter = 5000,   verbose = FALSE,   wgcna_name = NULL )"},{"path":"https://smorabit.github.io/hdWGCNA/reference/MetacellsByGroups.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"MetacellsByGroups — MetacellsByGroups","text":"seurat_obj Seurat object group.character vector Seurat metadata column names representing groups metacells computed. k Number nearest neighbors aggregate. Default = 50 reduction dimensionality reduction stored Seurat object. Default = 'pca' dims vector represnting dimensions reduction use. Either specify names dimensions indices. Default = NULL include dims. assay Assay extract data aggregation. Default = 'RNA' slot Slot extract data aggregation. Default = 'counts'. Slot used Seurat v4 instead layer. layer Layer extract data aggregation. Default = 'counts'. Layer used Seurat v5 instead slot. mode determines make gene expression profiles metacells constituent single cells. Options \"average\" \"sum\". min_cells minimum number cells particular grouping construct metacells max_shared maximum number cells shared across two metacells target_metacells maximum target number metacells construct max_iter maximum number iterations metacells bootstrapping loop verbose logical indicating whether print additional information wgcna_name name WGCNA experiment name string appended resulting metalcells. Default = 'agg'","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/MetacellsByGroups.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"MetacellsByGroups — MetacellsByGroups","text":"seurat_obj metacell seurat_obj stored specified WGCNA experiment","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/MetacellsByGroups.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"MetacellsByGroups — MetacellsByGroups","text":"MetacellsByGroups merges transcriptomically similar cells \"metacells\". Given dimensionally-reduced representation input dataset, algorithm first uses KNN identify similar cells. bootstrapped sampling procedure used group together similar cells convergence reached. Importantly, procedure done context-specific manner based provided group.parameters. Typically means metacells constructed separately biological replicate, cell type cell state, disease condition, etc. metacell representation considerably less sparse original single-cell dataset, preferable co-expression network analysis othter analyses rely correlations.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/MetaspotsByGroups.html","id":null,"dir":"Reference","previous_headings":"","what":"MetaspotsByGroups — MetaspotsByGroups","title":"MetaspotsByGroups — MetaspotsByGroups","text":"Computes metaspots given Seurat object containing spatial transcriptomics data.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/MetaspotsByGroups.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"MetaspotsByGroups — MetaspotsByGroups","text":"","code":"MetaspotsByGroups(   seurat_obj,   group.by = c(\"seurat_clusters\"),   ident.group = \"seurat_clusters\",   assay = \"Spatial\",   slot = \"counts\",   layer = \"counts\",   mode = \"sum\",   min_spots = 50,   wgcna_name = NULL )"},{"path":"https://smorabit.github.io/hdWGCNA/reference/MetaspotsByGroups.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"MetaspotsByGroups — MetaspotsByGroups","text":"group.character vector Seurat metadata column names representing groups metacells computed. assay Assay extract data aggregation. Default = 'Spatial' slot Slot extract data aggregation. Default = 'counts' layer Layer extract data aggregation. Default = 'counts'. Layer used Seurat v5 instead slot. mode determines make gene expression profiles metacells constituent single cells. Options \"average\" \"sum\". min_spots minimum number spots particular grouping construct metaspots wgcna_name name WGCNA experiment cur_seurat Seurat object","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/ModuleConnectivity.html","id":null,"dir":"Reference","previous_headings":"","what":"ModuleConnectivity — ModuleConnectivity","title":"ModuleConnectivity — ModuleConnectivity","text":"Computes eigengene-based connectivity (kME) based module eigengenes feature expression selected cell populations / spatial regions.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/ModuleConnectivity.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"ModuleConnectivity — ModuleConnectivity","text":"","code":"ModuleConnectivity(   seurat_obj,   group.by = NULL,   group_name = NULL,   corFnc = \"bicor\",   corOptions = \"use='p'\",   harmonized = TRUE,   assay = NULL,   slot = \"data\",   layer = \"data\",   sparse = TRUE,   reassign_modules = TRUE,   TOM_use = NULL,   wgcna_name = NULL,   ... )"},{"path":"https://smorabit.github.io/hdWGCNA/reference/ModuleConnectivity.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"ModuleConnectivity — ModuleConnectivity","text":"seurat_obj Seurat object group.column seurat_obj@meta.data containing grouping info, ie clusters celltypes group_name name group(s) group.use kME calculation corFnc character string specifying function used calculate co-expression similarity. Defaults bicor. function returning values corOptions character string specifying additional arguments passed function given corFnc. Use \"use = 'p', method = 'spearman'\" obtain Spearman correlation. Use \"use = 'p'\" obtain Pearson correlation. harmonized logical determining whether use harmonized MEs kME calculation assay Assay seurat_obj containing expression information. slot Slot seurat_obj, default normalized 'data' slot. sparse logical indicating whether run correlation using sparse matrix. reassign_modules logical indicating whether reassign genes different co-expression modules kME value assigned module negative. TOM_use name hdWGCNA experiment contains TOM used compute intramodular degree gene. TOM found, calculation skipped. wgcna_name name hdWGCNA experiment seurat_obj@misc slot","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/ModuleConnectivity.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"ModuleConnectivity — ModuleConnectivity","text":"seurat_obj kMEs computed selected wgcna experiment","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/ModuleConnectivity.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"ModuleConnectivity — ModuleConnectivity","text":"ModuleConnectivity computes eigengene-based connectivity (kME) feature module. done correlating gene expression signal module eigengenes module. Features high kME values greater network connectivity within module, can identify module hub genes taking top genes module kME values. recommend using group.group_name parameters previously used SetDatExpr function, relevant cell populations / spatial regions considered computing kMEs. Depending parameters network analysis, sometimes feature negative kME module originally assigned. discrepancy arises since network construction done metacell/metaspot matrix kME calculation done cell/spot matrix. default, account reassigning features negative kMEs assigned module module highest kME feature.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/ModuleCorrNetwork.html","id":null,"dir":"Reference","previous_headings":"","what":"ModuleCorrNetworks — ModuleCorrNetwork","title":"ModuleCorrNetworks — ModuleCorrNetwork","text":"Plot Module Eigengene correlogram","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/ModuleCorrNetwork.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"ModuleCorrNetworks — ModuleCorrNetwork","text":"","code":"ModuleCorrNetwork(   seurat_obj,   cluster_col = NULL,   exclude_grey = TRUE,   features = \"hMEs\",   reduction = \"umap\",   cor_cutoff = 0.2,   label_vertices = FALSE,   edge_scale = 5,   vertex_size = 15,   niter = 100,   vertex_frame = FALSE,   wgcna_name = NULL )"},{"path":"https://smorabit.github.io/hdWGCNA/reference/ModuleCorrNetwork.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"ModuleCorrNetworks — ModuleCorrNetwork","text":"seurat_obj Seurat object","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/ModuleCorrNetwork.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"ModuleCorrNetworks — ModuleCorrNetwork","text":"","code":"ModuleCorrNetwork #> function (seurat_obj, cluster_col = NULL, exclude_grey = TRUE,  #>     features = \"hMEs\", reduction = \"umap\", cor_cutoff = 0.2,  #>     label_vertices = FALSE, edge_scale = 5, vertex_size = 15,  #>     niter = 100, vertex_frame = FALSE, wgcna_name = NULL)  #> { #>     if (is.null(wgcna_name)) { #>         wgcna_name <- seurat_obj@misc$active_wgcna #>     } #>     if (features == \"hMEs\") { #>         MEs <- GetMEs(seurat_obj, TRUE, wgcna_name) #>     } #>     else if (features == \"MEs\") { #>         MEs <- GetMEs(seurat_obj, FALSE, wgcna_name) #>     } #>     else if (features == \"scores\") { #>         MEs <- GetModuleScores(seurat_obj, wgcna_name) #>     } #>     else if (features == \"average\") { #>         MEs <- GetAvgModuleExpr(seurat_obj, wgcna_name) #>         restrict_range <- FALSE #>     } #>     else (stop(\"Invalid feature selection. Valid choices: hMEs, MEs, scores, average\")) #>     modules <- GetModules(seurat_obj, wgcna_name) #>     if (exclude_grey) { #>         MEs <- MEs[, colnames(MEs) != \"grey\"] #>         modules <- modules %>% subset(color != \"grey\") #>     } #>     mods <- colnames(MEs) #>     if (is.null(cluster_col)) { #>         clusters <- Idents(seurat_obj) #>     } #>     else { #>         clusters <- droplevels(seurat_obj@meta.data[[cluster_col]]) #>     } #>     MEs$cluster <- clusters #>     cluster_ME_av <- do.call(rbind, lapply(split(MEs, MEs$cluster),  #>         function(x) { #>             colMeans(x[, mods]) #>         })) %>% as.data.frame #>     top_clusters <- sapply(mods, function(x) { #>         rownames(cluster_ME_av[cluster_ME_av[, x] == max(cluster_ME_av[,  #>             x]), ]) #>     }) #>     red_df <- as.data.frame(seurat_obj@reductions[[reduction]]@cell.embeddings) #>     red_df$cluster <- clusters #>     red_av <- do.call(rbind, lapply(split(red_df, red_df$cluster),  #>         function(x) { #>             colMeans(x[, 1:2]) #>         })) %>% as.data.frame #>     cor_mat <- Hmisc::rcorr(as.matrix(MEs[, 1:ncol(MEs) - 1]))$r #>     cor_mat[lower.tri(cor_mat)] <- NA #>     cor_df <- reshape2::melt(cor_mat) %>% na.omit #>     cor_df <- cor_df %>% subset(!(Var1 == Var2)) #>     cor_df <- cor_df %>% subset(abs(value) >= cor_cutoff) #>     v_df <- data.frame(name = mods, cluster = as.character(top_clusters)) #>     unique_mods <- dplyr::distinct(modules[, c(\"module\", \"color\")]) #>     rownames(unique_mods) <- unique_mods$module #>     v_df$color <- unique_mods[v_df$name, \"color\"] #>     v_df$x <- red_av[v_df$cluster, 1] #>     v_df$y <- red_av[v_df$cluster, 2] #>     g <- igraph::graph_from_data_frame(cor_df, directed = FALSE,  #>         vertices = v_df) #>     e <- get.edgelist(g, name = FALSE) #>     l <- qgraph::qgraph.layout.fruchtermanreingold(e, vcount = vcount(g),  #>         weights = igraph::E(g)$value, repulse.rad = (vcount(g)),  #>         niter = niter, ) #>     plot_df <- rbind(cor_df, data.frame(Var1 = c(\"x\", \"y\"), Var2 = c(\"y\",  #>         \"x\"), value = c(-1, 1))) #>     temp <- ggplot(plot_df, aes(x = value, y = value, color = value)) +  #>         geom_point() + scale_color_gradient2(high = \"darkorchid1\",  #>         mid = \"white\", low = \"seagreen\", midpoint = 0) #>     temp <- ggplot_build(temp) #>     igraph::E(g)$color <- temp$data[[1]]$colour[1:nrow(cor_df)] #>     if (label_vertices) { #>         labels <- igraph::V(g)$name #>     } #>     else { #>         labels <- NA #>     } #>     if (vertex_frame) { #>         frame_color <- \"black\" #>     } #>     else { #>         frame_color <- igraph::V(g)$color #>     } #>     plot(g, layout = l, edge.color = igraph::E(g)$color, edge.curved = 0,  #>         edge.width = abs(igraph::E(g)$value) * edge_scale, vertex.color = igraph::V(g)$color,  #>         vertex.frame.color = frame_color, vertex.label = labels,  #>         vertex.label.family = \"Helvetica\", vertex.label.color = \"black\",  #>         vertex.label.cex = 0.5, vertex.size = vertex_size) #> } #> <bytecode: 0x7f962d49ad10> #> <environment: namespace:hdWGCNA>"},{"path":"https://smorabit.github.io/hdWGCNA/reference/ModuleCorrelogram.html","id":null,"dir":"Reference","previous_headings":"","what":"ModuleCorrelogram — ModuleCorrelogram","title":"ModuleCorrelogram — ModuleCorrelogram","text":"Plot Module Eigengene correlogram","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/ModuleCorrelogram.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"ModuleCorrelogram — ModuleCorrelogram","text":"","code":"ModuleCorrelogram(   seurat_obj,   MEs2 = NULL,   features = \"hMEs\",   order = \"original\",   method = \"ellipse\",   exclude_grey = TRUE,   type = \"upper\",   tl.col = \"black\",   tl.srt = 45,   sig.level = c(1e-04, 0.001, 0.01, 0.05),   pch.cex = 0.7,   col = NULL,   ncolors = 200,   wgcna_name = NULL,   wgcna_name2 = NULL,   ... )"},{"path":"https://smorabit.github.io/hdWGCNA/reference/ModuleCorrelogram.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"ModuleCorrelogram — ModuleCorrelogram","text":"seurat_obj Seurat object features plot? Can select hMEs, MEs, scores, average","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/ModuleCorrelogram.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"ModuleCorrelogram — ModuleCorrelogram","text":"","code":"MECorrelogram #> Error in eval(expr, envir, enclos): object 'MECorrelogram' not found"},{"path":"https://smorabit.github.io/hdWGCNA/reference/ModuleEigengenes.html","id":null,"dir":"Reference","previous_headings":"","what":"ModuleEigengenes — ModuleEigengenes","title":"ModuleEigengenes — ModuleEigengenes","text":"Computes module eigengenes co-expression modules","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/ModuleEigengenes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"ModuleEigengenes — ModuleEigengenes","text":"","code":"ModuleEigengenes(   seurat_obj,   group.by.vars = NULL,   modules = NULL,   vars.to.regress = NULL,   scale.model.use = \"linear\",   verbose = TRUE,   assay = NULL,   pc_dim = 1,   wgcna_name = NULL,   ... )"},{"path":"https://smorabit.github.io/hdWGCNA/reference/ModuleEigengenes.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"ModuleEigengenes — ModuleEigengenes","text":"seurat_obj Seurat object group..vars groups harmonize modules table containing module / gene assignments, GetModules(seurat_obj). vars..regress character vector variables seurat_obj@meta.data regress running ScaleData scale.model.use model scale data running ScaleData choices \"linear\", \"poisson\", \"negbinom\" verbose logical indicating whether print messages assay Assay seurat_obj compute module eigengenes. Default DefaultAssay(seurat_obj) pc_dim PC use module eigengene? Default 1. wgcna_name name WGCNA experiment","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/ModuleEigengenes.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"ModuleEigengenes — ModuleEigengenes","text":"seurat_obj module eigengenes computed selected wgcna experiment","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/ModuleEigengenes.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"ModuleEigengenes — ModuleEigengenes","text":"ModuleEigengenes summarizes gene expression signatures entire co-expression modules. done performing singular value decomposition (SVD) subset scaled expression matrix containing features assigned module. module eigengene (), defined first dimension SVD matrix, retains variation, use vector summary gene expression whole module. module gene expression matrix first scaled using Seurat ScaleData function. user can optionally adjust covariates interest step using vars..regress parameter. Additionally, module eigengenes can adjusted technical biases sequencing batch, dataset origin, factors using Harmony algorithm group..vars parameter.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/ModuleExprScore.html","id":null,"dir":"Reference","previous_headings":"","what":"ModuleExprScore — ModuleExprScore","title":"ModuleExprScore — ModuleExprScore","text":"Computes module score co-expression module using Seurat AddModuleScore UCell.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/ModuleExprScore.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"ModuleExprScore — ModuleExprScore","text":"","code":"ModuleExprScore(   seurat_obj,   n_genes = 25,   method = \"Seurat\",   wgcna_name = NULL,   ... )"},{"path":"https://smorabit.github.io/hdWGCNA/reference/ModuleExprScore.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"ModuleExprScore — ModuleExprScore","text":"seurat_obj Seurat object n_genes number genes use module, ranked kME. Setting n_genes = '' uses genes module method selected method module scoring, valid choices \"Seurat\" \"UCell\" wgcna_name name hdWGCNA experiment seurat_obj@misc slot","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/ModuleExprScore.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"ModuleExprScore — ModuleExprScore","text":"seurat_obj module scores computed selected wgcna experiment","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/ModuleExprScore.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"ModuleExprScore — ModuleExprScore","text":"ModuleExprScore provides alternative function ModuleEigengenes summarizing expression level module. user can choose Seurat AddModuleScore UCell using method parameter.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/ModuleFeaturePlot.html","id":null,"dir":"Reference","previous_headings":"","what":"ModuleFeaturePlot — ModuleFeaturePlot","title":"ModuleFeaturePlot — ModuleFeaturePlot","text":"Plot module eigengenes FeaturePlot","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/ModuleFeaturePlot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"ModuleFeaturePlot — ModuleFeaturePlot","text":"","code":"ModuleFeaturePlot(   seurat_obj,   module_names = NULL,   wgcna_name = NULL,   reduction = \"umap\",   features = \"hMEs\",   order_points = TRUE,   restrict_range = TRUE,   point_size = 0.5,   alpha = 1,   label_legend = FALSE,   ucell = FALSE,   raster = FALSE,   raster_dpi = 500,   raster_scale = 1,   plot_ratio = 1,   title = TRUE )"},{"path":"https://smorabit.github.io/hdWGCNA/reference/ModuleFeaturePlot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"ModuleFeaturePlot — ModuleFeaturePlot","text":"seurat_obj Seurat object features plot? Can select hMEs, MEs, scores, average order TRUE, FALSE, \"shuffle\" valid options","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/ModuleFeaturePlot.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"ModuleFeaturePlot — ModuleFeaturePlot","text":"","code":"ModuleFeaturePlot #> function (seurat_obj, module_names = NULL, wgcna_name = NULL,  #>     reduction = \"umap\", features = \"hMEs\", order_points = TRUE,  #>     restrict_range = TRUE, point_size = 0.5, alpha = 1, label_legend = FALSE,  #>     ucell = FALSE, raster = FALSE, raster_dpi = 500, raster_scale = 1,  #>     plot_ratio = 1, title = TRUE)  #> { #>     if (is.null(wgcna_name)) { #>         wgcna_name <- seurat_obj@misc$active_wgcna #>     } #>     if (features == \"hMEs\") { #>         MEs <- GetMEs(seurat_obj, TRUE, wgcna_name) #>     } #>     else if (features == \"MEs\") { #>         MEs <- GetMEs(seurat_obj, FALSE, wgcna_name) #>     } #>     else if (features == \"scores\") { #>         MEs <- GetModuleScores(seurat_obj, wgcna_name) #>     } #>     else if (features == \"average\") { #>         MEs <- GetAvgModuleExpr(seurat_obj, wgcna_name) #>         restrict_range <- FALSE #>     } #>     else (stop(\"Invalid feature selection. Valid choices: hMEs, MEs, scores, average\")) #>     if (ucell) { #>         restrict_range <- FALSE #>     } #>     modules <- GetModules(seurat_obj, wgcna_name) #>     if (is.null(module_names)) { #>         module_names <- levels(modules$module) #>         module_names <- module_names[module_names != \"grey\"] #>     } #>     umap <- seurat_obj@reductions[[reduction]]@cell.embeddings #>     x_name <- colnames(umap)[1] #>     y_name <- colnames(umap)[2] #>     plot_df <- cbind(umap, MEs) %>% as.data.frame() #>     plot_list <- list() #>     for (cur_mod in module_names) { #>         print(cur_mod) #>         cur_color <- modules %>% subset(module == cur_mod) %>%  #>             .$color %>% unique #>         plot_range <- plot_df[, cur_mod] %>% range #>         if (restrict_range) { #>             if (abs(plot_range[1]) > abs(plot_range[2])) { #>                 plot_range[1] <- -1 * plot_range[2] #>             } #>             else { #>                 plot_range[2] <- -1 * plot_range[1] #>             } #>             plot_df[, cur_mod] <- ifelse(plot_df[, cur_mod] >  #>                 plot_range[2], plot_range[2], plot_df[, cur_mod]) #>             plot_df[, cur_mod] <- ifelse(plot_df[, cur_mod] <  #>                 plot_range[1], plot_range[1], plot_df[, cur_mod]) #>         } #>         cur_plot_df <- plot_df[, c(colnames(umap), cur_mod)] #>         colnames(cur_plot_df)[3] <- \"val\" #>         if (order_points == TRUE) { #>             cur_plot_df <- cur_plot_df %>% dplyr::arrange(val) #>         } #>         else if (order_points == \"shuffle\") { #>             cur_plot_df <- cur_plot_df[sample(nrow(cur_plot_df)),  #>                 ] #>         } #>         p <- cur_plot_df %>% ggplot(aes_string(x = x_name, y = y_name,  #>             color = \"val\")) #>         if (raster) { #>             p <- p + ggrastr::rasterise(geom_point(size = point_size,  #>                 alpha = alpha), dpi = raster_dpi, scale = raster_scale) #>         } #>         else { #>             p <- p + geom_point(size = point_size, alpha = alpha) #>         } #>         p <- p + umap_theme() + labs(color = \"\") #>         if (title) { #>             p <- p + ggtitle(cur_mod) #>         } #>         if (is.numeric(plot_ratio)) { #>             p <- p + coord_fixed(ratio = plot_ratio) #>         } #>         if (!ucell) { #>             p <- p + scale_color_gradient2(low = \"grey75\", mid = \"grey95\",  #>                 high = cur_color, breaks = plot_range, labels = c(\"-\",  #>                   \"+\"), guide = guide_colorbar(ticks = FALSE,  #>                   barwidth = 0.5, barheight = 4)) #>         } #>         else { #>             p <- p + scale_color_gradient(low = \"grey95\", high = cur_color,  #>                 breaks = plot_range, labels = c(\"0\", \"+\"), guide = guide_colorbar(ticks = FALSE,  #>                   barwidth = 0.5, barheight = 4)) #>         } #>         plot_list[[cur_mod]] <- p #>     } #>     if (length(plot_list) == 1) { #>         p <- plot_list[[1]] #>     } #>     else { #>         p <- plot_list #>     } #>     p #> } #> <bytecode: 0x7f9629c4e8e8> #> <environment: namespace:hdWGCNA>"},{"path":"https://smorabit.github.io/hdWGCNA/reference/ModuleNetworkPlot.html","id":null,"dir":"Reference","previous_headings":"","what":"ModuleNetworkPlot — ModuleNetworkPlot","title":"ModuleNetworkPlot — ModuleNetworkPlot","text":"Visualizes top hub genes selected modules circular network plot one inner circle one outer circle.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/ModuleNetworkPlot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"ModuleNetworkPlot — ModuleNetworkPlot","text":"","code":"ModuleNetworkPlot(   seurat_obj,   n_inner = 10,   n_outer = 15,   n_conns = 500,   mods = \"all\",   outdir = \"ModuleNetworks\",   wgcna_name = NULL,   plot_size = c(6, 6),   edge.alpha = 0.25,   edge.width = 1,   vertex.label.cex = 1,   vertex.size = 6,   ... )"},{"path":"https://smorabit.github.io/hdWGCNA/reference/ModuleNetworkPlot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"ModuleNetworkPlot — ModuleNetworkPlot","text":"seurat_obj Seurat object n_inner Number genes plot inner circle n_outer Number genes plot outer circle. n_conns Number gene-gene co-expression connections plot, sorted strongest connections. mods Names modules plot. mods = \"\", modules plotted. outdir directory plots stored. wgcna_name name hdWGCNA experiment seurat_obj@misc slot plot_size vector containing width height network plots. example: c(5,5) edge.alpha value 0 1 determining alpha (transparency) scaling factor network edges edge.width value determining width network edges vertex.label.cex vertex label font size vertex.size vertex size","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/ModulePreservation.html","id":null,"dir":"Reference","previous_headings":"","what":"ModulePreservation — ModulePreservation","title":"ModulePreservation — ModulePreservation","text":"Computes module preservation statistics query dataset given reference dataset","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/ModulePreservation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"ModulePreservation — ModulePreservation","text":"","code":"ModulePreservation(   seurat_obj,   seurat_ref,   name,   n_permutations = 500,   parallel = FALSE,   seed = 12345,   gene_mapping = NULL,   genome_ref_col = NULL,   genome_query_col = NULL,   return_raw = FALSE,   wgcna_name = NULL,   wgcna_name_ref = NULL,   ... )"},{"path":"https://smorabit.github.io/hdWGCNA/reference/ModulePreservation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"ModulePreservation — ModulePreservation","text":"seurat_obj Seurat object seurat_ref Seurat object serving reference module preservation analysis name name give module preservation analysis. n_permutations Number permutations module preservation test. parallel logical determining whether run preservation analysis parallel seed random seed permutation analysis. gene_mapping dataframe containing gene name mappings query reference dataset. One column gene name query dataset, anotehr column corresponding gene name reference dataset. genome_ref_col column name containing gene names reference dataset genome_query_col column name containing gene names query dataset return_raw TRUE, returns module preservation statistics, else returns seurat_obj stats added hdWGCNA experiment. wgcna_name name hdWGCNA experiment seurat_obj@misc slot wgcna_name_ref name hdWGCNA experiment seurat_ref@misc slot","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/ModulePreservation.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"ModulePreservation — ModulePreservation","text":"ModulePreservation performs statistical test assess preservation co-expression modules identified one dataset independent dataset. method originally described Langfelder et al. 2011 paper \"Network Module Preserved Reproducible?\". method can used assess biological differences networks, well technical differences / reproducibility across different batches.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/ModulePreservationNetRep.html","id":null,"dir":"Reference","previous_headings":"","what":"ModulePreservationNetRep — ModulePreservationNetRep","title":"ModulePreservationNetRep — ModulePreservationNetRep","text":"Computes module preservation statistics query dataset given reference dataset","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/ModulePreservationNetRep.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"ModulePreservationNetRep — ModulePreservationNetRep","text":"","code":"ModulePreservationNetRep(   seurat_query,   seurat_ref,   name,   n_permutations = 10000,   n_threads = 8,   gene_mapping = NULL,   genome_ref_col = NULL,   genome_query_col = NULL,   TOM_use = NULL,   wgcna_name = NULL,   wgcna_name_ref = NULL,   ... )"},{"path":"https://smorabit.github.io/hdWGCNA/reference/ModulePreservationNetRep.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"ModulePreservationNetRep — ModulePreservationNetRep","text":"seurat_query Seurat object seurat_ref Seurat object serving reference module preservation analysis name name give module preservation analysis. n_permutations Number permutations module preservation test. n_threads Number parallel threads use module preservation test gene_mapping dataframe containing gene name mappings query reference dataset. One column gene name query dataset, anotehr column corresponding gene name reference dataset. genome_ref_col column name containing gene names reference dataset genome_query_col column name containing gene names query dataset TOM_use name hdWGCNA experiment containing TOM used plotting wgcna_name name hdWGCNA experiment seurat_obj@misc slot wgcna_name_ref name hdWGCNA experiment seurat_ref@misc slot","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/ModulePreservationNetRep.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"ModulePreservationNetRep — ModulePreservationNetRep","text":"Seurat Object containing module preservation statistics NetRep.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/ModulePreservationNetRep.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"ModulePreservationNetRep — ModulePreservationNetRep","text":"ModulePreservationNetRep performs statistical test assess preservation co-expression modules identified one dataset independent dataset using NetRep implementation rather WGCNA implementation. method originally described Langfelder et al. 2011 paper \"Network Module Preserved Reproducible?\". NetRep implementation module preservation test described Ritchie et al. 2016 paper \"Scalable Permutation Approach Reveals Replication Preservation Patterns Networks Modules Large Datasets\" method can used assess biological differences networks, well technical differences / reproducibility across different batches. Note outputs ModulePreservation ModulePreservationNetRep identical. function requires separate installation NetRep package, directly included dependency hdWGCNA.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/ModuleRadarPlot.html","id":null,"dir":"Reference","previous_headings":"","what":"ModuleRadarPlot — ModuleRadarPlot","title":"ModuleRadarPlot — ModuleRadarPlot","text":"Plots expression level (module eigengene) co-expression module different groups radar plot.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/ModuleRadarPlot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"ModuleRadarPlot — ModuleRadarPlot","text":"","code":"ModuleRadarPlot(   seurat_obj,   group.by = NULL,   barcodes = NULL,   combine = TRUE,   ncol = 4,   wgcna_name = NULL,   fill = TRUE,   draw.points = FALSE,   ... )"},{"path":"https://smorabit.github.io/hdWGCNA/reference/ModuleRadarPlot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"ModuleRadarPlot — ModuleRadarPlot","text":"seurat_obj Seurat object group.column name selected comparison DMEs dataframe barcodes list barcodes colnames(seurat_obj) used subset data plotting. combine logical indicating whether combine plots using patchwork ncol number columns combined plot patchwork used wgcna_name name hdWGCNA experiment seurat_obj@misc slot ... additional parameters ggradar","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/ModuleRadarPlot.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"ModuleRadarPlot — ModuleRadarPlot","text":"ggplot object containing ModuleRadarPlot","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/ModuleRadarPlot.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"ModuleRadarPlot — ModuleRadarPlot","text":"ModuleRadarPlot visualizes expression level (module eigengene, ) co-expression module different groups radial coordinate system. module averaged group, scaled, plotted radially. resulting plots help us interpret cell groups (clusters, cell types, etc) expressing module.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/ModuleRegulatoryHeatmap.html","id":null,"dir":"Reference","previous_headings":"","what":"ModuleRegulatoryHeatmap — ModuleRegulatoryHeatmap","title":"ModuleRegulatoryHeatmap — ModuleRegulatoryHeatmap","text":"function visualizes regulatory network gene modules heatmap, cell represents regulatory score source target module. heatmap can display either positive, negative, delta (positive minus negative) regulatory scores. Optionally, dendrogram can plotted cluster modules based regulatory interactions.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/ModuleRegulatoryHeatmap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"ModuleRegulatoryHeatmap — ModuleRegulatoryHeatmap","text":"","code":"ModuleRegulatoryHeatmap(   seurat_obj,   feature = \"delta\",   TFs_only = TRUE,   dendrogram = TRUE,   coord_fixed = TRUE,   max_val = 1,   min_val_label = 3,   high_color = \"orange2\",   mid_color = \"white\",   low_color = \"dodgerblue\",   wgcna_name = NULL )"},{"path":"https://smorabit.github.io/hdWGCNA/reference/ModuleRegulatoryHeatmap.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"ModuleRegulatoryHeatmap — ModuleRegulatoryHeatmap","text":"seurat_obj Seurat object containing single-cell data WGCNA results. feature character string specifying type regulatory score plot. Options 'positive' (positive regulatory score), 'negative' (negative regulatory score), 'delta' (difference positive negative scores). Default 'delta'. TFs_only Logical; TRUE (default), transcription factor (TF) genes included heatmap. FALSE, genes considered regulatory network. dendrogram Logical; TRUE (default), dendrogram added heatmap cluster modules based regulatory interactions. Default TRUE. coord_fixed Logical; TRUE (default), aspect ratio x y axes equal. Default TRUE. max_val Numeric; sets maximum absolute value regulatory score. values exceeding threshold capped. Default 1. min_val_label Numeric; minimum number interactions required label displayed heatmap cell. Default 3. high_color Character string; color representing high regulatory scores heatmap. Default 'orange2'. mid_color Character string; color representing intermediate regulatory scores heatmap. Default 'white'. low_color Character string; color representing low regulatory scores heatmap. Default 'dodgerblue'. wgcna_name name hdWGCNA experiment seurat_obj@misc slot","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/ModuleRegulatoryHeatmap.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"ModuleRegulatoryHeatmap — ModuleRegulatoryHeatmap","text":"ggplot2 object visualizing module regulatory network heatmap, can customized displayed using plot().","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/ModuleRegulatoryHeatmap.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"ModuleRegulatoryHeatmap — ModuleRegulatoryHeatmap","text":"function visualizes regulatory network gene modules plotting regulatory scores heatmap. cell heatmap represents regulatory interaction source module (columns) target module (rows). color cell represents magnitude direction (positive negative) regulatory score. Users can choose plot positive, negative, delta scores can adjust color gradient score thresholds. dendrogram can added cluster modules based regulatory patterns, labels can shown cells sufficient number interactions.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/ModuleRegulatoryNetwork.html","id":null,"dir":"Reference","previous_headings":"","what":"ModuleRegulatoryNetwork — ModuleRegulatoryNetwork","title":"ModuleRegulatoryNetwork — ModuleRegulatoryNetwork","text":"Summarizes Transcription Factor regulatory networks across co-expression modules.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/ModuleRegulatoryNetwork.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"ModuleRegulatoryNetwork — ModuleRegulatoryNetwork","text":"","code":"ModuleRegulatoryNetwork(seurat_obj, TFs_only = TRUE, wgcna_name = NULL)"},{"path":"https://smorabit.github.io/hdWGCNA/reference/ModuleRegulatoryNetwork.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"ModuleRegulatoryNetwork — ModuleRegulatoryNetwork","text":"seurat_obj Seurat object containing single-cell data WGCNA results. TFs_only Logical; TRUE (default), transcription factor (TF) genes included regulatory network. FALSE, network includes genes. wgcna_name name hdWGCNA experiment seurat_obj@misc slot","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/ModuleRegulatoryNetwork.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"ModuleRegulatoryNetwork — ModuleRegulatoryNetwork","text":"data frame following columns: source source module regulatory interaction. target target module regulatory interaction. n_pos number positive regulatory links source module target module. sum_pos sum gain values positive links. n_neg number negative regulatory links source module target module. sum_neg sum gain values negative links. mean_pos average gain positive links. mean_neg average gain negative links. score_pos number positive links normalized number TFs source module. score_neg number negative links normalized number TFs source module.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/ModuleRegulatoryNetwork.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"ModuleRegulatoryNetwork — ModuleRegulatoryNetwork","text":"function summarizes transcription factor regulatory networks across modules infer module-module relationships. number directed TF links across modules counted normalized. strength links XGBoost model also tracked.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/ModuleRegulatoryNetworkPlot.html","id":null,"dir":"Reference","previous_headings":"","what":"ModuleRegulatoryNetworkPlot — ModuleRegulatoryNetworkPlot","title":"ModuleRegulatoryNetworkPlot — ModuleRegulatoryNetworkPlot","text":"function visualizes regulatory network gene modules Seurat object. plot displays transcription factor (TF) regulatory interactions modules, edges representing positive negative regulatory links.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/ModuleRegulatoryNetworkPlot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"ModuleRegulatoryNetworkPlot — ModuleRegulatoryNetworkPlot","text":"","code":"ModuleRegulatoryNetworkPlot(   seurat_obj,   feature = \"delta\",   TFs_only = TRUE,   layout = \"umap\",   umap_background = FALSE,   max_val = 1,   cutoff = 0,   focus_source = NULL,   focus_target = NULL,   loops = TRUE,   label_modules = TRUE,   high_color = \"orange2\",   mid_color = \"white\",   low_color = \"dodgerblue\",   wgcna_name = NULL,   ... )"},{"path":"https://smorabit.github.io/hdWGCNA/reference/ModuleRegulatoryNetworkPlot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"ModuleRegulatoryNetworkPlot — ModuleRegulatoryNetworkPlot","text":"seurat_obj Seurat object containing single-cell data WGCNA results. feature character string specifying type regulatory score plot. Options 'positive' (positive regulatory score), 'negative' (negative regulatory score), 'delta' (difference positive negative scores). Default 'delta'. TFs_only Logical; TRUE (default), transcription factor (TF) genes included plot. FALSE, genes considered regulatory network. layout character string specifying layout plot. Default 'umap', arranges modules according UMAP coordinates. layout options ggraph can also used. umap_background Logical; TRUE, UMAP module eigengenes plotted background (layout = 'umap'). Default FALSE. max_val Numeric; sets maximum absolute value regulatory score. values exceeding threshold capped. Default 1. cutoff Numeric; edges absolute regulatory scores value excluded plot. Default 0. focus_source Character vector; optionally restricts plot show regulatory links specified source modules. Default NULL (modules included). focus_target Character vector; optionally restricts plot show regulatory links targeting specified modules. Default NULL (modules included). loops Logical; TRUE (default), loops (self-regulatory connections) shown plot. label_modules Logical; TRUE (default), module names displayed labels plot. high_color Character string; color representing high regulatory scores color gradient. Default 'orange2'. mid_color Character string; color representing intermediate regulatory scores color gradient. Default 'white'. low_color Character string; color representing low regulatory scores color gradient. Default 'dodgerblue'. wgcna_name name hdWGCNA experiment seurat_obj@misc slot ... Additional arguments passed ggraph::create_layout function.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/ModuleRegulatoryNetworkPlot.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"ModuleRegulatoryNetworkPlot — ModuleRegulatoryNetworkPlot","text":"ggplot2 object visualizing regulatory network, can customized displayed using plot().","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/ModuleRegulatoryNetworkPlot.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"ModuleRegulatoryNetworkPlot — ModuleRegulatoryNetworkPlot","text":"function visualizes regulatory network gene modules plotting transcription factor regulatory interactions. Positive negative regulatory scores displayed edges connecting nodes (modules), node sizes proportional number genes module. Users can customize network layout (e.g., UMAP graph layouts), filter edges based score thresholds, highlight specific modules using focus parameters. Edge colors represent strength direction (positive negative) regulatory interactions, loops can optionally plotted indicate self-regulation.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/ModuleTFNetwork.html","id":null,"dir":"Reference","previous_headings":"","what":"ModuleTFNetwork — ModuleTFNetwork","title":"ModuleTFNetwork — ModuleTFNetwork","text":"Plotting relationships TF co-expression modules","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/ModuleTFNetwork.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"ModuleTFNetwork — ModuleTFNetwork","text":"","code":"ModuleTFNetwork(   seurat_obj,   tf_name,   tf_gene_name,   edge.alpha = 0.75,   cor_thresh = 0.25,   high_color = \"red\",   mid_color = \"grey\",   low_color = \"blue\",   slot = \"data\",   size.scale = 30,   tf_x = 0,   tf_y = 0,   wgcna_name = NULL )"},{"path":"https://smorabit.github.io/hdWGCNA/reference/ModuleTFNetwork.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"ModuleTFNetwork — ModuleTFNetwork","text":"seurat_obj Seurat object tf_name Motif name tf tf_gene_name gene associated tf rownames(seurat_obj) edge.alpha scaling factor edge opacity network cor_thresh threshold plot correlation edges modules high_color color positive correlation mid_color color zero correlation low_color color negative correlation slot slot seurat object extract expression data tf_gene_name size.scale scaling factor size node tf_x x coordinate TF TF found UMAP tf_y y coordinate TF TF foudn UMAP wgcna_name name WGCNA experiment seurat object","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/ModuleTFNetwork.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"ModuleTFNetwork — ModuleTFNetwork","text":"","code":"ModuleTFNetwork #> function (seurat_obj, tf_name, tf_gene_name, edge.alpha = 0.75,  #>     cor_thresh = 0.25, high_color = \"red\", mid_color = \"grey\",  #>     low_color = \"blue\", slot = \"data\", size.scale = 30, tf_x = 0,  #>     tf_y = 0, wgcna_name = NULL)  #> { #>     if (is.null(wgcna_name)) { #>         wgcna_name <- seurat_obj@misc$active_wgcna #>     } #>     modules <- GetModules(seurat_obj, wgcna_name) %>% subset(module !=  #>         \"grey\") %>% mutate(module = droplevels(module)) #>     MEs <- GetMEs(seurat_obj, TRUE, wgcna_name) %>% as.matrix #>     MEs <- MEs[, colnames(MEs) != \"grey\"] #>     mod_sizes <- table(modules$module) #>     module_cor <- Hmisc::rcorr(x = MEs, type = \"pearson\")$r #>     module_cor[lower.tri(module_cor)] <- NA #>     module_cor <- reshape2::melt(module_cor) %>% na.omit #>     module_cor <- subset(module_cor, abs(value) >= cor_thresh &  #>         Var1 != Var2) #>     module_cor #>     cur_exp <- GetAssayData(seurat_obj, slot = slot)[tf_gene_name,  #>         ] #>     exp_cor <- Hmisc::rcorr(x = MEs, y = cur_exp)$r[1:ncol(MEs),  #>         \"y\"] #>     exp_cor <- data.frame(mod = names(exp_cor), value = as.numeric(exp_cor)) #>     plot_lim <- abs(max(c(abs(range(exp_cor$value)), abs(range(module_cor$value))))) #>     p <- ggplot(module_cor, aes(x = Var1, y = Var2, color = value)) +  #>         geom_point() + scale_color_gradient2(high = high_color,  #>         mid = mid_color, low = low_color, limits = c(-1 * plot_lim,  #>             plot_lim)) #>     ggp <- ggplot_build(p) #>     module_cor$color <- ggp$data[[1]]$colour #>     p <- ggplot(exp_cor, aes(x = mod, y = mod, color = value)) +  #>         geom_point() + scale_color_gradient2(high = high_color,  #>         mid = mid_color, low = low_color, limits = c(-1 * plot_lim,  #>             plot_lim)) #>     ggp <- ggplot_build(p) #>     exp_cor$color <- ggp$data[[1]]$colour #>     umap_df <- GetModuleUMAP(seurat_obj, wgcna_name) #>     mods <- levels(umap_df$modules) #>     tf_match <- GetMotifMatrix(seurat_obj) #>     tf_targets <- GetMotifTargets(seurat_obj) #>     motif_df <- GetMotifs(seurat_obj) #>     overlap_df <- GetMotifOverlap(seurat_obj) #>     centroid_df <- umap_df %>% dplyr::select(c(UMAP1, UMAP2,  #>         module)) %>% dplyr::group_by(module) %>% dplyr::summarise(x = mean(UMAP1),  #>         y = mean(UMAP2)) #>     cur_overlap <- subset(overlap_df, tf == tf_name) #>     node_df <- dplyr::left_join(centroid_df, cur_overlap, by = \"module\") %>%  #>         dplyr::rename(c(UMAP1 = x, UMAP2 = y, name = module)) #>     node_df$size <- as.numeric(node_df$size_intersection)/as.numeric(mod_sizes) #>     if (tf_gene_name %in% umap_df$gene) { #>         tf_df <- umap_df[umap_df$gene == tf_gene_name, ] %>%  #>             dplyr::select(-c(hub, kME, module)) %>% dplyr::rename(name = gene) #>     } #>     else { #>         tf_df <- data.frame(name = tf_gene_name, module = \"grey\",  #>             color = \"grey\", UMAP1 = tf_x, UMAP2 = tf_y) #>     } #>     tf_df$size <- 0.25 #>     edge_df <- data.frame(Var1 = tf_gene_name, Var2 = as.character(node_df$name),  #>         value = node_df$odds_ratio, color = exp_cor$color) #>     edge_df$color <- ifelse(node_df$fdr <= 0.05, edge_df$color,  #>         \"grey\") #>     edge_df <- subset(edge_df, color != \"grey\") #>     node_df <- dplyr::bind_rows(node_df, tf_df) %>% as.data.frame() #>     rownames(node_df) <- as.character(node_df$name) #>     g1 <- igraph::graph_from_data_frame(edge_df, directed = TRUE,  #>         vertices = node_df) #>     g2 <- igraph::graph_from_data_frame(module_cor, directed = FALSE,  #>         vertices = node_df) #>     plot(g2, layout = as.matrix(node_df[, c(\"UMAP1\", \"UMAP2\")]),  #>         vertex.size = 1, edge.curved = 0, edge.width = 1, vertex.color = \"grey\",  #>         vertex.label = \"\", edge.color = adjustcolor(igraph::E(g2)$color,  #>             alpha.f = edge.alpha), ) #>     plot(g1, layout = as.matrix(node_df[, c(\"UMAP1\", \"UMAP2\")]),  #>         edge.color = adjustcolor(igraph::E(g1)$color), vertex.size = igraph::V(g1)$size *  #>             size.scale, edge.curved = 0, edge.width = edge_df$value *  #>             2, vertex.color = igraph::V(g1)$color, vertex.label = igraph::V(g1)$name,  #>         vertex.label.dist = 1.1, vertex.label.degree = -pi/4,  #>         vertex.label.family = \"Helvetica\", vertex.label.font = 3,  #>         vertex.label.color = \"black\", vertex.label.cex = 0, vertex.frame.color = \"black\",  #>         margin = 0, edge.arrow.size = edge_df$value/2, add = TRUE) #> } #> <bytecode: 0x7fced738ad68> #> <environment: namespace:hdWGCNA>"},{"path":"https://smorabit.github.io/hdWGCNA/reference/ModuleTopologyBarplot.html","id":null,"dir":"Reference","previous_headings":"","what":"ModuleTopologyBarplot — ModuleTopologyBarplot","title":"ModuleTopologyBarplot — ModuleTopologyBarplot","text":"Plots ranked barplot genes co-expression module intramodular connectivity","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/ModuleTopologyBarplot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"ModuleTopologyBarplot — ModuleTopologyBarplot","text":"","code":"ModuleTopologyBarplot(   seurat_obj,   mod,   features = \"kME\",   plot_color = NULL,   alpha = TRUE,   genes_order = NULL,   return_genes = FALSE,   wgcna_name = NULL )"},{"path":"https://smorabit.github.io/hdWGCNA/reference/ModuleTopologyBarplot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"ModuleTopologyBarplot — ModuleTopologyBarplot","text":"seurat_obj Seurat object mod name co-expression module plot features specify features use barplot, 'kME' 'degree' 'weighted_degree' (degree scaled 0 1) plot_color color used bar plot, default module's unique color alpha logical indicating whether add opacity barplot based strength (kME degree) genes_order character vector genes plot specific order, option override order_by parameter return_genes logical indicating whether return wgcna_name name hdWGCNA experiment seurat_obj@misc slot","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/ModuleTopologyBarplot.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"ModuleTopologyBarplot — ModuleTopologyBarplot","text":"ggplot object containing ModuleTopologyBarplot","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/ModuleTopologyBarplot.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"ModuleTopologyBarplot — ModuleTopologyBarplot","text":"ModuleTopologyBarplot generates barplot showing intramodular connectivity gene specific co-expression module. bar plot represents single gene, ranked based strength connections within particular module. custom gene ordering can supplied, helpful comparing module topologies side side one dataset.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/ModuleTopologyHeatmap.html","id":null,"dir":"Reference","previous_headings":"","what":"ModuleTopologyHeatmap — ModuleTopologyHeatmap","title":"ModuleTopologyHeatmap — ModuleTopologyHeatmap","text":"Plots heatmap co-expression network topology given module.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/ModuleTopologyHeatmap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"ModuleTopologyHeatmap — ModuleTopologyHeatmap","text":"","code":"ModuleTopologyHeatmap(   seurat_obj,   mod,   matrix = \"TOM\",   matrix_name = NULL,   order_by = \"kME\",   high_color = NULL,   low_color = \"white\",   raster = TRUE,   raster_dpi = 200,   plot_max = \"q99\",   plot_min = 0,   return_genes = FALSE,   genes_order = NULL,   TOM_use = NULL,   wgcna_name = NULL,   ... )"},{"path":"https://smorabit.github.io/hdWGCNA/reference/ModuleTopologyHeatmap.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"ModuleTopologyHeatmap — ModuleTopologyHeatmap","text":"seurat_obj Seurat object mod name co-expression module plot matrix specify matrix plot, use 'TOM' (topological overlap matrix) 'Cor' (correlation matrix), pass custom square matrix rownames colnames match genes module matrix_name name matrix plotted used label plot legend order_by order genes module 'kME' (default) 'degree' (sum connections gene co-expression network) high_color color used high values heatmap, default module's unique color low_color color used low values heatmap, default 'white' raster logical indicating whether rasterise plot raster_dpi dpi used rasterised plot plot_max maximum value plot heatmap, can pass numeric value string indicating quantile ('q99' 99th percentile) plot_min minimum value plot heatmap, can pass numeric value string indicating quantile ('q1' 1st percentile) return_genes logical indicating whether return genes_order character vector genes plot specific order, option override order_by parameter TOM_use name hdWGCNA experiment containing TOM used plotting wgcna_name name hdWGCNA experiment seurat_obj@misc slot","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/ModuleTopologyHeatmap.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"ModuleTopologyHeatmap — ModuleTopologyHeatmap","text":"ggplot object containing ModuleTopologyHeatmap","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/ModuleTopologyHeatmap.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"ModuleTopologyHeatmap — ModuleTopologyHeatmap","text":"ModuleTopologyHeatmap generates triangular heatmap plot showing network \"topology\" specific co-expression module. cell heatmap represents gene-gene pair, heatmap colored strength connection two genes. default genes heatmap ordered rows columns based importance module, ranked either eigengene-based connectivity (kME) network degree.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/ModuleTraitCorrelation.html","id":null,"dir":"Reference","previous_headings":"","what":"ModuleTraitCorrelation' — ModuleTraitCorrelation","title":"ModuleTraitCorrelation' — ModuleTraitCorrelation","text":"Correlates categorical numeric variables Module Eigengenes hub-gene scores.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/ModuleTraitCorrelation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"ModuleTraitCorrelation' — ModuleTraitCorrelation","text":"","code":"ModuleTraitCorrelation(   seurat_obj,   traits,   group.by = NULL,   features = \"hMEs\",   cor_method = \"pearson\",   subset_by = NULL,   subset_groups = NULL,   wgcna_name = NULL,   ... )"},{"path":"https://smorabit.github.io/hdWGCNA/reference/ModuleTraitCorrelation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"ModuleTraitCorrelation' — ModuleTraitCorrelation","text":"seurat_obj list column names Seurat object's metadata wish correlate module. Traits must categorical variable (character vector), numeric variable. features features use summarize modules? Valid choices hMEs, MEs, scores wgcna_name name hdWGCNA experiment seurat_obj@misc slot cor_meth method use correlation? Valid choices pearson, spearman, kendall.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/ModuleTraitCorrelation.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"ModuleTraitCorrelation' — ModuleTraitCorrelation","text":"","code":"ModuleTraitCorrelation #> function (seurat_obj, traits, group.by = NULL, features = \"hMEs\",  #>     cor_method = \"pearson\", subset_by = NULL, subset_groups = NULL,  #>     wgcna_name = NULL, ...)  #> { #>     if (is.null(wgcna_name)) { #>         wgcna_name <- seurat_obj@misc$active_wgcna #>     } #>     CheckWGCNAName(seurat_obj, wgcna_name) #>     if (features == \"hMEs\") { #>         MEs <- GetMEs(seurat_obj, TRUE, wgcna_name) #>     } #>     else if (features == \"MEs\") { #>         MEs <- GetMEs(seurat_obj, FALSE, wgcna_name) #>     } #>     else if (features == \"scores\") { #>         MEs <- GetModuleScores(seurat_obj, wgcna_name) #>     } #>     else { #>         stop(\"Invalid feature selection. Valid choices: hMEs, MEs, scores, average\") #>     } #>     if (!is.null(subset_by)) { #>         print(\"subsetting\") #>         seurat_full <- seurat_obj #>         MEs <- MEs[seurat_obj@meta.data[[subset_by]] %in% subset_groups,  #>             ] #>         seurat_obj <- seurat_obj[, seurat_obj@meta.data[[subset_by]] %in%  #>             subset_groups] #>     } #>     if (sum(traits %in% colnames(seurat_obj@meta.data)) != length(traits)) { #>         stop(paste(\"Some of the provided traits were not found in the Seurat obj:\",  #>             paste(traits[!(traits %in% colnames(seurat_obj@meta.data))],  #>                 collapse = \", \"))) #>     } #>     if (is.null(group.by)) { #>         group.by <- \"temp_ident\" #>         seurat_obj$temp_ident <- Idents(seurat_obj) #>     } #>     valid_types <- c(\"numeric\", \"factor\", \"integer\") #>     data_types <- sapply(traits, function(x) { #>         class(seurat_obj@meta.data[, x]) #>     }) #>     if (!all(data_types %in% valid_types)) { #>         incorrect <- traits[!(data_types %in% valid_types)] #>         stop(paste0(\"Invalid data types for \", paste(incorrect,  #>             collapse = \", \"), \". Accepted data types are numeric, factor, integer.\")) #>     } #>     if (any(data_types == \"factor\")) { #>         factor_traits <- traits[data_types == \"factor\"] #>         for (tr in factor_traits) { #>             warning(paste0(\"Trait \", tr, \" is a factor with levels \",  #>                 paste0(levels(seurat_obj@meta.data[, tr]), collapse = \", \"),  #>                 \". Levels will be converted to numeric IN THIS ORDER for the correlation, is this the expected order?\")) #>         } #>     } #>     modules <- GetModules(seurat_obj, wgcna_name) #>     mods <- levels(modules$module) #>     mods <- mods[mods != \"grey\"] #>     trait_df <- seurat_obj@meta.data[, traits] #>     if (length(traits == 1)) { #>         trait_df <- data.frame(x = trait_df) #>         colnames(trait_df) <- traits #>     } #>     if (any(data_types == \"factor\")) { #>         factor_traits <- traits[data_types == \"factor\"] #>         for (tr in factor_traits) { #>             trait_df[, tr] <- as.numeric(trait_df[, tr]) #>         } #>     } #>     cor_list <- list() #>     pval_list <- list() #>     fdr_list <- list() #>     temp <- Hmisc::rcorr(as.matrix(trait_df), as.matrix(MEs),  #>         type = cor_method) #>     cur_cor <- temp$r[traits, mods] #>     cur_p <- temp$P[traits, mods] #>     p_df <- cur_p %>% reshape2::melt() #>     if (length(traits) == 1) { #>         tmp <- rep(mods, length(traits)) #>         tmp <- factor(tmp, levels = mods) #>         tmp <- tmp[order(tmp)] #>         p_df$Var1 <- traits #>         p_df$Var2 <- tmp #>         rownames(p_df) <- 1:nrow(p_df) #>         p_df <- dplyr::select(p_df, c(Var1, Var2, value)) #>     } #>     p_df <- p_df %>% dplyr::mutate(fdr = p.adjust(value, method = \"fdr\")) %>%  #>         dplyr::select(c(Var1, Var2, fdr)) #>     cur_fdr <- reshape2::dcast(p_df, Var1 ~ Var2, value.var = \"fdr\") #>     rownames(cur_fdr) <- cur_fdr$Var1 #>     cur_fdr <- cur_fdr[, -1] #>     cor_list[[\"all_cells\"]] <- cur_cor #>     pval_list[[\"all_cells\"]] <- cur_p #>     fdr_list[[\"all_cells\"]] <- cur_fdr #>     trait_df <- cbind(trait_df, seurat_obj@meta.data[, group.by]) #>     colnames(trait_df)[ncol(trait_df)] <- \"group\" #>     MEs <- cbind(as.data.frame(MEs), seurat_obj@meta.data[, group.by]) #>     colnames(MEs)[ncol(MEs)] <- \"group\" #>     if (class(seurat_obj@meta.data[, group.by]) == \"factor\") { #>         group_names <- levels(seurat_obj@meta.data[, group.by]) #>     } #>     else { #>         group_names <- levels(as.factor(seurat_obj@meta.data[,  #>             group.by])) #>     } #>     trait_list <- dplyr::group_split(trait_df, group, .keep = FALSE) #>     ME_list <- dplyr::group_split(MEs, group, .keep = FALSE) #>     names(trait_list) <- group_names #>     names(ME_list) <- group_names #>     for (i in names(trait_list)) { #>         temp <- Hmisc::rcorr(as.matrix(trait_list[[i]]), as.matrix(ME_list[[i]])) #>         cur_cor <- temp$r[traits, mods] #>         cur_p <- temp$P[traits, mods] #>         p_df <- cur_p %>% reshape2::melt() #>         if (length(traits) == 1) { #>             tmp <- rep(mods, length(traits)) #>             tmp <- factor(tmp, levels = mods) #>             tmp <- tmp[order(tmp)] #>             p_df$Var1 <- traits #>             p_df$Var2 <- tmp #>             rownames(p_df) <- 1:nrow(p_df) #>             p_df <- dplyr::select(p_df, c(Var1, Var2, value)) #>         } #>         p_df <- p_df %>% dplyr::mutate(fdr = p.adjust(value,  #>             method = \"fdr\")) %>% dplyr::select(c(Var1, Var2,  #>             fdr)) #>         cur_fdr <- reshape2::dcast(p_df, Var1 ~ Var2, value.var = \"fdr\") #>         rownames(cur_fdr) <- cur_fdr$Var1 #>         cur_fdr <- cur_fdr[, -1] #>         cor_list[[i]] <- cur_cor #>         pval_list[[i]] <- cur_p #>         fdr_list[[i]] <- as.matrix(cur_fdr) #>     } #>     mt_cor <- list(cor = cor_list, pval = pval_list, fdr = fdr_list) #>     if (!is.null(subset_by)) { #>         seurat_full <- SetModuleTraitCorrelation(seurat_full,  #>             mt_cor, wgcna_name) #>         seurat_obj <- seurat_full #>     } #>     else { #>         seurat_obj <- SetModuleTraitCorrelation(seurat_obj, mt_cor,  #>             wgcna_name) #>     } #>     seurat_obj #> } #> <bytecode: 0x7f96306795a8> #> <environment: namespace:hdWGCNA>"},{"path":"https://smorabit.github.io/hdWGCNA/reference/ModuleUMAPPlot.html","id":null,"dir":"Reference","previous_headings":"","what":"ModuleUMAPPlot — ModuleUMAPPlot","title":"ModuleUMAPPlot — ModuleUMAPPlot","text":"Makes igraph network plot using module UMAP","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/ModuleUMAPPlot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"ModuleUMAPPlot — ModuleUMAPPlot","text":"","code":"ModuleUMAPPlot(   seurat_obj,   sample_edges = TRUE,   edge_prop = 0.2,   label_hubs = 5,   edge.alpha = 0.25,   vertex.label.cex = 0.5,   label_genes = NULL,   return_graph = FALSE,   keep_grey_edges = TRUE,   wgcna_name = NULL,   ... )"},{"path":"https://smorabit.github.io/hdWGCNA/reference/ModuleUMAPPlot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"ModuleUMAPPlot — ModuleUMAPPlot","text":"seurat_obj Seurat object sample_edges logical determining whether downsample edges plotting (TRUE), take strongst edges. edge_prop proportion edges plot. sample_edges=FALSE, strongest edges selected. label_hubs number hub genes label module edge.alpha scaling factor edge opacity vertex.label.cex font size labeled genes return_graph logical determining whether plot thr graph (FALSE) return igraph object (TRUE) keep_grey_edges logical determining whether show edges genes different modules (grey edges) wgcna_name name hdWGCNA experiment seurat_obj@misc slot","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/ModuleUMAPPlot.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"ModuleUMAPPlot — ModuleUMAPPlot","text":"","code":"ModuleUMAPPlot #> function (seurat_obj, sample_edges = TRUE, edge_prop = 0.2, label_hubs = 5,  #>     edge.alpha = 0.25, vertex.label.cex = 0.5, label_genes = NULL,  #>     return_graph = FALSE, keep_grey_edges = TRUE, wgcna_name = NULL,  #>     ...)  #> { #>     if (is.null(wgcna_name)) { #>         wgcna_name <- seurat_obj@misc$active_wgcna #>     } #>     TOM <- GetTOM(seurat_obj, wgcna_name) #>     modules <- GetModules(seurat_obj, wgcna_name) #>     umap_df <- GetModuleUMAP(seurat_obj, wgcna_name) #>     mods <- levels(umap_df$module) #>     mods <- mods[mods != \"grey\"] #>     subset_TOM <- TOM[umap_df$gene, umap_df$gene[umap_df$hub ==  #>         \"hub\"]] #>     hub_list <- lapply(mods, function(cur_mod) { #>         cur <- subset(modules, module == cur_mod) #>         cur[, c(\"gene_name\", paste0(\"kME_\", cur_mod))] %>% top_n(label_hubs) %>%  #>             .$gene_name #>     }) #>     names(hub_list) <- mods #>     hub_labels <- as.character(unlist(hub_list)) #>     print(\"hub labels\") #>     print(hub_labels) #>     print(label_genes) #>     if (is.null(label_genes)) { #>         label_genes <- hub_labels #>     } #>     else { #>         if (!any(label_genes %in% umap_df$gene)) { #>             stop(\"Some genes in label_genes not found in the UMAP.\") #>         } #>         label_genes <- unique(c(label_genes, hub_labels)) #>     } #>     print(label_genes) #>     selected_modules <- modules[umap_df$gene, ] #>     selected_modules <- cbind(selected_modules, umap_df[, c(\"UMAP1\",  #>         \"UMAP2\", \"hub\", \"kME\")]) #>     selected_modules$label <- ifelse(selected_modules$gene_name %in%  #>         label_genes, selected_modules$gene_name, \"\") #>     selected_modules$fontcolor <- ifelse(selected_modules$color ==  #>         \"black\", \"gray50\", \"black\") #>     selected_modules$framecolor <- ifelse(selected_modules$gene_name %in%  #>         label_genes, \"black\", selected_modules$color) #>     edge_df <- subset_TOM %>% reshape2::melt() #>     print(dim(edge_df)) #>     edge_df$color <- future.apply::future_sapply(1:nrow(edge_df),  #>         function(i) { #>             gene1 = as.character(edge_df[i, \"Var1\"]) #>             gene2 = as.character(edge_df[i, \"Var2\"]) #>             col1 <- selected_modules[selected_modules$gene_name ==  #>                 gene1, \"color\"] #>             col2 <- selected_modules[selected_modules$gene_name ==  #>                 gene2, \"color\"] #>             if (col1 == col2) { #>                 col = col1 #>             } #>             else { #>                 col = \"grey90\" #>             } #>             col #>         }) #>     if (!keep_grey_edges) { #>         edge_df <- edge_df %>% subset(color != \"grey90\") #>     } #>     groups <- unique(edge_df$color) #>     if (sample_edges) { #>         temp <- do.call(rbind, lapply(groups, function(cur_group) { #>             cur_df <- edge_df %>% subset(color == cur_group) #>             n_edges <- nrow(cur_df) #>             cur_sample <- sample(1:n_edges, round(n_edges * edge_prop)) #>             cur_df[cur_sample, ] #>         })) #>     } #>     else { #>         temp <- do.call(rbind, lapply(groups, function(cur_group) { #>             cur_df <- edge_df %>% subset(color == cur_group) #>             n_edges <- nrow(cur_df) #>             cur_df %>% dplyr::top_n(round(n_edges * edge_prop),  #>                 wt = value) #>         })) #>     } #>     edge_df <- temp #>     print(dim(edge_df)) #>     edge_df <- edge_df %>% group_by(color) %>% mutate(value = scale01(value)) #>     edge_df <- edge_df %>% arrange(value) #>     edge_df <- rbind(subset(edge_df, color == \"grey90\"), subset(edge_df,  #>         color != \"grey90\")) #>     edge_df$color_alpha <- ifelse(edge_df$color == \"grey90\",  #>         alpha(edge_df$color, alpha = edge_df$value/2), alpha(edge_df$color,  #>             alpha = edge_df$value)) #>     selected_modules <- rbind(subset(selected_modules, hub ==  #>         \"other\"), subset(selected_modules, hub != \"other\")) #>     selected_modules <- rbind(subset(selected_modules, label ==  #>         \"\"), subset(selected_modules, label != \"\")) #>     g <- igraph::graph_from_data_frame(edge_df, directed = FALSE,  #>         vertices = selected_modules) #>     if (return_graph) { #>         return(g) #>     } #>     plot(g, layout = as.matrix(selected_modules[, c(\"UMAP1\",  #>         \"UMAP2\")]), edge.color = adjustcolor(igraph::E(g)$color_alpha,  #>         alpha.f = edge.alpha), vertex.size = igraph::V(g)$kME *  #>         3, edge.curved = 0, edge.width = 0.5, vertex.color = igraph::V(g)$color,  #>         vertex.label = igraph::V(g)$label, vertex.label.dist = 1.1,  #>         vertex.label.degree = -pi/4, vertex.label.family = \"Helvetica\",  #>         vertex.label.font = 3, vertex.label.color = igraph::V(g)$fontcolor,  #>         vertex.label.cex = 0, vertex.frame.color = igraph::V(g)$framecolor,  #>         margin = 0) #> } #> <bytecode: 0x7f9613c2bf90> #> <environment: namespace:hdWGCNA>"},{"path":"https://smorabit.github.io/hdWGCNA/reference/MotifOverlapBarPlot.html","id":null,"dir":"Reference","previous_headings":"","what":"Displays the top n TFs in a set of modules as a bar plot — MotifOverlapBarPlot","title":"Displays the top n TFs in a set of modules as a bar plot — MotifOverlapBarPlot","text":"Displays top n TFs set modules bar plot","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/MotifOverlapBarPlot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Displays the top n TFs in a set of modules as a bar plot — MotifOverlapBarPlot","text":"","code":"MotifOverlapBarPlot(   seurat_obj,   n_tfs = 10,   plot_size = c(5, 6),   outdir = \"MotifOverlaps/\",   motif_font = \"helvetica_regular\",   module_names = NULL,   wgcna_name = NULL )"},{"path":"https://smorabit.github.io/hdWGCNA/reference/MotifOverlapBarPlot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Displays the top n TFs in a set of modules as a bar plot — MotifOverlapBarPlot","text":"seurat_obj Seurat object wgcna_name name hdWGCNA experiment seurat_obj@misc slot","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/MotifOverlapBarPlot.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Displays the top n TFs in a set of modules as a bar plot — MotifOverlapBarPlot","text":"","code":"MotifOverlapBarPlot #> function (seurat_obj, n_tfs = 10, plot_size = c(5, 6), outdir = \"MotifOverlaps/\",  #>     motif_font = \"helvetica_regular\", module_names = NULL, wgcna_name = NULL)  #> { #>     if (is.null(wgcna_name)) { #>         wgcna_name <- seurat_obj@misc$active_wgcna #>     } #>     if (!dir.exists(outdir)) { #>         dir.create(outdir) #>     } #>     modules <- GetModules(seurat_obj) #>     mods <- levels(modules$module) #>     mods <- mods[mods != \"grey\"] #>     if (is.null(module_names)) { #>         module_names <- mods #>     } #>     overlap_df <- GetMotifOverlap(seurat_obj, wgcna_name) #>     motif_df <- GetMotifs(seurat_obj) #>     pfm <- GetPFMList(seurat_obj) #>     overlap_df$motif_ID <- motif_df$motif_ID[match(overlap_df$tf,  #>         motif_df$motif_name)] #>     overlap_df <- overlap_df %>% subset(module %in% module_names) #>     for (cur_mod in module_names) { #>         print(cur_mod) #>         plot_df <- overlap_df %>% subset(module == cur_mod) %>%  #>             top_n(n_tfs, wt = odds_ratio) %>% arrange(desc(odds_ratio)) #>         p1 <- plot_df %>% ggplot(aes(y = reorder(tf, odds_ratio),  #>             fill = odds_ratio, x = odds_ratio)) + geom_bar(stat = \"identity\",  #>             width = 0.7) + NoLegend() + scale_fill_gradient(high = unique(plot_df$color),  #>             low = \"grey90\") + ylab(\"\") + theme(axis.line.y = element_blank(),  #>             axis.text.y = element_blank(), plot.margin = margin(t = 0,  #>                 r = 0, b = 0, l = 0)) #>         plot_list <- list() #>         for (i in 1:nrow(plot_df)) { #>             cur_id <- plot_df[i, \"motif_ID\"] #>             cur_name <- plot_df[i, \"tf\"] #>             plot_list[[cur_id]] <- ggplot() + ggseqlogo::geom_logo(as.matrix(pfm[[cur_id]]),  #>                 font = motif_font) + ggseqlogo::theme_logo() +  #>                 xlab(\"\") + ylab(cur_name) + theme(axis.text.x = element_blank(),  #>                 axis.text.y = element_blank(), axis.title.y = element_text(angle = 0),  #>                 plot.margin = margin(t = 0, r = 0, b = 0, l = 0)) #>         } #>         patch1 <- wrap_plots(plot_list, ncol = 1) #>         outplot <- (patch1 | p1) + plot_layout(ncol = 2, widths = c(1,  #>             2)) + plot_annotation(title = paste0(\"Motif overlaps with \",  #>             cur_mod), theme = theme(plot.title = element_text(hjust = 0.5))) #>         pdf(paste0(outdir, \"/\", cur_mod, \"_motif_overlaps.pdf\"),  #>             width = plot_size[1], height = plot_size[2], useDingbats = FALSE) #>         print(outplot) #>         dev.off() #>     } #> } #> <bytecode: 0x7f96163d8318> #> <environment: namespace:hdWGCNA>"},{"path":"https://smorabit.github.io/hdWGCNA/reference/MotifScan.html","id":null,"dir":"Reference","previous_headings":"","what":"MotifScan — MotifScan","title":"MotifScan — MotifScan","text":"function scans promoter regions protein-coding genes transcription factor (TF) motifs. extracts promoter sequences using Ensembl database (EnsDb) searches sequences TF binding motifs using position frequency matrices (PFMs). Seurat object updated matrix motif-gene matches, list target genes TF, additional motif information.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/MotifScan.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"MotifScan — MotifScan","text":"","code":"MotifScan(seurat_obj, pfm, EnsDb, species_genome, wgcna_name = NULL)"},{"path":"https://smorabit.github.io/hdWGCNA/reference/MotifScan.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"MotifScan — MotifScan","text":"seurat_obj Seurat object updated motif scan results. pfm list position frequency matrices (PFMs), JASPAR2020 database. EnsDb Ensembl database object (e.g., EnsDb.Hsapiens.v86 EnsDb.Mmusculus.v79) containing gene promoter annotations. species_genome character string specifying genome version (e.g., \"hg38\" human \"mm10\" mouse). wgcna_name character string specifying name WGCNA experiment associate motif data (optional). NULL, active WGCNA experiment seurat_obj@misc used.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/MotifScan.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"MotifScan — MotifScan","text":"modified Seurat object containing results motif scan, including: seurat_obj@misc$motif_matrix: binary matrix indicating motif matches gene. seurat_obj@misc$motif_info: data frame containing motif names, IDs, number target genes. seurat_obj@misc$motif_targets: list genes targeted motif. seurat_obj@misc$pfm: original PFMs used motif scan.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/MotifScan.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"MotifScan — MotifScan","text":"MotifScan function performs following steps: extracts promoter regions (typically 2 kb upstream transcription start site) protein-coding genes provided EnsDb. uses motifmatchr package search promoters TF motifs, using input PFMs. function returns Seurat object updated several key pieces information: motif-gene match matrix indicating presence absence motif promoter gene. list target genes TF based motif presence. summary motifs, including number target genes TF. data stored seurat_obj's metadata can used downstream analysis, regulatory network inference.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/MotifTargetScore.html","id":null,"dir":"Reference","previous_headings":"","what":"MotifTargetScore — MotifTargetScore","title":"MotifTargetScore — MotifTargetScore","text":"Computes gene expression scores TF Motif target genes based MotifScan.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/MotifTargetScore.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"MotifTargetScore — MotifTargetScore","text":"","code":"MotifTargetScore(   seurat_obj,   method = \"Seurat\",   wgcna_genes = TRUE,   wgcna_name = NULL,   ... )"},{"path":"https://smorabit.github.io/hdWGCNA/reference/MotifTargetScore.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"MotifTargetScore — MotifTargetScore","text":"seurat_obj Seurat object method Seurat UCell?","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/MotifTargetScore.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"MotifTargetScore — MotifTargetScore","text":"","code":"MotifTargetScore(pbmc) #> Error in eval(expr, envir, enclos): object 'pbmc' not found"},{"path":"https://smorabit.github.io/hdWGCNA/reference/NormalizeMetacells.html","id":null,"dir":"Reference","previous_headings":"","what":"NormalizeMetacells — NormalizeMetacells","title":"NormalizeMetacells — NormalizeMetacells","text":"Wrapper function run Seurat's NormalizeData function metacell object.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/NormalizeMetacells.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"NormalizeMetacells — NormalizeMetacells","text":"","code":"NormalizeMetacells(seurat_obj, wgcna_name = NULL, ...)"},{"path":"https://smorabit.github.io/hdWGCNA/reference/NormalizeMetacells.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"NormalizeMetacells — NormalizeMetacells","text":"seurat_obj Seurat object","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/OverlapBarPlot.html","id":null,"dir":"Reference","previous_headings":"","what":"OverlapBarPlot — OverlapBarPlot","title":"OverlapBarPlot — OverlapBarPlot","text":"Plots results OverlapModulesDEGs bar plot","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/OverlapBarPlot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"OverlapBarPlot — OverlapBarPlot","text":"","code":"OverlapBarPlot(   overlap_df,   plot_var = \"odds_ratio\",   logscale = FALSE,   neglog = FALSE,   label_size = 2,   ... )"},{"path":"https://smorabit.github.io/hdWGCNA/reference/OverlapBarPlot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"OverlapBarPlot — OverlapBarPlot","text":"overlap_df Module/DEG overlap table OverlapModulesDEGs plot_var name overlap statistic plot logscale logical controlling whether plot result log scale, useful odds ratio neglog logical controlling wehether plot result negative log, useful p-value / FDR label_size size module labels bar plot","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/OverlapBarPlot.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"OverlapBarPlot — OverlapBarPlot","text":"","code":"OverlapBarPlot #> function (overlap_df, plot_var = \"odds_ratio\", logscale = FALSE,  #>     neglog = FALSE, label_size = 2, ...)  #> { #>     label <- plot_var #>     if (plot_var == \"odds_ratio\") { #>         yint <- 1 #>     } #>     else if (plot_var == \"fdr\") { #>         yint <- 0.05 #>     } #>     if (logscale) { #>         overlap_df[[plot_var]] <- log(overlap_df[[plot_var]]) #>         label <- paste0(\"log(\", plot_var, \")\") #>         yint = log(yint) #>     } #>     if (neglog) { #>         overlap_df[[plot_var]] <- -1 * log(overlap_df[[plot_var]]) #>         label <- paste0(\"-log(\", label, \")\") #>         yint = -1 * log(yint) #>     } #>     groups <- overlap_df$group %>% as.character %>% unique #>     plot_list <- list() #>     for (cur_group in groups) { #>         cur_df <- overlap_df %>% subset(group == cur_group) #>         p <- cur_df %>% ggplot(aes(x = reorder(module, get(plot_var)),  #>             y = get(plot_var))) + geom_bar(stat = \"identity\",  #>             fill = cur_df$color) + coord_flip() + xlab(\"\") +  #>             ylab(label) + ggtitle(cur_group) + theme(axis.line.y = element_blank(),  #>             axis.ticks.y = element_blank(), axis.text.y = element_blank(),  #>             plot.title = element_text(hjust = 0.5)) #>         if (plot_var == \"fdr\" | plot_var == \"odds_ratio\") { #>             p <- p + geom_hline(yintercept = yint, linetype = \"dashed\",  #>                 color = \"gray\") #>         } #>         p <- p + geom_text(aes(label = module, x = module, y = get(plot_var)),  #>             color = \"black\", size = label_size, hjust = \"inward\") #>         plot_list[[cur_group]] <- p #>     } #>     plot_list #> } #> <bytecode: 0x7f96347622a8> #> <environment: namespace:hdWGCNA>"},{"path":"https://smorabit.github.io/hdWGCNA/reference/OverlapDotPlot.html","id":null,"dir":"Reference","previous_headings":"","what":"OverlapDotPlot — OverlapDotPlot","title":"OverlapDotPlot — OverlapDotPlot","text":"Makes barplots Enrichr data","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/OverlapDotPlot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"OverlapDotPlot — OverlapDotPlot","text":"","code":"OverlapDotPlot(   overlap_df,   plot_var = \"odds_ratio\",   logscale = TRUE,   neglog = FALSE,   plot_significance = TRUE,   ... )"},{"path":"https://smorabit.github.io/hdWGCNA/reference/OverlapDotPlot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"OverlapDotPlot — OverlapDotPlot","text":"overlap_df Module/DEG overlap table OverlapModulesDEGs plot_var name overlap statistic plot logscale logical controlling whether plot result log scale, useful odds ratio neglog logical controlling wehether plot result negative log, useful p-value / FDR plot_significance logical controlling whether plot significance levels top dots","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/OverlapDotPlot.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"OverlapDotPlot — OverlapDotPlot","text":"","code":"OverlapDotPlot #> function (overlap_df, plot_var = \"odds_ratio\", logscale = TRUE,  #>     neglog = FALSE, plot_significance = TRUE, ...)  #> { #>     label <- plot_var #>     if (logscale) { #>         overlap_df[[plot_var]] <- log(overlap_df[[plot_var]]) #>         label <- paste0(\"log(\", plot_var, \")\") #>     } #>     if (neglog) { #>         overlap_df[[plot_var]] <- -1 * overlap_df[[plot_var]] #>         label <- paste0(\"-\", label) #>     } #>     p <- overlap_df %>% ggplot(aes(x = module, y = group)) +  #>         geom_point(aes(size = get(plot_var), alpha = get(plot_var)),  #>             color = overlap_df$color) + RotatedAxis() + ylab(\"\") +  #>         xlab(\"\") + labs(size = label, alpha = label) + theme(plot.title = element_text(hjust = 0.5),  #>         axis.line.x = element_blank(), axis.line.y = element_blank(),  #>         panel.border = element_rect(colour = \"black\", fill = NA,  #>             size = 1)) #>     if (plot_significance) { #>         p <- p + geom_text(aes(label = Significance)) #>     } #>     p #> } #> <bytecode: 0x7f962ca21a30> #> <environment: namespace:hdWGCNA>"},{"path":"https://smorabit.github.io/hdWGCNA/reference/OverlapModulesDEGs.html","id":null,"dir":"Reference","previous_headings":"","what":"OverlapModulesDEGs — OverlapModulesDEGs","title":"OverlapModulesDEGs — OverlapModulesDEGs","text":"Performs Fisher's Exact Test overlap DEGs hdWGCNA modules.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/OverlapModulesDEGs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"OverlapModulesDEGs — OverlapModulesDEGs","text":"","code":"OverlapModulesDEGs(   seurat_obj,   deg_df,   fc_cutoff = 0.5,   group_col = \"cluster\",   wgcna_name = NULL,   ... )"},{"path":"https://smorabit.github.io/hdWGCNA/reference/OverlapModulesDEGs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"OverlapModulesDEGs — OverlapModulesDEGs","text":"seurat_obj Seurat object deg_df DEG table formatted like output Seurat's FindMarkers fc_cutoff log fold change cutoff DEGs included overlap test group_col name column deg_df containing cell grouping information wgcna_name name hdWGCNA experiment seurat_obj@misc slot","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/OverlapModulesMotifs.html","id":null,"dir":"Reference","previous_headings":"","what":"Overlap modules with TF target genes — OverlapModulesMotifs","title":"Overlap modules with TF target genes — OverlapModulesMotifs","text":"Overlap modules TF target genes","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/OverlapModulesMotifs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Overlap modules with TF target genes — OverlapModulesMotifs","text":"","code":"OverlapModulesMotifs(seurat_obj, wgcna_name = NULL)"},{"path":"https://smorabit.github.io/hdWGCNA/reference/OverlapModulesMotifs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Overlap modules with TF target genes — OverlapModulesMotifs","text":"seurat_obj Seurat object wgcna_name name hdWGCNA experiment seurat_obj@misc slot","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/OverlapModulesMotifs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Overlap modules with TF target genes — OverlapModulesMotifs","text":"","code":"OverlapModulesDEGs #> function (seurat_obj, deg_df, fc_cutoff = 0.5, group_col = \"cluster\",  #>     wgcna_name = NULL, ...)  #> { #>     if (is.null(wgcna_name)) { #>         wgcna_name <- seurat_obj@misc$active_wgcna #>     } #>     deg_df$group <- deg_df[, group_col] #>     cell_groups <- deg_df$group %>% unique #>     modules <- GetModules(seurat_obj) #>     mods <- levels(modules$module) #>     mods <- mods[mods != \"grey\"] #>     if (fc_cutoff >= 0) { #>         deg_df <- subset(deg_df, avg_log2FC >= fc_cutoff) #>     } #>     else { #>         deg_df <- subset(deg_df, avg_log2FC <= fc_cutoff) #>         deg_df$avg_log2FC <- -1 * deg_df$avg_log2FC #>         fc_cutoff <- -1 * fc_cutoff #>     } #>     genome.size <- nrow(seurat_obj) #>     overlap_df <- do.call(rbind, lapply(mods, function(cur_mod) { #>         cur_module_genes <- modules %>% subset(module == cur_mod) %>%  #>             .$gene_name #>         cur_overlap_df <- do.call(rbind, lapply(cell_groups,  #>             function(cur_group) { #>                 cur_DEGs <- deg_df %>% subset(group == cur_group &  #>                   p_val_adj <= 0.05 & avg_log2FC > fc_cutoff) %>%  #>                   .$gene #>                 cur_overlap <- testGeneOverlap(newGeneOverlap(cur_module_genes,  #>                   cur_DEGs, genome.size = genome.size)) #>                 c(cur_overlap@odds.ratio, cur_overlap@pval, cur_overlap@Jaccard,  #>                   length(cur_overlap@intersection)) #>             })) %>% as.data.frame #>         colnames(cur_overlap_df) <- c(\"odds_ratio\", \"pval\", \"Jaccard\",  #>             \"size_intersection\") #>         cur_overlap_df$module <- cur_mod #>         cur_overlap_df$group <- cell_groups #>         cur_overlap_df$color <- modules %>% subset(module ==  #>             cur_mod) %>% .$color %>% unique #>         cur_overlap_df #>     })) #>     overlap_df$fdr <- p.adjust(overlap_df$pval, method = \"fdr\") #>     overlap_df$Significance <- gtools::stars.pval(overlap_df$fdr) #>     overlap_df$Significance <- ifelse(overlap_df$Significance ==  #>         \".\", \"\", overlap_df$Significance) #>     overlap_df$module <- factor(overlap_df$module, levels = mods) #>     overlap_df <- overlap_df %>% dplyr::select(c(module, group,  #>         color, odds_ratio, pval, fdr, Significance, Jaccard,  #>         size_intersection)) #>     overlap_df #> } #> <bytecode: 0x7f9614363708> #> <environment: namespace:hdWGCNA>"},{"path":"https://smorabit.github.io/hdWGCNA/reference/PlotDMEsLollipop.html","id":null,"dir":"Reference","previous_headings":"","what":"PlotDMEsLollipop — PlotDMEsLollipop","title":"PlotDMEsLollipop — PlotDMEsLollipop","text":"Plotting function results FindDMEs FindAllDMEs","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/PlotDMEsLollipop.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"PlotDMEsLollipop — PlotDMEsLollipop","text":"","code":"PlotDMEsLollipop(   seurat_obj,   DMEs,   wgcna_name,   group.by = NULL,   comparison = NULL,   pvalue,   avg_log2FC = \"avg_log2FC\" )"},{"path":"https://smorabit.github.io/hdWGCNA/reference/PlotDMEsLollipop.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"PlotDMEsLollipop — PlotDMEsLollipop","text":"seurat_obj Seurat object DMEs dataframe output FindDMEs FindAllDMEs group.column name selected comparison DMEs dataframe comparison character vector list character vectors containing comparison DMEs dataframe pvalue p_value fdr used comparison DMEs dataframe","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/PlotDMEsLollipop.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"PlotDMEsLollipop — PlotDMEsLollipop","text":"ggplot object PlotDMEsLollipop","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/PlotDMEsVolcano.html","id":null,"dir":"Reference","previous_headings":"","what":"PlotDMEsVolcano — PlotDMEsVolcano","title":"PlotDMEsVolcano — PlotDMEsVolcano","text":"Plotting function results FindDMEs FindAllDMEs.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/PlotDMEsVolcano.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"PlotDMEsVolcano — PlotDMEsVolcano","text":"","code":"PlotDMEsVolcano(   seurat_obj,   DMEs,   plot_labels = TRUE,   mod_point_size = 4,   label_size = 4,   show_cutoff = TRUE,   wgcna_name = NULL,   xlim_range = NULL,   ylim_range = NULL )"},{"path":"https://smorabit.github.io/hdWGCNA/reference/PlotDMEsVolcano.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"PlotDMEsVolcano — PlotDMEsVolcano","text":"seurat_obj Seurat object containing WGCNA analysis @misc slot. DMEs dataframe output FindDMEs FindAllDMEs containing DME results. plot_labels Logical, determines whether plot module labels volcano plot. Default TRUE. mod_point_size Numeric, size points volcano plot. Default 4. label_size Numeric, size module labels plot. Default 4. show_cutoff Logical, determines whether plot significance cutoff. Set FALSE using facet_wrap. Default TRUE. wgcna_name Character, name hdWGCNA experiment seurat_obj@misc slot. Default NULL, case pulls active WGCNA experiment seurat_obj@misc$active_wgcna. xlim_range numeric vector length 2 specifying x-axis limits log2 fold change. Default NULL, automatically calculates limits based data. ylim_range numeric vector length 2 specifying y-axis limits -log10(p-value). Default NULL, automatically calculates limits based data.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/PlotDMEsVolcano.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"PlotDMEsVolcano — PlotDMEsVolcano","text":"ggplot object containing volcano plot DME results.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/PlotDMEsVolcano.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"PlotDMEsVolcano — PlotDMEsVolcano","text":"function generates volcano plot differential module expression (DME) analysis results. can handle two-group comparisons (using output FindDMEs) one-vs-comparisons (using output FindAllDMEs).","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/PlotDMEsVolcano.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"PlotDMEsVolcano — PlotDMEsVolcano","text":"","code":"# Example usage: # Assuming `seurat_obj` is your Seurat object and `DMEs` is the output from FindDMEs PlotDMEsVolcano(seurat_obj, DMEs, wgcna_name = \"MG\") #> Error in eval(expr, envir, enclos): object 'DMEs' not found"},{"path":"https://smorabit.github.io/hdWGCNA/reference/PlotDendrogram.html","id":null,"dir":"Reference","previous_headings":"","what":"PlotDendrogram — PlotDendrogram","title":"PlotDendrogram — PlotDendrogram","text":"Plot WGCNA dendrogram","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/PlotDendrogram.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"PlotDendrogram — PlotDendrogram","text":"","code":"PlotDendrogram(   seurat_obj,   groupLabels = \"Module colors\",   wgcna_name = NULL,   dendroLabels = FALSE,   hang = 0.03,   addGuide = TRUE,   guideHang = 0.05,   main = \"\",   ... )"},{"path":"https://smorabit.github.io/hdWGCNA/reference/PlotDendrogram.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"PlotDendrogram — PlotDendrogram","text":"seurat_obj Seurat object","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/PlotDendrogram.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"PlotDendrogram — PlotDendrogram","text":"","code":"PlotDendrogram #> function (seurat_obj, groupLabels = \"Module colors\", wgcna_name = NULL,  #>     dendroLabels = FALSE, hang = 0.03, addGuide = TRUE, guideHang = 0.05,  #>     main = \"\", ...)  #> { #>     if (is.null(wgcna_name)) { #>         wgcna_name <- seurat_obj@misc$active_wgcna #>     } #>     net <- GetNetworkData(seurat_obj, wgcna_name) #>     modules <- GetModules(seurat_obj, wgcna_name) #>     WGCNA::plotDendroAndColors(net$dendrograms[[1]], as.character(modules$color),  #>         groupLabels = groupLabels, dendroLabels = dendroLabels,  #>         hang = hang, addGuide = addGuide, guideHang = guideHang,  #>         main = main, ...) #> } #> <bytecode: 0x7f9627bc0dd8> #> <environment: namespace:hdWGCNA>"},{"path":"https://smorabit.github.io/hdWGCNA/reference/PlotDifferentialRegulons.html","id":null,"dir":"Reference","previous_headings":"","what":"PlotDifferentialRegulons — PlotDifferentialRegulons","title":"PlotDifferentialRegulons — PlotDifferentialRegulons","text":"Function visualize differential TF regulon activity two groups cells based regulon scores. plot shows average log fold-change (logFC) positive negative regulon scores scatter plot, points colored associated module optionally labeled differentially active regulons.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/PlotDifferentialRegulons.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"PlotDifferentialRegulons — PlotDifferentialRegulons","text":"","code":"PlotDifferentialRegulons(   seurat_obj,   dregs,   n_label = 10,   logfc_thresh = 0.1,   lm = TRUE,   wgcna_name = NULL )"},{"path":"https://smorabit.github.io/hdWGCNA/reference/PlotDifferentialRegulons.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"PlotDifferentialRegulons — PlotDifferentialRegulons","text":"seurat_obj Seurat object contains WGCNA experiment TF regulon scores. dregs Dataframe output FindDifferentialRegulons function containing differential regulon results. n_label Integer specifying number top - -regulated regulons label plot. '', significant regulons labeled. Default = 10. logfc_thresh Numeric threshold labeling annotating regulons based logFC values. Default = 0.1. lm Logical indicating whether plot linear regression line logFC values positive vs. negative regulons. Default = TRUE. wgcna_name name WGCNA experiment seurat_obj@misc slot. Default active WGCNA experiment.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/PlotDifferentialRegulons.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"PlotDifferentialRegulons — PlotDifferentialRegulons","text":"ggplot object representing differential regulon scatter plot.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/PlotDifferentialRegulons.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"PlotDifferentialRegulons — PlotDifferentialRegulons","text":"function generates scatter plot point represents TF regulon, x-axis showing average log fold-change positive regulon scores y-axis showing average log fold-change negative regulon scores. Points colored module assignment, size points reflects module eigengene correlation (kME) value TF. Differentially expressed regulons can highlighted, significantly - -regulated regulons can labeled. Additional options allow adding linear regression line controlling label density based logFC thresholds.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/PlotKMEs.html","id":null,"dir":"Reference","previous_headings":"","what":"PlotKMEs — PlotKMEs","title":"PlotKMEs — PlotKMEs","text":"Plotting function show genes kME value module","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/PlotKMEs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"PlotKMEs — PlotKMEs","text":"","code":"PlotKMEs(   seurat_obj,   n_hubs = 10,   text_size = 2,   ncol = 5,   plot_widths = c(3, 2),   wgcna_name = NULL )"},{"path":"https://smorabit.github.io/hdWGCNA/reference/PlotKMEs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"PlotKMEs — PlotKMEs","text":"seurat_obj Seurat object n_hubs number hub genes display text_size controls size hub gene text ncol number columns display individual plots plot_widths relative width kME rank plot hub gene text wgcna_name name WGCNA experiment seurat object","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/PlotLollipop.html","id":null,"dir":"Reference","previous_headings":"","what":"PlotLollipop — PlotLollipop","title":"PlotLollipop — PlotLollipop","text":"Internal function PlotDMEsLollipop Plotting function results FindDMEs FindAllDMEs","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/PlotLollipop.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"PlotLollipop — PlotLollipop","text":"","code":"PlotLollipop(modules, cur_DMEs, pvalue, avg_log2FC = \"avg_log2FC\")"},{"path":"https://smorabit.github.io/hdWGCNA/reference/PlotLollipop.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"PlotLollipop — PlotLollipop","text":"pvalue p_value fdr used comparison DMEs dataframe seurat_obj Seurat object DMEs dataframe output FindDMEs FindAllDMEs group.column name selected comparison DMEs dataframe comparison character vector list character vectors containing comparison DMEs dataframe","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/PlotLollipop.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"PlotLollipop — PlotLollipop","text":"ggplot object","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/PlotLollipop.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"PlotLollipop — PlotLollipop","text":"","code":"plot_list <- PlotLollipop(modules, DMEs, cur_title= c(\"Group1_vs_Group2\"), pvalue, avg_log2FC = 'avg_log2FC') #> Error in PlotLollipop(modules, DMEs, cur_title = c(\"Group1_vs_Group2\"),     pvalue, avg_log2FC = \"avg_log2FC\"): could not find function \"PlotLollipop\""},{"path":"https://smorabit.github.io/hdWGCNA/reference/PlotModulePreservation.html","id":null,"dir":"Reference","previous_headings":"","what":"PlotModulePreservation — PlotModulePreservation","title":"PlotModulePreservation — PlotModulePreservation","text":"Plotting function Module Preservation statistics","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/PlotModulePreservation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"PlotModulePreservation — PlotModulePreservation","text":"","code":"PlotModulePreservation(   seurat_obj,   name,   statistics = \"summary\",   plot_labels = TRUE,   label_size = 4,   mod_point_size = 4,   wgcna_name = NULL )"},{"path":"https://smorabit.github.io/hdWGCNA/reference/PlotModulePreservation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"PlotModulePreservation — PlotModulePreservation","text":"seurat_obj Seurat object name name module preservation analysis plot given ModulePreservation statistics module preservation statistics plot? Choices summary, , custom list plot_labels logical determining whether plot module labels label_size size module labels mod_point_size size points plot wgcna_name name hdWGCNA experiment seurat_obj@misc slot","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/PlotModulePreservation.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"PlotModulePreservation — PlotModulePreservation","text":"function creates scatter plot showing module preservation statistics module compared size module (number genes).","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/PlotModulePreservationLollipop.html","id":null,"dir":"Reference","previous_headings":"","what":"PlotModulePreservationLollipop — PlotModulePreservationLollipop","title":"PlotModulePreservationLollipop — PlotModulePreservationLollipop","text":"Plots ranked lollipop plot co-expression modules based results module preservation analysis.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/PlotModulePreservationLollipop.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"PlotModulePreservationLollipop — PlotModulePreservationLollipop","text":"","code":"PlotModulePreservationLollipop(   seurat_obj,   name,   features = NULL,   fdr = TRUE,   wgcna_name = NULL )"},{"path":"https://smorabit.github.io/hdWGCNA/reference/PlotModulePreservationLollipop.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"PlotModulePreservationLollipop — PlotModulePreservationLollipop","text":"seurat_obj Seurat object name name give module preservation analysis. features name module preservation features plot. fdr logical indicating whether plot FDR-corrected p-values wgcna_name name hdWGCNA experiment seurat_obj@misc slot","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/PlotModulePreservationLollipop.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"PlotModulePreservationLollipop — PlotModulePreservationLollipop","text":"ggplot object containing PlotModulePreservationLollipop","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/PlotModulePreservationLollipop.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"PlotModulePreservationLollipop — PlotModulePreservationLollipop","text":"PlotModulePreservationLollipop generates lollipop plot showing module preservation results. module preservation test performed using WGCNA method, statistic shown Z-summary preservation statistic. analysis performed using NetRep, statistic shown FDR corrected averaged p-values module preservation permutation test.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/PlotModuleTraitCorrelation.html","id":null,"dir":"Reference","previous_headings":"","what":"PlotModuleTraitCorrelation — PlotModuleTraitCorrelation","title":"PlotModuleTraitCorrelation — PlotModuleTraitCorrelation","text":"Plotting function Module Preservation statistics","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/PlotModuleTraitCorrelation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"PlotModuleTraitCorrelation — PlotModuleTraitCorrelation","text":"","code":"PlotModuleTraitCorrelation(   seurat_obj,   high_color = \"red\",   mid_color = \"grey90\",   low_color = \"blue\",   label = NULL,   label_symbol = \"stars\",   plot_max = NULL,   text_size = 2,   text_color = \"black\",   text_digits = 3,   combine = TRUE,   wgcna_name = NULL )"},{"path":"https://smorabit.github.io/hdWGCNA/reference/PlotModuleTraitCorrelation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"PlotModuleTraitCorrelation — PlotModuleTraitCorrelation","text":"seurat_obj Seurat object high_color color positive correlation mid_color color zero correlation low_color color negative correlation label logical determining whether add p-val label cell heatmap label_symbol show labels 'stars' 'numeric' plot_max maximum value correlation show colorbar text_size size labels text_color color text labels text_digits many digits show text labels combine logical determining whether plot one combined plot (TRUE) return individual plots list (FALSE)","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/PlotModuleTrajectory.html","id":null,"dir":"Reference","previous_headings":"","what":"PlotModuleTrajectory — PlotModuleTrajectory","title":"PlotModuleTrajectory — PlotModuleTrajectory","text":"Plots module eigengene dynamics pseudotime trajectory.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/PlotModuleTrajectory.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"PlotModuleTrajectory — PlotModuleTrajectory","text":"","code":"PlotModuleTrajectory(   seurat_obj,   pseudotime_col = \"pseudotime\",   n_bins = 20,   harmonized = TRUE,   ncol = 4,   point_size = 1,   line_size = 1,   se = TRUE,   group_colors = NULL,   wgcna_name = NULL )"},{"path":"https://smorabit.github.io/hdWGCNA/reference/PlotModuleTrajectory.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"PlotModuleTrajectory — PlotModuleTrajectory","text":"seurat_obj Seurat object pseudotime_col name column seurat_obj@meta.data containing pseudotime information. Multiple names can passed plot multiple trajectories simultaneously. n_bins number pseudotime bins/windows used smooth MEs harmonized logical determining whether use harmonized MEs point_size size points plot line_size width lines plot se logical determining whether show standard error plot group_colors optional list colors differentiate multiple pseudotime trajectories. Must length pseudotime_col wgcna_name name hdWGCNA experiment seurat_obj@misc slot n_col number columns different modules plot","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/PlotSoftPowers.html","id":null,"dir":"Reference","previous_headings":"","what":"PlotSoftPowers — PlotSoftPowers","title":"PlotSoftPowers — PlotSoftPowers","text":"Plot Soft Power Threshold results","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/PlotSoftPowers.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"PlotSoftPowers — PlotSoftPowers","text":"","code":"PlotSoftPowers(   seurat_obj,   selected_power = NULL,   point_size = 5,   text_size = 3,   plot_connectivity = TRUE,   wgcna_name = NULL )"},{"path":"https://smorabit.github.io/hdWGCNA/reference/PlotSoftPowers.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"PlotSoftPowers — PlotSoftPowers","text":"seurat_obj Seurat object selected_power power highlight plots point_size size points plot text_size size text plot plot_connectivity logical indicating whether plot connectivity addition scale free topplogy fit. wgcna_name name WGCNA experiment seurat_obj","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/PlotSoftPowers.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"PlotSoftPowers — PlotSoftPowers","text":"","code":"PlotSoftPowers #> function (seurat_obj, selected_power = NULL, point_size = 5,  #>     text_size = 3, plot_connectivity = TRUE, wgcna_name = NULL)  #> { #>     if (is.null(wgcna_name)) { #>         wgcna_name <- seurat_obj@misc$active_wgcna #>     } #>     pt <- GetPowerTable(seurat_obj, wgcna_name) #>     if (\"group\" %in% colnames(pt)) { #>         print(\"here\") #>         power_tables <- pt %>% dplyr::group_split(group) #>         soft_powers <- sapply(power_tables, function(power_table) { #>             power_table %>% subset(SFT.R.sq >= 0.8) %>% .$Power %>%  #>                 min #>         }) #>     } #>     else { #>         if (is.null(selected_power)) { #>             soft_power <- pt %>% subset(SFT.R.sq >= 0.8) %>%  #>                 .$Power %>% min #>         } #>         else { #>             soft_power <- selected_power #>         } #>         soft_powers <- NULL #>         power_tables <- list(power = pt) #>     } #>     plot_list <- list() #>     for (i in 1:length(power_tables)) { #>         pt <- power_tables[[i]] #>         if (!is.null(soft_powers)) { #>             soft_power <- soft_powers[i] #>             print(i) #>             print(soft_power) #>             pt <- pt %>% dplyr::select(-group) #>         } #>         print(head(pt)) #>         sft_r <- as.numeric(pt[pt$Power == soft_power, \"SFT.R.sq\"]) #>         mean_k <- as.numeric(pt[pt$Power == soft_power, \"mean.k.\"]) #>         median_k <- as.numeric(pt[pt$Power == soft_power, \"median.k.\"]) #>         max_k <- as.numeric(pt[pt$Power == soft_power, \"max.k.\"]) #>         pt$text_color <- ifelse(pt$Power == soft_power, \"white\",  #>             \"black\") #>         p1 <- pt %>% ggplot(aes(x = Power, y = SFT.R.sq)) + geom_rect(data = pt[1,  #>             ], aes(xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = 0.8),  #>             fill = \"grey80\", alpha = 0.8, color = NA) + geom_hline(yintercept = sft_r,  #>             linetype = \"dashed\") + geom_vline(xintercept = soft_power,  #>             linetype = \"dashed\") + geom_point(data = pt[pt$Power ==  #>             soft_power, c(\"Power\", \"SFT.R.sq\")], aes(x = Power,  #>             y = SFT.R.sq), inherit.aes = FALSE, color = \"black\",  #>             size = point_size) + geom_text(label = pt$Power,  #>             color = pt$text_color, size = text_size) + scale_y_continuous(limits = c(0,  #>             1), breaks = c(0, 0.2, 0.4, 0.6, 0.8, 1)) + ylab(\"Scale-free Topology Model Fit\") +  #>             xlab(\"Soft Power Threshold\") + theme(axis.line.x = element_blank(),  #>             axis.line.y = element_blank(), panel.border = element_rect(colour = \"black\",  #>                 fill = NA, size = 1)) #>         if (plot_connectivity) { #>             p2 <- pt %>% ggplot(aes(x = Power, y = mean.k.)) +  #>                 geom_hline(yintercept = mean_k, linetype = \"dashed\") +  #>                 geom_vline(xintercept = soft_power, linetype = \"dashed\") +  #>                 geom_point(data = pt[pt$Power == soft_power,  #>                   c(\"Power\", \"mean.k.\")], aes(x = Power, y = mean.k.),  #>                   inherit.aes = FALSE, color = \"black\", size = point_size) +  #>                 geom_text(label = pt$Power, color = pt$text_color,  #>                   size = text_size) + scale_y_continuous(labels = scales::comma) +  #>                 ylab(\"Mean Connectivity\") + xlab(\"Soft Power Threshold\") +  #>                 theme(axis.line.x = element_blank(), axis.line.y = element_blank(),  #>                   panel.border = element_rect(colour = \"black\",  #>                     fill = NA, size = 1)) #>             p3 <- pt %>% ggplot(aes(x = Power, y = median.k.)) +  #>                 geom_hline(yintercept = median_k, linetype = \"dashed\") +  #>                 geom_vline(xintercept = soft_power, linetype = \"dashed\") +  #>                 geom_point(data = pt[pt$Power == soft_power,  #>                   c(\"Power\", \"median.k.\")], aes(x = Power, y = median.k.),  #>                   inherit.aes = FALSE, color = \"black\", size = point_size) +  #>                 geom_text(label = pt$Power, color = pt$text_color,  #>                   size = text_size) + scale_y_continuous(labels = scales::comma) +  #>                 ylab(\"Median Connectivity\") + xlab(\"Soft Power Threshold\") +  #>                 theme(axis.line.x = element_blank(), axis.line.y = element_blank(),  #>                   panel.border = element_rect(colour = \"black\",  #>                     fill = NA, size = 1)) #>             p4 <- pt %>% ggplot(aes(x = Power, y = max.k.)) +  #>                 geom_hline(yintercept = max_k, linetype = \"dashed\") +  #>                 geom_vline(xintercept = soft_power, linetype = \"dashed\") +  #>                 geom_point(data = pt[pt$Power == soft_power,  #>                   c(\"Power\", \"max.k.\")], aes(x = Power, y = max.k.),  #>                   inherit.aes = FALSE, color = \"black\", size = point_size) +  #>                 geom_text(label = pt$Power, color = pt$text_color,  #>                   size = text_size) + scale_y_continuous(labels = scales::comma) +  #>                 ylab(\"Max Connectivity\") + xlab(\"Soft Power Threshold\") +  #>                 theme(axis.line.x = element_blank(), axis.line.y = element_blank(),  #>                   panel.border = element_rect(colour = \"black\",  #>                     fill = NA, size = 1)) #>             plot_list[[i]] <- list(p1, p2, p3, p4) #>         } #>         else { #>             plot_list[[i]] <- p1 #>         } #>     } #>     if (length(plot_list) == 1) { #>         return(plot_list[[1]]) #>     } #>     plot_list #> } #> <bytecode: 0x7f963b5f7e80> #> <environment: namespace:hdWGCNA>"},{"path":"https://smorabit.github.io/hdWGCNA/reference/ProjectModules.html","id":null,"dir":"Reference","previous_headings":"","what":"ProjectModules — ProjectModules","title":"ProjectModules — ProjectModules","text":"Project set co-expression modules reference query dataset","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/ProjectModules.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"ProjectModules — ProjectModules","text":"","code":"ProjectModules(   seurat_obj,   seurat_ref,   modules = NULL,   group.by.vars = NULL,   gene_mapping = NULL,   genome1_col = NULL,   genome2_col = NULL,   overlap_proportion = 0.5,   vars.to.regress = NULL,   scale.model.use = \"linear\",   wgcna_name = NULL,   wgcna_name_proj = NULL,   ... )"},{"path":"https://smorabit.github.io/hdWGCNA/reference/ProjectModules.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"ProjectModules — ProjectModules","text":"seurat_obj Seurat object modules projected seurat_ref Seurat object containing co-expression modules projected modules optionally provide dataframe containing gene-module information bypass seurat_ref group..vars groups harmonize gene_mapping dataframe map gene names genomes genome1_col column gene_mapping containing genes seurat_ref (reference) genome2_col column gene_mapping containing genes seurat_obj (query) overlap_proportion proportion genes must present seurat_obj given module projected. Default = 0.5 (50% genes) vars..regress character vector variables seurat_obj@meta.data regress running ScaleData scale.model.use model scale data running ScaleData choices \"linear\", \"poisson\", \"negbinom\" wgcna_name name hdWGCNA experiment seurat_ref@misc slot wgcna_name_proj name hdWGCNA experiment created projected modules seurat_obj","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/ProjectModules.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"ProjectModules — ProjectModules","text":"","code":"ProjectModules #> function (seurat_obj, seurat_ref, modules = NULL, group.by.vars = NULL,  #>     gene_mapping = NULL, genome1_col = NULL, genome2_col = NULL,  #>     overlap_proportion = 0.5, vars.to.regress = NULL, scale.model.use = \"linear\",  #>     wgcna_name = NULL, wgcna_name_proj = NULL, ...)  #> { #>     if (is.null(wgcna_name)) { #>         wgcna_name <- seurat_ref@misc$active_wgcna #>     } #>     CheckWGCNAName(seurat_ref, wgcna_name) #>     if (is.null(modules)) { #>         modules <- GetModules(seurat_ref, wgcna_name) #>     } #>     else { #>         if (!all(c(\"gene_name\", \"module\", \"color\") %in% colnames(modules))) { #>             stop(\"Missing columns in modules table. Required columns are gene_name, module, color\") #>         } #>     } #>     if (!is.factor(modules$module)) { #>         modules$module <- as.factor(modules$module) #>     } #>     if (!is.null(gene_mapping)) { #>         modules <- TransferModuleGenome(modules, gene_mapping,  #>             genome1_col, genome2_col) #>     } #>     mods <- as.character(unique(modules$module)) #>     mod_props <- unlist(lapply(mods, function(x) { #>         cur_mod <- subset(modules, module == x) #>         sum(cur_mod$gene_name %in% rownames(seurat_obj))/nrow(cur_mod) #>     })) #>     mods_keep <- mods[mod_props >= overlap_proportion] #>     mods_remove <- mods[mod_props < overlap_proportion] #>     if (length(mods) > 0) { #>         warning(paste0(\"The following modules will not be projected because too few genes are present in seurat_obj: \",  #>             paste(mods_remove, collapse = \", \"))) #>     } #>     modules <- subset(modules, module %in% mods_keep) %>% dplyr::mutate(module = droplevels(module)) #>     gene_names <- modules$gene_name #>     genes_use <- intersect(gene_names, rownames(seurat_obj)) #>     modules <- modules %>% subset(gene_name %in% genes_use) #>     if (!(wgcna_name_proj %in% names(seurat_obj@misc))) { #>         seurat_obj <- SetupForWGCNA(seurat_obj, wgcna_name = wgcna_name_proj,  #>             features = genes_use) #>     } #>     print(\"project modules\") #>     seurat_obj <- ModuleEigengenes(seurat_obj, group.by.vars = group.by.vars,  #>         modules = modules, vars.to.regress = vars.to.regress,  #>         scale.model.use = scale.model.use, wgcna_name = wgcna_name_proj,  #>         ...) #>     seurat_obj #> } #> <bytecode: 0x7f962ba3abf0> #> <environment: namespace:hdWGCNA>"},{"path":"https://smorabit.github.io/hdWGCNA/reference/ReassignModules.html","id":null,"dir":"Reference","previous_headings":"","what":"ReassignModules — ReassignModules","title":"ReassignModules — ReassignModules","text":"Reassigns features different modules","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/ReassignModules.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"ReassignModules — ReassignModules","text":"","code":"ReassignModules(   seurat_obj,   harmonized = TRUE,   features = NULL,   new_modules = NULL,   ignore = FALSE,   wgcna_name = NULL )"},{"path":"https://smorabit.github.io/hdWGCNA/reference/ReassignModules.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"ReassignModules — ReassignModules","text":"seurat_obj Seurat object harmonized logical indicating whether use harmonized MEs features character vector containing features manual module reassignment, new_modules character vector containing modules reassign genes ignore logical indicating whether ignore error message reassigning non-grey features wgcna_name name hdWGCNA experiment seurat_obj@misc slot","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/ReassignModules.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"ReassignModules — ReassignModules","text":"seurat_obj updated modules table selected wgcna experiment","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/ReassignModules.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"ReassignModules — ReassignModules","text":"ReassignModules reassigns features negative kMEs assigned module module highest kME feature. Alternatively, function can manually assign features different modules, can helpful certain genes interest assigned grey module. generally advise reassigning features new modules non-grey modules, user can risk setting ignore=TRUE.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/RegulonBarPlot.html","id":null,"dir":"Reference","previous_headings":"","what":"RegulonBarPlot — RegulonBarPlot","title":"RegulonBarPlot — RegulonBarPlot","text":"Plots top target genes within specific TF regulon","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/RegulonBarPlot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"RegulonBarPlot — RegulonBarPlot","text":"","code":"RegulonBarPlot(   seurat_obj,   selected_tf,   cutoff = 0.2,   top_n = Inf,   TFs_only = FALSE,   high_color = \"orange2\",   mid_color = \"white\",   low_color = \"dodgerblue\",   wgcna_name = NULL )"},{"path":"https://smorabit.github.io/hdWGCNA/reference/RegulonBarPlot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"RegulonBarPlot — RegulonBarPlot","text":"seurat_obj Seurat object cutoff Cutoff edge weights, links value included. top_n Number top bottom target genes include plot. TFs_only Logical indicating whether use TFs plot use TFs genes. high_color Color corresponding positive edge weights mid_color Color corresponding edge weights close 0 low_color Color corresponding negative edge weights wgcna_name name hdWGCNA experiment seurat_obj@misc slot selected_tfs TF whose target genes shown","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/RegulonBarPlot.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"RegulonBarPlot — RegulonBarPlot","text":"ggplot object containing RegulonBarPlot","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/RegulonBarPlot.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"RegulonBarPlot — RegulonBarPlot","text":"RegulonBarPlot creates bar plot showing top target genes particular TF based TF regulatory network analysis. Target genes ranked predicted interaction strength XGBoost (Gain) multiplied sign correlation TF target gene.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/RegulonScores.html","id":null,"dir":"Reference","previous_headings":"","what":"RegulonScores — RegulonScores","title":"RegulonScores — RegulonScores","text":"Calculate expression scores TF Regulons","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/RegulonScores.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"RegulonScores — RegulonScores","text":"","code":"RegulonScores(   seurat_obj,   target_type = \"positive\",   cor_thresh = 0.05,   exclude_grey_genes = TRUE,   wgcna_name = NULL,   ... )"},{"path":"https://smorabit.github.io/hdWGCNA/reference/RegulonScores.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"RegulonScores — RegulonScores","text":"seurat_obj Seurat object target_type types TF target genes compute scores ? \"positive\", \"negative\", \"\" cor_thresh threshold TF-gene correlation genes included regulon score exclude_grey_genes option exclude genes grey module regulon scores wgcna_name name WGCNA experiment","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/RegulonScores.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"RegulonScores — RegulonScores","text":"seurat_obj TF Regulon Scores added","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/RegulonScores.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"RegulonScores — RegulonScores","text":"RegulonScores calculates expression signatures TF regulon using UCell algorithm function can calculate separate scores TF regulons target genes positively negatively correlated TF, representing putative acivated repressed genes. scores conveniently summarize expression levels entire TF regulon, similar module eigengenes co-expression network analyssis.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/ResetModuleColors.html","id":null,"dir":"Reference","previous_headings":"","what":"ResetModuleColors — ResetModuleColors","title":"ResetModuleColors — ResetModuleColors","text":"Reset unique color hdWGCNA module","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/ResetModuleColors.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"ResetModuleColors — ResetModuleColors","text":"","code":"ResetModuleColors(seurat_obj, new_colors, wgcna_name = NULL)"},{"path":"https://smorabit.github.io/hdWGCNA/reference/ResetModuleColors.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"ResetModuleColors — ResetModuleColors","text":"seurat_obj Seurat object new_colors character vector containing new colors wgcna_name name hdWGCNA experiment seurat_obj@misc slot","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/ResetModuleNames.html","id":null,"dir":"Reference","previous_headings":"","what":"ResetModuleNames — ResetModuleNames","title":"ResetModuleNames — ResetModuleNames","text":"Reset uname hdWGCNA module","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/ResetModuleNames.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"ResetModuleNames — ResetModuleNames","text":"","code":"ResetModuleNames(   seurat_obj,   new_name = \"M\",   reset_levels = FALSE,   wgcna_name = NULL )"},{"path":"https://smorabit.github.io/hdWGCNA/reference/ResetModuleNames.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"ResetModuleNames — ResetModuleNames","text":"seurat_obj Seurat object new_name string containing base name re-name modules wgcna_name name hdWGCNA experiment seurat_obj@misc slot","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/RunEnrichr.html","id":null,"dir":"Reference","previous_headings":"","what":"RunEnrichr — RunEnrichr","title":"RunEnrichr — RunEnrichr","text":"Run Enrichr gene set enrichment tests hdWGCNA modules","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/RunEnrichr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"RunEnrichr — RunEnrichr","text":"","code":"RunEnrichr(   seurat_obj,   dbs = c(\"GO_Biological_Process_2021\", \"GO_Cellular_Component_2021\",     \"GO_Molecular_Function_2021\"),   max_genes = 100,   wait = TRUE,   wait_time = 5,   wgcna_name = NULL,   ... )"},{"path":"https://smorabit.github.io/hdWGCNA/reference/RunEnrichr.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"RunEnrichr — RunEnrichr","text":"seurat_obj Seurat object dbs character vector EnrichR databases max_genes Max number genes include per module, ranked kME. wait logical indicating whether wait time sending requests EnrichR server. wait_time number seconds wait sending requests EnrichR server. Value must less 60. wgcna_name name hdWGCNA experiment seurat_obj@misc slot","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/RunEnrichrRegulons.html","id":null,"dir":"Reference","previous_headings":"","what":"RunEnrichrRegulons — RunEnrichrRegulons","title":"RunEnrichrRegulons — RunEnrichrRegulons","text":"Run Enrichr gene set enrichment tests hdWGCNA modules","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/RunEnrichrRegulons.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"RunEnrichrRegulons — RunEnrichrRegulons","text":"","code":"RunEnrichrRegulons(   seurat_obj,   dbs = c(\"GO_Biological_Process_2021\", \"GO_Cellular_Component_2021\",     \"GO_Molecular_Function_2021\"),   depth = 1,   use_regulons = TRUE,   min_genes = 5,   wait = TRUE,   wait_time = 5,   wgcna_name = NULL,   ... )"},{"path":"https://smorabit.github.io/hdWGCNA/reference/RunEnrichrRegulons.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"RunEnrichrRegulons — RunEnrichrRegulons","text":"seurat_obj Seurat object dbs character vector EnrichR databases wait logical indicating whether wait time sending requests EnrichR server. wait_time number seconds wait sending requests EnrichR server. Value must less 60. wgcna_name name hdWGCNA experiment seurat_obj@misc slot max_genes Max number genes include per module, ranked kME.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/RunHarmonyMetacells.html","id":null,"dir":"Reference","previous_headings":"","what":"RunHarmonyMetacells — RunHarmonyMetacells","title":"RunHarmonyMetacells — RunHarmonyMetacells","text":"Wrapper function run harmony's RunHarmony function metacell object.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/RunHarmonyMetacells.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"RunHarmonyMetacells — RunHarmonyMetacells","text":"","code":"RunHarmonyMetacells(seurat_obj, ...)"},{"path":"https://smorabit.github.io/hdWGCNA/reference/RunHarmonyMetacells.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"RunHarmonyMetacells — RunHarmonyMetacells","text":"seurat_obj Seurat object","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/RunModuleUMAP.html","id":null,"dir":"Reference","previous_headings":"","what":"RunModuleUMAP — RunModuleUMAP","title":"RunModuleUMAP — RunModuleUMAP","text":"Run UMAP co-expression matrix using hub genes features.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/RunModuleUMAP.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"RunModuleUMAP — RunModuleUMAP","text":"","code":"RunModuleUMAP(   seurat_obj,   n_hubs = 10,   exclude_grey = TRUE,   genes_use = NULL,   wgcna_name = NULL,   n_neighbors = 25,   metric = \"cosine\",   spread = 1,   min_dist = 0.4,   supervised = FALSE,   ... )"},{"path":"https://smorabit.github.io/hdWGCNA/reference/RunModuleUMAP.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"RunModuleUMAP — RunModuleUMAP","text":"seurat_obj Seurat object n_hubs number hub genes use UMAP computation exclude_grey logical indicating whether include grey module genes_use character vector genes use UMAP, must already present GetModules(seurat_obj) wgcna_name name hdWGCNA experiment seurat_obj@misc slot ... Additional parameters supplied uwot::umap","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/RunPCAMetacells.html","id":null,"dir":"Reference","previous_headings":"","what":"RunPCAMetacells — RunPCAMetacells","title":"RunPCAMetacells — RunPCAMetacells","text":"Wrapper function run Seurat's RunPCA function metacell object.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/RunPCAMetacells.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"RunPCAMetacells — RunPCAMetacells","text":"","code":"RunPCAMetacells(seurat_obj, wgcna_name = NULL, ...)"},{"path":"https://smorabit.github.io/hdWGCNA/reference/RunPCAMetacells.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"RunPCAMetacells — RunPCAMetacells","text":"seurat_obj Seurat object","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/RunUMAPMetacells.html","id":null,"dir":"Reference","previous_headings":"","what":"RunUMAPMetacells — RunUMAPMetacells","title":"RunUMAPMetacells — RunUMAPMetacells","text":"Wrapper function run Seurat's RunUMAP function metacell object.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/RunUMAPMetacells.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"RunUMAPMetacells — RunUMAPMetacells","text":"","code":"RunUMAPMetacells(seurat_obj, ...)"},{"path":"https://smorabit.github.io/hdWGCNA/reference/RunUMAPMetacells.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"RunUMAPMetacells — RunUMAPMetacells","text":"seurat_obj Seurat object","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/ScaleMetacells.html","id":null,"dir":"Reference","previous_headings":"","what":"ScaleMetacells — ScaleMetacells","title":"ScaleMetacells — ScaleMetacells","text":"Wrapper function run Seurat's ScaleData function metacell object.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/ScaleMetacells.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"ScaleMetacells — ScaleMetacells","text":"","code":"ScaleMetacells(seurat_obj, wgcna_name = NULL, ...)"},{"path":"https://smorabit.github.io/hdWGCNA/reference/ScaleMetacells.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"ScaleMetacells — ScaleMetacells","text":"seurat_obj Seurat object","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/SelectNetworkGenes.html","id":null,"dir":"Reference","previous_headings":"","what":"SelectNetworkGenes — SelectNetworkGenes","title":"SelectNetworkGenes — SelectNetworkGenes","text":"Select genes used co-expression network analysis","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/SelectNetworkGenes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"SelectNetworkGenes — SelectNetworkGenes","text":"","code":"SelectNetworkGenes(   seurat_obj,   gene_select = \"variable\",   fraction = 0.05,   group.by = NULL,   gene_list = NULL,   assay = NULL,   wgcna_name = NULL )"},{"path":"https://smorabit.github.io/hdWGCNA/reference/SelectNetworkGenes.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"SelectNetworkGenes — SelectNetworkGenes","text":"seurat_obj Seurat object fraction numeric determines minimum cells gene must expressed order included. example, fraction = 0.05 means 5% cells must express gene (count > 0) included. gene_list character string gene names, used type = \"custom\" assay Assay seurat_obj compute module eigengenes. Default DefaultAssay(seurat_obj) wgcna_name name WGCNA experiment type select genes? Select \"variable\", \"fraction\", \"\", \"custom\".","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/SelectNetworkGenes.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"SelectNetworkGenes — SelectNetworkGenes","text":"SelectNetworkGenes allows us specify genes used co-expression network analysis. function called SetupForWGCNA. default, variable features VariableFeatures(seurat_obj) used. custom gene list can also used gene_list parameter setting gene_select=\"custom\". can also identify genes expressed 0 certain proportion dataset settting gene_select='fraction'. example, setting fraction=0.1 group.='seurat_clusters', function identify set genes expressed 10% cells least one clusters.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/SetActiveWGCNA.html","id":null,"dir":"Reference","previous_headings":"","what":"SetActiveWGCNA — SetActiveWGCNA","title":"SetActiveWGCNA — SetActiveWGCNA","text":"SetActiveWGCNA","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/SetActiveWGCNA.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"SetActiveWGCNA — SetActiveWGCNA","text":"","code":"SetActiveWGCNA(seurat_obj, wgcna_name)"},{"path":"https://smorabit.github.io/hdWGCNA/reference/SetActiveWGCNA.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"SetActiveWGCNA — SetActiveWGCNA","text":"seurat_obj Seurat object wgcna_name name hdWGCNA experiment seurat_obj@misc slot","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/SetAvgModuleExpr.html","id":null,"dir":"Reference","previous_headings":"","what":"SetAvgModuleExpr — SetAvgModuleExpr","title":"SetAvgModuleExpr — SetAvgModuleExpr","text":"SetAvgModuleExpr","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/SetAvgModuleExpr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"SetAvgModuleExpr — SetAvgModuleExpr","text":"","code":"SetAvgModuleExpr(seurat_obj, avg_mods, wgcna_name = NULL)"},{"path":"https://smorabit.github.io/hdWGCNA/reference/SetAvgModuleExpr.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"SetAvgModuleExpr — SetAvgModuleExpr","text":"seurat_obj Seurat object avg_mods dataframe storing average expression genes module wgcna_name name hdWGCNA experiment seurat_obj@misc slot","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/SetDatExpr.html","id":null,"dir":"Reference","previous_headings":"","what":"SetDatExpr — SetDatExpr","title":"SetDatExpr — SetDatExpr","text":"function specifies gene expression matrix co-expression network analysis.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/SetDatExpr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"SetDatExpr — SetDatExpr","text":"","code":"SetDatExpr(   seurat_obj,   group_name,   use_metacells = TRUE,   group.by = NULL,   multi.group.by = NULL,   multi_group_name = NULL,   return_seurat = TRUE,   assay = NULL,   slot = \"data\",   layer = \"data\",   mat = NULL,   features = NULL,   wgcna_name = NULL,   ... )"},{"path":"https://smorabit.github.io/hdWGCNA/reference/SetDatExpr.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"SetDatExpr — SetDatExpr","text":"seurat_obj Seurat object group_name string containing group present provided group.column Seurat Idents. character vector can provided select multiple groups time. use_metacells logical determining use metacells (TRUE) full expression matrix (FALSE) group.string containing name column Seurat object cell groups (clusters, cell types, etc). NULL (default), hdWGCNA uses Seurat Idents group. multi.group.string containing name column Seurat object groups consensus WGCNA (dataset, sample, condition, etc) multi_group_name string containing name group present multi.group.column. assay name assay Seurat object slot Slot extract data aggregation. Default = 'counts'. Slot used Seurat v4 instead layer. layer Layer extract data aggregation. Default = 'counts'. Layer used Seurat v5 instead slot. mat Matrix containing gene expression data. Supplying matrix using parameter ignores options. almost exclusively used pseudobulk analysis. features list features use override features previously set. wgcna_name string containing name WGCNA slot seurat_obj@misc. Default = NULL retrieves currently active WGCNA data","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/SetDatExpr.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"SetDatExpr — SetDatExpr","text":"SetDatExpr critical function hdWGCNA pipeline determines gene expession matrix used network analysis. typically use function select cell type group cell types network analysis using group.parameter, provide additional parameters customization.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/SetDegrees.html","id":null,"dir":"Reference","previous_headings":"","what":"SetDegrees — SetDegrees","title":"SetDegrees — SetDegrees","text":"SetDegrees","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/SetDegrees.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"SetDegrees — SetDegrees","text":"","code":"SetDegrees(seurat_obj, degree_df, wgcna_name = NULL)"},{"path":"https://smorabit.github.io/hdWGCNA/reference/SetDegrees.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"SetDegrees — SetDegrees","text":"seurat_obj Seurat object degree_df dataframe containing gene module assignments wgcna_name name hdWGCNA experiment seurat_obj@misc slot","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/SetEnrichrRegulonTable.html","id":null,"dir":"Reference","previous_headings":"","what":"SetEnrichRegulonTable — SetEnrichrRegulonTable","title":"SetEnrichRegulonTable — SetEnrichrRegulonTable","text":"SetEnrichRegulonTable","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/SetEnrichrRegulonTable.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"SetEnrichRegulonTable — SetEnrichrRegulonTable","text":"","code":"SetEnrichrRegulonTable(seurat_obj, enrich_table, wgcna_name = NULL)"},{"path":"https://smorabit.github.io/hdWGCNA/reference/SetEnrichrRegulonTable.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"SetEnrichRegulonTable — SetEnrichrRegulonTable","text":"seurat_obj Seurat object enrich_table dataframe storing results running enrichr wgcna_name name hdWGCNA experiment seurat_obj@misc slot","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/SetEnrichrTable.html","id":null,"dir":"Reference","previous_headings":"","what":"SetEnrichrTable — SetEnrichrTable","title":"SetEnrichrTable — SetEnrichrTable","text":"SetEnrichrTable","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/SetEnrichrTable.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"SetEnrichrTable — SetEnrichrTable","text":"","code":"SetEnrichrTable(seurat_obj, enrich_table, wgcna_name = NULL)"},{"path":"https://smorabit.github.io/hdWGCNA/reference/SetEnrichrTable.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"SetEnrichrTable — SetEnrichrTable","text":"seurat_obj Seurat object enrich_table dataframe storing results running enrichr wgcna_name name hdWGCNA experiment seurat_obj@misc slot","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/SetMELoadings.html","id":null,"dir":"Reference","previous_headings":"","what":"SetMELoadings — SetMELoadings","title":"SetMELoadings — SetMELoadings","text":"SetMELoadings","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/SetMELoadings.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"SetMELoadings — SetMELoadings","text":"","code":"SetMELoadings(seurat_obj, loadings, harmonized = TRUE, wgcna_name = NULL)"},{"path":"https://smorabit.github.io/hdWGCNA/reference/SetMELoadings.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"SetMELoadings — SetMELoadings","text":"seurat_obj Seurat object loadings named numeric vector eigengene loadings harmonized logical indicating whether MEs harmonized wgcna_name name hdWGCNA experiment seurat_obj@misc slot","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/SetMEs.html","id":null,"dir":"Reference","previous_headings":"","what":"SetMEs — SetMEs","title":"SetMEs — SetMEs","text":"SetMEs","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/SetMEs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"SetMEs — SetMEs","text":"","code":"SetMEs(seurat_obj, MEs, harmonized = TRUE, wgcna_name = NULL)"},{"path":"https://smorabit.github.io/hdWGCNA/reference/SetMEs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"SetMEs — SetMEs","text":"seurat_obj Seurat object MEs dataframe matrix containing module eigengenes harmonized logical indicating whether MEs harmonized wgcna_name name hdWGCNA experiment seurat_obj@misc slot","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/SetMetacellObject.html","id":null,"dir":"Reference","previous_headings":"","what":"SetMetacellObject — SetMetacellObject","title":"SetMetacellObject — SetMetacellObject","text":"SetMetacellObject","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/SetMetacellObject.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"SetMetacellObject — SetMetacellObject","text":"","code":"SetMetacellObject(seurat_obj, metacell_obj, wgcna_name = NULL)"},{"path":"https://smorabit.github.io/hdWGCNA/reference/SetMetacellObject.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"SetMetacellObject — SetMetacellObject","text":"seurat_obj Seurat object metacell_obj metacell Seurat object wgcna_name name hdWGCNA experiment seurat_obj@misc slot","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/SetMetacellParams.html","id":null,"dir":"Reference","previous_headings":"","what":"SetMetacellParams — SetMetacellParams","title":"SetMetacellParams — SetMetacellParams","text":"SetMetacellParams","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/SetMetacellParams.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"SetMetacellParams — SetMetacellParams","text":"","code":"SetMetacellParams(seurat_obj, params, wgcna_name = NULL)"},{"path":"https://smorabit.github.io/hdWGCNA/reference/SetMetacellParams.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"SetMetacellParams — SetMetacellParams","text":"seurat_obj Seurat object params list WGCNA parameters wgcna_name name hdWGCNA experiment seurat_obj@misc slot","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/SetModulePreservation.html","id":null,"dir":"Reference","previous_headings":"","what":"SetModulePreservation — SetModulePreservation","title":"SetModulePreservation — SetModulePreservation","text":"SetModulePreservation","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/SetModulePreservation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"SetModulePreservation — SetModulePreservation","text":"","code":"SetModulePreservation(seurat_obj, mod_pres, mod_name, wgcna_name = NULL)"},{"path":"https://smorabit.github.io/hdWGCNA/reference/SetModulePreservation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"SetModulePreservation — SetModulePreservation","text":"seurat_obj Seurat object mod_name name module preservation test store wgcna_name name hdWGCNA experiment seurat_obj@misc slot mt_cor matrix module-trait correlation results","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/SetModuleScores.html","id":null,"dir":"Reference","previous_headings":"","what":"SetModuleScores — SetModuleScores","title":"SetModuleScores — SetModuleScores","text":"SetModuleScores","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/SetModuleScores.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"SetModuleScores — SetModuleScores","text":"","code":"SetModuleScores(seurat_obj, mod_scores, wgcna_name = NULL)"},{"path":"https://smorabit.github.io/hdWGCNA/reference/SetModuleScores.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"SetModuleScores — SetModuleScores","text":"seurat_obj Seurat object mod_scores dataframe storing module expression scores wgcna_name name hdWGCNA experiment seurat_obj@misc slot","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/SetModuleTraitCorrelation.html","id":null,"dir":"Reference","previous_headings":"","what":"SetModuleTraitCorrelation — SetModuleTraitCorrelation","title":"SetModuleTraitCorrelation — SetModuleTraitCorrelation","text":"SetModuleTraitCorrelation","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/SetModuleTraitCorrelation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"SetModuleTraitCorrelation — SetModuleTraitCorrelation","text":"","code":"SetModuleTraitCorrelation(seurat_obj, mt_cor, wgcna_name = NULL)"},{"path":"https://smorabit.github.io/hdWGCNA/reference/SetModuleTraitCorrelation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"SetModuleTraitCorrelation — SetModuleTraitCorrelation","text":"seurat_obj Seurat object mt_cor matrix module-trait correlation results wgcna_name name hdWGCNA experiment seurat_obj@misc slot","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/SetModuleUMAP.html","id":null,"dir":"Reference","previous_headings":"","what":"SetModuleUMAP — SetModuleUMAP","title":"SetModuleUMAP — SetModuleUMAP","text":"SetModuleUMAP","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/SetModuleUMAP.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"SetModuleUMAP — SetModuleUMAP","text":"","code":"SetModuleUMAP(seurat_obj, umap_df, wgcna_name = NULL)"},{"path":"https://smorabit.github.io/hdWGCNA/reference/SetModuleUMAP.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"SetModuleUMAP — SetModuleUMAP","text":"seurat_obj Seurat object umap_df dataframe UMAP coordinates wgcna_name name hdWGCNA experiment seurat_obj@misc slot","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/SetModules.html","id":null,"dir":"Reference","previous_headings":"","what":"SetModules — SetModules","title":"SetModules — SetModules","text":"SetModules","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/SetModules.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"SetModules — SetModules","text":"","code":"SetModules(seurat_obj, modules, wgcna_name = NULL)"},{"path":"https://smorabit.github.io/hdWGCNA/reference/SetModules.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"SetModules — SetModules","text":"seurat_obj Seurat object modules dataframe containing gene module assignments wgcna_name name hdWGCNA experiment seurat_obj@misc slot","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/SetMotifMatrix.html","id":null,"dir":"Reference","previous_headings":"","what":"SetMotifMatrix — SetMotifMatrix","title":"SetMotifMatrix — SetMotifMatrix","text":"SetMotifMatrix","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/SetMotifMatrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"SetMotifMatrix — SetMotifMatrix","text":"","code":"SetMotifMatrix(seurat_obj, tf_match)"},{"path":"https://smorabit.github.io/hdWGCNA/reference/SetMotifMatrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"SetMotifMatrix — SetMotifMatrix","text":"seurat_obj Seurat object tf_match matrix containing tf-promoter matches","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/SetMotifMatrix.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"SetMotifMatrix — SetMotifMatrix","text":"","code":"SetMotifMatrix #> function (seurat_obj, tf_match)  #> { #>     if (is.null(seurat_obj@misc$motifs)) { #>         seurat_obj@misc$motifs <- list() #>     } #>     seurat_obj@misc$motifs$tf_match_matrix <- tf_match #>     seurat_obj #> } #> <bytecode: 0x7f963a8ef2d8> #> <environment: namespace:hdWGCNA>"},{"path":"https://smorabit.github.io/hdWGCNA/reference/SetMotifOverlap.html","id":null,"dir":"Reference","previous_headings":"","what":"SetMotifOverlap — SetMotifOverlap","title":"SetMotifOverlap — SetMotifOverlap","text":"SetMotifOverlap","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/SetMotifOverlap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"SetMotifOverlap — SetMotifOverlap","text":"","code":"SetMotifOverlap(seurat_obj, overlap_df, wgcna_name = NULL)"},{"path":"https://smorabit.github.io/hdWGCNA/reference/SetMotifOverlap.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"SetMotifOverlap — SetMotifOverlap","text":"seurat_obj Seurat object overlap_df dataframe containing motif-module overlap info wgcna_name name hdWGCNA experiment seurat_obj@misc slot","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/SetMotifScores.html","id":null,"dir":"Reference","previous_headings":"","what":"SetMotifScores — SetMotifScores","title":"SetMotifScores — SetMotifScores","text":"SetMotifScores","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/SetMotifScores.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"SetMotifScores — SetMotifScores","text":"","code":"SetMotifScores(seurat_obj, tf_scores, wgcna_name = NULL)"},{"path":"https://smorabit.github.io/hdWGCNA/reference/SetMotifScores.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"SetMotifScores — SetMotifScores","text":"seurat_obj Seurat object tf_scores dataframe tf motif target scores wgcna_name name hdWGCNA experiment seurat_obj@misc slot","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/SetMotifTargets.html","id":null,"dir":"Reference","previous_headings":"","what":"SetMotifTargets — SetMotifTargets","title":"SetMotifTargets — SetMotifTargets","text":"SetMotifTargets","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/SetMotifTargets.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"SetMotifTargets — SetMotifTargets","text":"","code":"SetMotifTargets(seurat_obj, motif_targets)"},{"path":"https://smorabit.github.io/hdWGCNA/reference/SetMotifTargets.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"SetMotifTargets — SetMotifTargets","text":"seurat_obj Seurat object motif_targets list motifs target genes","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/SetMotifTargets.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"SetMotifTargets — SetMotifTargets","text":"","code":"SetMotifTargets #> function (seurat_obj, motif_targets)  #> { #>     if (is.null(seurat_obj@misc$motifs)) { #>         seurat_obj@misc$motifs <- list() #>     } #>     seurat_obj@misc$motifs$motif_targets <- motif_targets #>     seurat_obj #> } #> <bytecode: 0x7f961312e078> #> <environment: namespace:hdWGCNA>"},{"path":"https://smorabit.github.io/hdWGCNA/reference/SetMotifs.html","id":null,"dir":"Reference","previous_headings":"","what":"SetMotifs — SetMotifs","title":"SetMotifs — SetMotifs","text":"SetMotifs","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/SetMotifs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"SetMotifs — SetMotifs","text":"","code":"SetMotifs(seurat_obj, motif_df)"},{"path":"https://smorabit.github.io/hdWGCNA/reference/SetMotifs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"SetMotifs — SetMotifs","text":"seurat_obj Seurat object motif_df dataframe containing info motifs analyzed","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/SetMotifs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"SetMotifs — SetMotifs","text":"","code":"SetMotifs #> function (seurat_obj, motif_df)  #> { #>     if (is.null(seurat_obj@misc$motifs)) { #>         seurat_obj@misc$motifs <- list() #>     } #>     seurat_obj@misc$motifs$motif_df <- motif_df #>     seurat_obj #> } #> <bytecode: 0x7f9613eff030> #> <environment: namespace:hdWGCNA>"},{"path":"https://smorabit.github.io/hdWGCNA/reference/SetMultiExpr.html","id":null,"dir":"Reference","previous_headings":"","what":"SetMultiExpr — SetMultiExpr","title":"SetMultiExpr — SetMultiExpr","text":"function sets expression matrix input consensus WGCNA based metacell expression matrix, full expression matrix, provided pseudobulk expression matrix.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/SetMultiExpr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"SetMultiExpr — SetMultiExpr","text":"","code":"SetMultiExpr(   seurat_obj,   group_name,   use_metacells = TRUE,   group.by = NULL,   multi.group.by = NULL,   multi_groups = NULL,   assay = NULL,   slot = \"data\",   layer = \"data\",   mat = NULL,   mat_group_delim = 3,   wgcna_name = NULL,   ... )"},{"path":"https://smorabit.github.io/hdWGCNA/reference/SetMultiExpr.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"SetMultiExpr — SetMultiExpr","text":"seurat_obj Seurat object group_name string containing group present provided group.column Seurat Idents. use_metacells logical determining use metacells (TRUE) full expression matrix (FALSE) group.string containing name column Seurat object cell groups (clusters, cell types, etc). NULL (default), hdWGCNA uses Seurat Idents group. multi.group.string containing name column Seurat object groups consensus WGCNA (dataset, sample, condition, etc) multi_groups character vecrtor containing names groups select assay name assay Seurat object slot name slot Seurat object (counts, data) layer Layer extract data aggregation. Default = 'counts'. Layer used Seurat v5 instead slot. mat Matrix containing gene expression data. Supplying matrix using parameter ignores options. almost exclusively used pseudobulk analysis. wgcna_name string containing name WGCNA slot seurat_obj@misc. Default = NULL retrieves currently active WGCNA data","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/SetNetworkData.html","id":null,"dir":"Reference","previous_headings":"","what":"SetNetworkData — SetNetworkData","title":"SetNetworkData — SetNetworkData","text":"SetNetworkData","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/SetNetworkData.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"SetNetworkData — SetNetworkData","text":"","code":"SetNetworkData(seurat_obj, net, wgcna_name = NULL)"},{"path":"https://smorabit.github.io/hdWGCNA/reference/SetNetworkData.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"SetNetworkData — SetNetworkData","text":"seurat_obj Seurat object net list network data WGCNA wgcna_name name hdWGCNA experiment seurat_obj@misc slot","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/SetPFMList.html","id":null,"dir":"Reference","previous_headings":"","what":"SetPFMList — SetPFMList","title":"SetPFMList — SetPFMList","text":"SetPFMList","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/SetPFMList.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"SetPFMList — SetPFMList","text":"","code":"SetPFMList(seurat_obj, pfm_list)"},{"path":"https://smorabit.github.io/hdWGCNA/reference/SetPFMList.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"SetPFMList — SetPFMList","text":"seurat_obj Seurat object pfm_list list pfm objects","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/SetPFMList.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"SetPFMList — SetPFMList","text":"","code":"SetPFMList #> function (seurat_obj, pfm_list)  #> { #>     if (is.null(seurat_obj@misc$motifs)) { #>         seurat_obj@misc$motifs <- list() #>     } #>     seurat_obj@misc$motifs$pfm_list <- pfm_list #>     seurat_obj #> } #> <bytecode: 0x7f963ed1b698> #> <environment: namespace:hdWGCNA>"},{"path":"https://smorabit.github.io/hdWGCNA/reference/SetPowerTable.html","id":null,"dir":"Reference","previous_headings":"","what":"SetPowerTable — SetPowerTable","title":"SetPowerTable — SetPowerTable","text":"SetPowerTable","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/SetPowerTable.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"SetPowerTable — SetPowerTable","text":"","code":"SetPowerTable(seurat_obj, power_table, wgcna_name = NULL)"},{"path":"https://smorabit.github.io/hdWGCNA/reference/SetPowerTable.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"SetPowerTable — SetPowerTable","text":"seurat_obj Seurat object power_table dataframe containing results soft power test wgcna_name name hdWGCNA experiment seurat_obj@misc slot","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/SetRegulonScores.html","id":null,"dir":"Reference","previous_headings":"","what":"SetRegulonScores — SetRegulonScores","title":"SetRegulonScores — SetRegulonScores","text":"SetRegulonScores","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/SetRegulonScores.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"SetRegulonScores — SetRegulonScores","text":"","code":"SetRegulonScores(seurat_obj, regulon_scores, target_type, wgcna_name = NULL)"},{"path":"https://smorabit.github.io/hdWGCNA/reference/SetRegulonScores.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"SetRegulonScores — SetRegulonScores","text":"seurat_obj Seurat object regulon_scores dataframe storing TF regulon scores target_type dataframe storing TF regulon scores wgcna_name name hdWGCNA experiment seurat_obj@misc slot","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/SetTFEval.html","id":null,"dir":"Reference","previous_headings":"","what":"SetTFEval — SetTFEval","title":"SetTFEval — SetTFEval","text":"SetTFEval","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/SetTFEval.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"SetTFEval — SetTFEval","text":"","code":"SetTFEval(seurat_obj, tf_eval, wgcna_name = NULL)"},{"path":"https://smorabit.github.io/hdWGCNA/reference/SetTFEval.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"SetTFEval — SetTFEval","text":"seurat_obj Seurat object tf_eval dataframe storing TF network evaluation info ConstructTFNetwork wgcna_name name hdWGCNA experiment seurat_obj@misc slot","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/SetTFNetwork.html","id":null,"dir":"Reference","previous_headings":"","what":"SetTFNetwork — SetTFNetwork","title":"SetTFNetwork — SetTFNetwork","text":"SetTFNetwork","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/SetTFNetwork.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"SetTFNetwork — SetTFNetwork","text":"","code":"SetTFNetwork(seurat_obj, tf_net, wgcna_name = NULL)"},{"path":"https://smorabit.github.io/hdWGCNA/reference/SetTFNetwork.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"SetTFNetwork — SetTFNetwork","text":"seurat_obj Seurat object tf_net dataframe storing TF network info ConstructTFNetwork wgcna_name name hdWGCNA experiment seurat_obj@misc slot","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/SetTFRegulons.html","id":null,"dir":"Reference","previous_headings":"","what":"SetTFRegulons — SetTFRegulons","title":"SetTFRegulons — SetTFRegulons","text":"SetTFRegulons","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/SetTFRegulons.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"SetTFRegulons — SetTFRegulons","text":"","code":"SetTFRegulons(seurat_obj, tf_regulons, wgcna_name = NULL)"},{"path":"https://smorabit.github.io/hdWGCNA/reference/SetTFRegulons.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"SetTFRegulons — SetTFRegulons","text":"seurat_obj Seurat object tf_regulons dataframe storing TF regulon info AssignTFRegulons wgcna_name name hdWGCNA experiment seurat_obj@misc slot","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/SetWGCNAGenes.html","id":null,"dir":"Reference","previous_headings":"","what":"SetWGCNAGenes — SetWGCNAGenes","title":"SetWGCNAGenes — SetWGCNAGenes","text":"SetWGCNAGenes","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/SetWGCNAGenes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"SetWGCNAGenes — SetWGCNAGenes","text":"","code":"SetWGCNAGenes(seurat_obj, gene_list, wgcna_name = NULL)"},{"path":"https://smorabit.github.io/hdWGCNA/reference/SetWGCNAGenes.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"SetWGCNAGenes — SetWGCNAGenes","text":"seurat_obj Seurat object gene_list vector genes used WGCNA wgcna_name name hdWGCNA experiment seurat_obj@misc slot","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/SetWGCNAParams.html","id":null,"dir":"Reference","previous_headings":"","what":"SetWGCNAParams — SetWGCNAParams","title":"SetWGCNAParams — SetWGCNAParams","text":"SetWGCNAParams","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/SetWGCNAParams.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"SetWGCNAParams — SetWGCNAParams","text":"","code":"SetWGCNAParams(seurat_obj, params, wgcna_name = NULL)"},{"path":"https://smorabit.github.io/hdWGCNA/reference/SetWGCNAParams.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"SetWGCNAParams — SetWGCNAParams","text":"seurat_obj Seurat object params list WGCNA parameters wgcna_name name hdWGCNA experiment seurat_obj@misc slot","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/SetupForWGCNA.html","id":null,"dir":"Reference","previous_headings":"","what":"SetupForWGCNA — SetupForWGCNA","title":"SetupForWGCNA — SetupForWGCNA","text":"Create slot Seurat object store hdWGCNA data","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/SetupForWGCNA.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"SetupForWGCNA — SetupForWGCNA","text":"","code":"SetupForWGCNA(   seurat_obj,   wgcna_name,   features = NULL,   metacell_location = NULL,   ... )"},{"path":"https://smorabit.github.io/hdWGCNA/reference/SetupForWGCNA.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"SetupForWGCNA — SetupForWGCNA","text":"seurat_obj Seurat object wgcna_name name WGCNA experiment features list features use WGCNA metacell_location name WGCNA experiment copy metacell object ... additional parameters pass SelectNetworkGenes","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/SetupForWGCNA.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"SetupForWGCNA — SetupForWGCNA","text":"SetupForWGCNA creates new slot Seurat object (seurat_obj) store hdWGCNA experiment given name (wgcna_name). function calls SelectNetworkGenes specify features used network analysis. another hdWGCNA experiment already seurat_obj, metacell/metaspot object can used specifying name hdWGCNA experiment metacell_location parameter.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/TFNetworkPlot.html","id":null,"dir":"Reference","previous_headings":"","what":"TFNetworkPlot — TFNetworkPlot","title":"TFNetworkPlot — TFNetworkPlot","text":"Plots network TFs predicted target genes.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/TFNetworkPlot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"TFNetworkPlot — TFNetworkPlot","text":"","code":"TFNetworkPlot(   seurat_obj,   selected_tfs,   depth = 2,   edge_weight = \"Cor\",   cutoff = 0.01,   color_cutoff = 0.75,   target_type = \"both\",   use_regulons = TRUE,   label_genes = NULL,   label_TFs = 1,   no_labels = FALSE,   TFs_only = FALSE,   high_color = \"orange2\",   mid_color = \"white\",   low_color = \"dodgerblue\",   node_colors = c(\"black\", \"darkorchid4\", \"mediumpurple2\"),   wgcna_name = NULL )"},{"path":"https://smorabit.github.io/hdWGCNA/reference/TFNetworkPlot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"TFNetworkPlot — TFNetworkPlot","text":"seurat_obj Seurat object selected_tfs list TFs depth Number layers extend TF network selected_tfs. example, depth=2 (default), target genes selected_tfs shown, additional target genes shown TFs target genes original selected_tfs. edge_weight Attribute use color network edges. \"Cor\" show pearson correlation, \"Gain\" show importance score XGBoost model. cutoff Cutoff edge weights, links value included. color_cutoff Maximum value colorscale edge weights. target_type Type target genes show network. \"Positive\" shows genes expression positively correlated selected_tfs, \"Negative\" shows genes negatively correlated, \"\" shows (default). use_regulons Logical indicating whether use TF-gene links defined TF Regulons (TRUE, default), putative TF-gene links (FALSE). label_genes List target genes label network plot. label_TFs depth level network plot names TFs. no_labels Logical indicating whether remove labels. TFs_only Logical indicating whether use TFs plot use TFs genes. high_color Color corresponding positive edge weights mid_color Color corresponding edge weights close 0 low_color Color corresponding negative edge weights node_colors List color names TFs genes depth. example, depth=2, supply list 3 colors corresponding selected_tfs (depth 0), primary target genes (depth 1), secondary target genes (depth 2). wgcna_name name hdWGCNA experiment seurat_obj@misc slot","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/TFNetworkPlot.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"TFNetworkPlot — TFNetworkPlot","text":"ggplot object containing TFNetworkPlot","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/TFNetworkPlot.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"TFNetworkPlot — TFNetworkPlot","text":"TFNetworkPlot plots network TFs predicted target genes, based results ConstructTFNetwork.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/TestSoftPowers.html","id":null,"dir":"Reference","previous_headings":"","what":"TestSoftPowers — TestSoftPowers","title":"TestSoftPowers — TestSoftPowers","text":"Compute scale-free topology model fit different soft power thresholds","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/TestSoftPowers.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"TestSoftPowers — TestSoftPowers","text":"","code":"TestSoftPowers(   seurat_obj,   powers = c(seq(1, 10, by = 1), seq(12, 30, by = 2)),   networkType = \"signed\",   corFnc = \"bicor\",   wgcna_name = NULL,   ... )"},{"path":"https://smorabit.github.io/hdWGCNA/reference/TestSoftPowers.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"TestSoftPowers — TestSoftPowers","text":"seurat_obj Seurat object powers numeric vector specifying soft powers test networkType type network use network analysis. Options \"signed\" (default), \"unsigned\", \"signed hybrid\". consistent network chosen ConstructNetwork corFnc Correlation function gene-gene correlation adjacency matrix. wgcna_name name WGCNA experiment ... additional parameters passed WGCNA::pickSoftThreshold","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/TestSoftPowers.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"TestSoftPowers — TestSoftPowers","text":"TestSoftPowers aims find optimal value \"soft-power threshold\" co-expression network analysis. varying values soft_power parameter, function assesses scale-free topology model fit resulting network function also calculates network statistics connectivity. user may also vary type network used correlation function. downstream functions, lowest soft_power reaches fit 0.8 selected network construction, user may select values.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/TestSoftPowersConsensus.html","id":null,"dir":"Reference","previous_headings":"","what":"TestSoftPowersConsensus — TestSoftPowersConsensus","title":"TestSoftPowersConsensus — TestSoftPowersConsensus","text":"Compute scale-free topology model fit different soft power thresholds separately input dataset","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/TestSoftPowersConsensus.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"TestSoftPowersConsensus — TestSoftPowersConsensus","text":"","code":"TestSoftPowersConsensus(   seurat_obj,   powers = c(seq(1, 10, by = 1), seq(12, 30, by = 2)),   use_metacells = TRUE,   networkType = \"signed\",   corFnc = \"bicor\",   setDatExpr = FALSE,   group.by = NULL,   group_name = NULL,   multi.group.by = NULL,   multi_groups = NULL,   wgcna_name = NULL,   ... )"},{"path":"https://smorabit.github.io/hdWGCNA/reference/TestSoftPowersConsensus.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"TestSoftPowersConsensus — TestSoftPowersConsensus","text":"seurat_obj Seurat object powers numeric vector specifying soft powers test use_metacells logical flag whether use metacell expression matrix networkType type network use network analysis. Options \"signed\" (default), \"unsigned\", \"signed hybrid\". consistent network chosen ConstructNetwork corFnc Correlation function gene-gene correlation adjacency matrix. setDatExpr logical flag indicating whether run setDatExpr. group.string containing name column Seurat object cell groups (clusters, cell types, etc). NULL (default), hdWGCNA uses Seurat Idents group. group_name string containing group present provided group.column Seurat Idents. character vector can provided select multiple groups time. multi.group.string containing name column Seurat object groups consensus WGCNA (dataset, sample, condition, etc) multi_groups character vecrtor containing names groups select ... additional parameters passed SetDatExpr","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/TestSoftPowersConsensus.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"TestSoftPowersConsensus — TestSoftPowersConsensus","text":"","code":"# TestSoftPowers(pbmc)"},{"path":"https://smorabit.github.io/hdWGCNA/reference/TransferModuleGenome.html","id":null,"dir":"Reference","previous_headings":"","what":"TransferModuleGenome — TransferModuleGenome","title":"TransferModuleGenome — TransferModuleGenome","text":"Takes module table gene mapping table (like biomart) gene names two genomes order switch","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/TransferModuleGenome.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"TransferModuleGenome — TransferModuleGenome","text":"","code":"TransferModuleGenome(   modules,   gene_mapping,   genome1_col = NULL,   genome2_col = NULL )"},{"path":"https://smorabit.github.io/hdWGCNA/reference/TransferModuleGenome.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"TransferModuleGenome — TransferModuleGenome","text":"modules module table GetModules function gene_mapping table gene names genomes genome1_col column gene_mapping gene names genome currently present modules genome2_col column gene_mapping gene names genome transfer ","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/TransferModuleGenome.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"TransferModuleGenome — TransferModuleGenome","text":"","code":"TransferModuleGenome #> function (modules, gene_mapping, genome1_col = NULL, genome2_col = NULL)  #> { #>     if (is.null(genome1_col)) { #>         genome1_col <- colnames(gene_mapping)[1] #>     } #>     if (is.null(genome2_col)) { #>         genome2_col <- colnames(gene_mapping)[2] #>     } #>     if (!all(table(gene_mapping[[genome2_col]]) == 1)) { #>         stop(\"There can only be one value for each feature in genome2_col in the gene_mapping table.\") #>     } #>     gene_mapping <- gene_mapping[, c(genome1_col, genome2_col)] #>     gene_list <- modules$gene_name #>     gene_mapping <- gene_mapping[gene_mapping[, genome1_col] %in%  #>         gene_list, ] #>     modules <- subset(modules, gene_name %in% gene_mapping[,  #>         genome1_col]) #>     gene_match <- match(gene_list, gene_mapping[, genome1_col]) #>     gene_mapping <- na.omit(gene_mapping[gene_match, ]) #>     print(head(gene_mapping)) #>     modules$gene_name <- gene_mapping[, genome2_col] #>     rownames(modules) <- modules$gene_name #>     modules #> } #> <bytecode: 0x7f961694eeb8> #> <environment: namespace:hdWGCNA>"},{"path":"https://smorabit.github.io/hdWGCNA/reference/check_inputs.html","id":null,"dir":"Reference","previous_headings":"","what":"Check inputs — check_inputs","title":"Check inputs — check_inputs","text":"Check inputs prior running to_pseudobulk","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/check_inputs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check inputs — check_inputs","text":"","code":"check_inputs(   input,   meta = meta,   replicate_col = \"replicate\",   cell_type_col = \"cell_type\",   label_col = \"label\" )"},{"path":"https://smorabit.github.io/hdWGCNA/reference/check_inputs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check inputs — check_inputs","text":"input single-cell matrix converted, features (genes) rows cells columns. Alternatively, Seurat, monocole3, SingleCellExperiment object can directly input. meta accompanying meta data whereby rownames match column names input. replicate_col vector meta containing replicate information. Defaults replicate. cell_type_col vector meta containing cell type information. Defaults cell_type. label_col vector meta containing experimental label. Defaults label. min_cells minimum number cells cell type retain . Defaults 3. min_reps minimum number replicates cell type retain . Defaults 2. min_features minimum number expressing cells (replicates) gene retain . Defaults 0.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/check_inputs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check inputs — check_inputs","text":"cleaned expression matrix meta data object","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/corSparse.html","id":null,"dir":"Reference","previous_headings":"","what":"Sparse matrix correlation — corSparse","title":"Sparse matrix correlation — corSparse","text":"Compute Pearson correlation matrix columns two sparse matrices.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/corSparse.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sparse matrix correlation — corSparse","text":"","code":"corSparse(X, Y = NULL, cov = FALSE)"},{"path":"https://smorabit.github.io/hdWGCNA/reference/corSparse.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sparse matrix correlation — corSparse","text":"X matrix Y matrix cov return covariance matrix","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/corSparse.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Sparse matrix correlation — corSparse","text":"Originally http://stackoverflow.com/questions/5888287/running-cor---variant---sparse-matrix--r qlcMatrix & Signac packages.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/corSparse.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Sparse matrix correlation — corSparse","text":"Michael Cysouw, Karsten Looschen","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/scale01.html","id":null,"dir":"Reference","previous_headings":"","what":"scale01 — scale01","title":"scale01 — scale01","text":"Function scale numeric vector 0 1.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/scale01.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"scale01 — scale01","text":"","code":"scale01(x)"},{"path":"https://smorabit.github.io/hdWGCNA/reference/scale01.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"scale01 — scale01","text":"x numeric vector","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/shuffle_points.html","id":null,"dir":"Reference","previous_headings":"","what":"shuffle_points — shuffle_points","title":"shuffle_points — shuffle_points","text":"Function shuffle rows dataframe.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/shuffle_points.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"shuffle_points — shuffle_points","text":"","code":"shuffle_points(df)"},{"path":"https://smorabit.github.io/hdWGCNA/reference/shuffle_points.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"shuffle_points — shuffle_points","text":"df dataframe","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/to_pseudobulk.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a pseudobulk matrix — to_pseudobulk","title":"Create a pseudobulk matrix — to_pseudobulk","text":"Convert single-cell expression matrix (.e., genes cells) pseudobulk matrix summarizing counts within biological replicates. function ","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/to_pseudobulk.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a pseudobulk matrix — to_pseudobulk","text":"","code":"to_pseudobulk(   input,   meta = NULL,   replicate_col = \"replicate\",   cell_type_col = \"cell_type\",   label_col = \"label\",   min_cells = 3,   min_reps = 2,   min_features = 0,   external = T )"},{"path":"https://smorabit.github.io/hdWGCNA/reference/to_pseudobulk.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a pseudobulk matrix — to_pseudobulk","text":"input single-cell matrix converted, features (genes) rows cells columns. Alternatively, Seurat, monocole3, SingleCellExperiment object can directly input. meta accompanying meta data whereby rownames match column names input. replicate_col vector meta containing replicate information. Defaults replicate. cell_type_col vector meta containing cell type information. Defaults cell_type. label_col vector meta containing experimental label. Defaults label. min_cells minimum number cells cell type retain . Defaults 3. min_reps minimum number replicates cell type retain . Defaults 2. min_features minimum number expressing cells (replicates) gene retain . Defaults 0.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/to_pseudobulk.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a pseudobulk matrix — to_pseudobulk","text":"list pseudobulk matrices, cell type.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/umap_theme.html","id":null,"dir":"Reference","previous_headings":"","what":"umap_theme — umap_theme","title":"umap_theme — umap_theme","text":"ggplot theme remove axes etc.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/reference/umap_theme.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"umap_theme — umap_theme","text":"","code":"umap_theme()"},{"path":[]},{"path":"https://smorabit.github.io/hdWGCNA/news/index.html","id":"added-0-4-00","dir":"Changelog","previous_headings":"","what":"Added","title":"hdWGCNA 0.4.00 (2024-10-09)","text":"Transcription Factor Regulatory Network Analysis functionality.","code":""},{"path":[]},{"path":"https://smorabit.github.io/hdWGCNA/news/index.html","id":"added-0-3-03","dir":"Changelog","previous_headings":"","what":"Added","title":"hdWGCNA 0.3.03 (2024-06-07)","text":"ModuleRadarPlot function visualize expression levels module.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/news/index.html","id":"changes-0-3-03","dir":"Changelog","previous_headings":"","what":"Changes","title":"hdWGCNA 0.3.03 (2024-06-07)","text":"Bugfix PlotModuleTraitCorrelation Update basics tutorial include ModuleRadarPlot","code":""},{"path":[]},{"path":"https://smorabit.github.io/hdWGCNA/news/index.html","id":"added-0-3-02","dir":"Changelog","previous_headings":"","what":"Added","title":"hdWGCNA 0.3.02 (2024-05-28)","text":"New functionality methods module preservation analysis using NetRep method Ritchie et al 2016. - ModuleTopologyHeatmap function. - ModuleTopologyBarplot function. - ModulePreservationNetrep function. - PlotModulePreservationLollipop function.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/news/index.html","id":"changes-0-3-02","dir":"Changelog","previous_headings":"","what":"Changes","title":"hdWGCNA 0.3.02 (2024-05-28)","text":"Update module preservation tutorial demonstrate perform module preservation analysis using NetRep.","code":""},{"path":[]},{"path":"https://smorabit.github.io/hdWGCNA/news/index.html","id":"added-0-3-01","dir":"Changelog","previous_headings":"","what":"Added","title":"hdWGCNA 0.3.01 (2024-03-07)","text":"None","code":""},{"path":"https://smorabit.github.io/hdWGCNA/news/index.html","id":"changes-0-3-01","dir":"Changelog","previous_headings":"","what":"Changes","title":"hdWGCNA 0.3.01 (2024-03-07)","text":"Bugfix ModulePreservation Update module preservation tutorial project modules tutorial.","code":""},{"path":[]},{"path":"https://smorabit.github.io/hdWGCNA/news/index.html","id":"added-0-3-00","dir":"Changelog","previous_headings":"","what":"Added","title":"hdWGCNA 0.3.00 (2024-02-27)","text":"First version support Seurat v5. Updated network visualization tutorial tutorial making custom networks.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/news/index.html","id":"changes-0-3-00","dir":"Changelog","previous_headings":"","what":"Changes","title":"hdWGCNA 0.3.00 (2024-02-27)","text":"Changed FindDMEs FindAllDMEs perform differential testing module expression scores.","code":""},{"path":[]},{"path":"https://smorabit.github.io/hdWGCNA/news/index.html","id":"added-0-2-27","dir":"Changelog","previous_headings":"","what":"Added","title":"hdWGCNA 0.2.27 (2024-01-29)","text":"New option MetacellsByGroups specify dims.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/news/index.html","id":"changes-0-2-27","dir":"Changelog","previous_headings":"","what":"Changes","title":"hdWGCNA 0.2.27 (2024-01-29)","text":"Fixed HubGeneNetworkPlot allow selecting specific modules. GetHubGenes now returns genes order highest lowest kME module.","code":""},{"path":[]},{"path":"https://smorabit.github.io/hdWGCNA/news/index.html","id":"added-0-2-26","dir":"Changelog","previous_headings":"","what":"Added","title":"hdWGCNA 0.2.26 (2023-12-05)","text":"None","code":""},{"path":"https://smorabit.github.io/hdWGCNA/news/index.html","id":"changes-0-2-26","dir":"Changelog","previous_headings":"","what":"Changes","title":"hdWGCNA 0.2.26 (2023-12-05)","text":"New options changing colors EnrichrBarPlot. ConstructNetwork naming temporary files updated.","code":""},{"path":[]},{"path":"https://smorabit.github.io/hdWGCNA/news/index.html","id":"added-0-2-25","dir":"Changelog","previous_headings":"","what":"Added","title":"hdWGCNA 0.2.25 (2023-11-28)","text":"None","code":""},{"path":"https://smorabit.github.io/hdWGCNA/news/index.html","id":"changes-0-2-25","dir":"Changelog","previous_headings":"","what":"Changes","title":"hdWGCNA 0.2.25 (2023-11-28)","text":"Requires Seurat version 4. update support v5 future.","code":""},{"path":[]},{"path":"https://smorabit.github.io/hdWGCNA/news/index.html","id":"added-0-2-24","dir":"Changelog","previous_headings":"","what":"Added","title":"hdWGCNA 0.2.24 (2023-09-28)","text":"None","code":""},{"path":"https://smorabit.github.io/hdWGCNA/news/index.html","id":"changes-0-2-24","dir":"Changelog","previous_headings":"","what":"Changes","title":"hdWGCNA 0.2.24 (2023-09-28)","text":"Update call Harmony ModuleEigengenes function","code":""},{"path":[]},{"path":"https://smorabit.github.io/hdWGCNA/news/index.html","id":"added-0-2-23","dir":"Changelog","previous_headings":"","what":"Added","title":"hdWGCNA 0.2.23 (2023-09-10)","text":"None","code":""},{"path":"https://smorabit.github.io/hdWGCNA/news/index.html","id":"changes-0-2-23","dir":"Changelog","previous_headings":"","what":"Changes","title":"hdWGCNA 0.2.23 (2023-09-10)","text":"Fixed bug SetDatExpr","code":""},{"path":[]},{"path":"https://smorabit.github.io/hdWGCNA/news/index.html","id":"added-0-2-22","dir":"Changelog","previous_headings":"","what":"Added","title":"hdWGCNA 0.2.22 (2023-09-08)","text":"New tutorial hdWGCNA pseudobulk data, including new functions like ConstructPseudobulk.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/news/index.html","id":"changes-0-2-22","dir":"Changelog","previous_headings":"","what":"Changes","title":"hdWGCNA 0.2.22 (2023-09-08)","text":"Updated SetDatExpr SetMultiExpr use pseudobulk expression matrix.","code":""},{"path":[]},{"path":"https://smorabit.github.io/hdWGCNA/news/index.html","id":"added-0-2-21","dir":"Changelog","previous_headings":"","what":"Added","title":"hdWGCNA 0.2.21 (2023-08-31)","text":"Additional checks wgcna_name several functions. New section DME tutorial show run loop multiple clusters.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/news/index.html","id":"changes-0-2-21","dir":"Changelog","previous_headings":"","what":"Changes","title":"hdWGCNA 0.2.21 (2023-08-31)","text":"None.","code":""},{"path":[]},{"path":"https://smorabit.github.io/hdWGCNA/news/index.html","id":"added-0-2-20","dir":"Changelog","previous_headings":"","what":"Added","title":"hdWGCNA 0.2.20 (2023-08-17)","text":"None.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/news/index.html","id":"changes-0-2-20","dir":"Changelog","previous_headings":"","what":"Changes","title":"hdWGCNA 0.2.20 (2023-08-17)","text":"Dependency tester pacakge.","code":""},{"path":[]},{"path":"https://smorabit.github.io/hdWGCNA/news/index.html","id":"added-0-2-19","dir":"Changelog","previous_headings":"","what":"Added","title":"hdWGCNA 0.2.19 (2023-06-13)","text":"None.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/news/index.html","id":"changes-0-2-19","dir":"Changelog","previous_headings":"","what":"Changes","title":"hdWGCNA 0.2.19 (2023-06-13)","text":"Updated README include publication, fixed several igraph function calls.","code":""},{"path":[]},{"path":"https://smorabit.github.io/hdWGCNA/news/index.html","id":"added-0-2-18","dir":"Changelog","previous_headings":"","what":"Added","title":"hdWGCNA 0.2.18 (2023-04-14)","text":"None.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/news/index.html","id":"changes-0-2-18","dir":"Changelog","previous_headings":"","what":"Changes","title":"hdWGCNA 0.2.18 (2023-04-14)","text":"noticed rare occasion EnrichR give duplicated results different modules, added new option RunEnrichr wait sending requests EnrichR server (default 5 seconds).","code":""},{"path":[]},{"path":"https://smorabit.github.io/hdWGCNA/news/index.html","id":"added-0-2-17","dir":"Changelog","previous_headings":"","what":"Added","title":"hdWGCNA 0.2.17 (2023-03-27)","text":"None.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/news/index.html","id":"changes-0-2-17","dir":"Changelog","previous_headings":"","what":"Changes","title":"hdWGCNA 0.2.17 (2023-03-27)","text":"New error checks SetupForWGCNA SelectNetworkGenes","code":""},{"path":[]},{"path":"https://smorabit.github.io/hdWGCNA/news/index.html","id":"added-0-2-16","dir":"Changelog","previous_headings":"","what":"Added","title":"hdWGCNA 0.2.16 (2023-03-20)","text":"PlotDMEsLollipop function visualize differential module eigengenes.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/news/index.html","id":"changes-0-2-16","dir":"Changelog","previous_headings":"","what":"Changes","title":"hdWGCNA 0.2.16 (2023-03-20)","text":"New error checks MetacellsByGroups","code":""},{"path":[]},{"path":"https://smorabit.github.io/hdWGCNA/news/index.html","id":"added-0-2-15","dir":"Changelog","previous_headings":"","what":"Added","title":"hdWGCNA 0.2.15 (2023-03-02)","text":"None","code":""},{"path":"https://smorabit.github.io/hdWGCNA/news/index.html","id":"changes-0-2-15","dir":"Changelog","previous_headings":"","what":"Changes","title":"hdWGCNA 0.2.15 (2023-03-02)","text":"Bugfix allow ResetModuleNames ResetModuleColors work grey module present.","code":""},{"path":[]},{"path":"https://smorabit.github.io/hdWGCNA/news/index.html","id":"added-0-2-14","dir":"Changelog","previous_headings":"","what":"Added","title":"hdWGCNA 0.2.14 (2023-02-14)","text":"None","code":""},{"path":"https://smorabit.github.io/hdWGCNA/news/index.html","id":"changes-0-2-14","dir":"Changelog","previous_headings":"","what":"Changes","title":"hdWGCNA 0.2.14 (2023-02-14)","text":"Fixed bug SetDatExpr throw error group.=NULL selected.","code":""},{"path":[]},{"path":"https://smorabit.github.io/hdWGCNA/news/index.html","id":"added-0-2-13","dir":"Changelog","previous_headings":"","what":"Added","title":"hdWGCNA 0.2.13 (2023-02-13)","text":"None","code":""},{"path":"https://smorabit.github.io/hdWGCNA/news/index.html","id":"changes-0-2-13","dir":"Changelog","previous_headings":"","what":"Changes","title":"hdWGCNA 0.2.13 (2023-02-13)","text":"Fixed bug ReassignModules cause modules assignments NA genes.","code":""},{"path":[]},{"path":"https://smorabit.github.io/hdWGCNA/news/index.html","id":"added-0-2-12","dir":"Changelog","previous_headings":"","what":"Added","title":"hdWGCNA 0.2.12 (2023-02-04)","text":"Module eigengene dynamics pseudotime tutorial PlotModuleTrajectory function.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/news/index.html","id":"changes-0-2-12","dir":"Changelog","previous_headings":"","what":"Changes","title":"hdWGCNA 0.2.12 (2023-02-04)","text":"None.","code":""},{"path":[]},{"path":"https://smorabit.github.io/hdWGCNA/news/index.html","id":"added-0-2-11","dir":"Changelog","previous_headings":"","what":"Added","title":"hdWGCNA 0.2.11 (2023-01-30)","text":"MAS-Seq tutorial (still construction)","code":""},{"path":"https://smorabit.github.io/hdWGCNA/news/index.html","id":"changes-0-2-11","dir":"Changelog","previous_headings":"","what":"Changes","title":"hdWGCNA 0.2.11 (2023-01-30)","text":"Bugfix ModuleConnectivity ReassignModules.","code":""},{"path":[]},{"path":"https://smorabit.github.io/hdWGCNA/news/index.html","id":"added-0-2-1","dir":"Changelog","previous_headings":"","what":"Added","title":"hdWGCNA 0.2.1 (2023-01-24)","text":"ReassignModules function.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/news/index.html","id":"changes-0-2-1","dir":"Changelog","previous_headings":"","what":"Changes","title":"hdWGCNA 0.2.1 (2023-01-24)","text":"New option ModuleConnectivity use corSparse compute correlation, greatly reduces runtime memory usage. New option ModuleConnectivity automatically reassign features different modules kME negative.","code":""},{"path":[]},{"path":"https://smorabit.github.io/hdWGCNA/news/index.html","id":"added-0-2-03","dir":"Changelog","previous_headings":"","what":"Added","title":"hdWGCNA 0.2.03 (2022-12-15)","text":"None","code":""},{"path":"https://smorabit.github.io/hdWGCNA/news/index.html","id":"changes-0-2-03","dir":"Changelog","previous_headings":"","what":"Changes","title":"hdWGCNA 0.2.03 (2022-12-15)","text":"Fixed bug ResetModuleNames.","code":""},{"path":[]},{"path":"https://smorabit.github.io/hdWGCNA/news/index.html","id":"added-0-2-03-1","dir":"Changelog","previous_headings":"","what":"Added","title":"hdWGCNA 0.2.03 (2022-11-10)","text":"None","code":""},{"path":"https://smorabit.github.io/hdWGCNA/news/index.html","id":"changes-0-2-03-1","dir":"Changelog","previous_headings":"","what":"Changes","title":"hdWGCNA 0.2.03 (2022-11-10)","text":"New error checking MetaspotsByGroups MetacellsByGroups now keeps track cells merged.","code":""},{"path":[]},{"path":"https://smorabit.github.io/hdWGCNA/news/index.html","id":"added-0-2-02","dir":"Changelog","previous_headings":"","what":"Added","title":"hdWGCNA 0.2.02 (2022-11-01)","text":"None","code":""},{"path":"https://smorabit.github.io/hdWGCNA/news/index.html","id":"changes-0-2-02","dir":"Changelog","previous_headings":"","what":"Changes","title":"hdWGCNA 0.2.02 (2022-11-01)","text":"New warning SetupForWGCNA user selects small number genes. MetaspotsByGroups uses sparse matrix format internally.","code":""},{"path":[]},{"path":"https://smorabit.github.io/hdWGCNA/news/index.html","id":"added-0-2-01","dir":"Changelog","previous_headings":"","what":"Added","title":"hdWGCNA 0.2.01 (2022-10-06)","text":"None","code":""},{"path":"https://smorabit.github.io/hdWGCNA/news/index.html","id":"changes-0-2-01","dir":"Changelog","previous_headings":"","what":"Changes","title":"hdWGCNA 0.2.01 (2022-10-06)","text":"Bugfix MetaspotsByGroups.","code":""},{"path":[]},{"path":"https://smorabit.github.io/hdWGCNA/news/index.html","id":"added-0-2-00","dir":"Changelog","previous_headings":"","what":"Added","title":"hdWGCNA 0.2.00 (2022-09-23)","text":"MetaspotsByGroups aggregate neighboring ST spots prior network analysis. Tutorial applying hdWGCNA spatial transcriptomics datasets.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/news/index.html","id":"changes-0-2-00","dir":"Changelog","previous_headings":"","what":"Changes","title":"hdWGCNA 0.2.00 (2022-09-23)","text":"None","code":""},{"path":[]},{"path":"https://smorabit.github.io/hdWGCNA/news/index.html","id":"added-0-1-2-0001","dir":"Changelog","previous_headings":"","what":"Added","title":"hdWGCNA 0.1.2.0001 (2022-09-19)","text":"None","code":""},{"path":"https://smorabit.github.io/hdWGCNA/news/index.html","id":"changes-0-1-2-0001","dir":"Changelog","previous_headings":"","what":"Changes","title":"hdWGCNA 0.1.2.0001 (2022-09-19)","text":"networkType option TestSoftPowers.","code":""},{"path":[]},{"path":"https://smorabit.github.io/hdWGCNA/news/index.html","id":"added-0-1-2-0000","dir":"Changelog","previous_headings":"","what":"Added","title":"hdWGCNA 0.1.2.0000 (2022-09-08)","text":"Differential Module Eigengene (DME) tutorial FindDMEs function FindAllDMEs function PlotDMEsVolcano function","code":""},{"path":"https://smorabit.github.io/hdWGCNA/news/index.html","id":"changes-0-1-2-0000","dir":"Changelog","previous_headings":"","what":"Changes","title":"hdWGCNA 0.1.2.0000 (2022-09-08)","text":"None","code":""},{"path":[]},{"path":"https://smorabit.github.io/hdWGCNA/news/index.html","id":"added-0-1-1-9015","dir":"Changelog","previous_headings":"","what":"Added","title":"hdWGCNA 0.1.1.9015 (2022-09-06)","text":"None","code":""},{"path":"https://smorabit.github.io/hdWGCNA/news/index.html","id":"changes-0-1-1-9015","dir":"Changelog","previous_headings":"","what":"Changes","title":"hdWGCNA 0.1.1.9015 (2022-09-06)","text":"New data format check MetacellsByGroups ensure selected slot present selected assay. SetDatExpr now backs full dataset metacell dataset isn’t found. Changed text clarify points Module Preservation tutorial.","code":""},{"path":[]},{"path":"https://smorabit.github.io/hdWGCNA/news/index.html","id":"added-0-1-1-9014","dir":"Changelog","previous_headings":"","what":"Added","title":"hdWGCNA 0.1.1.9014 (2022-08-26)","text":"None","code":""},{"path":"https://smorabit.github.io/hdWGCNA/news/index.html","id":"changes-0-1-1-9014","dir":"Changelog","previous_headings":"","what":"Changes","title":"hdWGCNA 0.1.1.9014 (2022-08-26)","text":"Bugfix ModuleConnectivity caused kMEs order.","code":""},{"path":[]},{"path":"https://smorabit.github.io/hdWGCNA/news/index.html","id":"added-0-1-1-9013","dir":"Changelog","previous_headings":"","what":"Added","title":"hdWGCNA 0.1.1.9013 (2022-08-25)","text":"Tutorial using SCTransform normalized data.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/news/index.html","id":"changes-0-1-1-9013","dir":"Changelog","previous_headings":"","what":"Changes","title":"hdWGCNA 0.1.1.9013 (2022-08-25)","text":"None","code":""},{"path":[]},{"path":"https://smorabit.github.io/hdWGCNA/news/index.html","id":"added-0-1-1-9012","dir":"Changelog","previous_headings":"","what":"Added","title":"hdWGCNA 0.1.1.9012 (2022-08-24)","text":"None","code":""},{"path":"https://smorabit.github.io/hdWGCNA/news/index.html","id":"changes-0-1-1-9012","dir":"Changelog","previous_headings":"","what":"Changes","title":"hdWGCNA 0.1.1.9012 (2022-08-24)","text":"Now includes options types correlations ModuleConnectivity.","code":""},{"path":[]},{"path":"https://smorabit.github.io/hdWGCNA/news/index.html","id":"added-0-1-1-9011","dir":"Changelog","previous_headings":"","what":"Added","title":"hdWGCNA 0.1.1.9011 (2022-08-17)","text":"None","code":""},{"path":"https://smorabit.github.io/hdWGCNA/news/index.html","id":"changes-0-1-1-9011","dir":"Changelog","previous_headings":"","what":"Changes","title":"hdWGCNA 0.1.1.9011 (2022-08-17)","text":"Reverted exclude_grey flag back nothing ModuleEigengenes function messed downstream tasks, resolve future update. ProjectModules now excludes modules many missing genes query dataset, tunable overlap_proportion parameter.","code":""},{"path":[]},{"path":"https://smorabit.github.io/hdWGCNA/news/index.html","id":"added-0-1-1-9010","dir":"Changelog","previous_headings":"","what":"Added","title":"hdWGCNA 0.1.1.9010 (2022-07-30)","text":"None","code":""},{"path":"https://smorabit.github.io/hdWGCNA/news/index.html","id":"changes-0-1-1-9010","dir":"Changelog","previous_headings":"","what":"Changes","title":"hdWGCNA 0.1.1.9010 (2022-07-30)","text":"default, ModuleEigengenes compute MEs grey module. User can change behavior exclude_grey flag.","code":""},{"path":[]},{"path":"https://smorabit.github.io/hdWGCNA/news/index.html","id":"added-0-1-1-9009","dir":"Changelog","previous_headings":"","what":"Added","title":"hdWGCNA 0.1.1.9009 (2022-07-23)","text":"None","code":""},{"path":"https://smorabit.github.io/hdWGCNA/news/index.html","id":"changes-0-1-1-9009","dir":"Changelog","previous_headings":"","what":"Changes","title":"hdWGCNA 0.1.1.9009 (2022-07-23)","text":"Bugfix ProjectModules. Bugfix MetacellsByGroups","code":""},{"path":[]},{"path":"https://smorabit.github.io/hdWGCNA/news/index.html","id":"added-0-1-1-9008","dir":"Changelog","previous_headings":"","what":"Added","title":"hdWGCNA 0.1.1.9008 (2022-07-21)","text":"New tutorial consensus co-expression network analysis.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/news/index.html","id":"changes-0-1-1-9008","dir":"Changelog","previous_headings":"","what":"Changes","title":"hdWGCNA 0.1.1.9008 (2022-07-21)","text":"ModuleNetworkPlot RunModuleUMAP now checks ModuleConnectivity computed order throw informative error. GetTOM checks TOM file exists order throw informative error.","code":""},{"path":[]},{"path":"https://smorabit.github.io/hdWGCNA/news/index.html","id":"added-0-1-1-9007","dir":"Changelog","previous_headings":"","what":"Added","title":"hdWGCNA 0.1.1.9007 (2022-07-20)","text":"None","code":""},{"path":"https://smorabit.github.io/hdWGCNA/news/index.html","id":"changes-0-1-1-9007","dir":"Changelog","previous_headings":"","what":"Changes","title":"hdWGCNA 0.1.1.9007 (2022-07-20)","text":"New warning message MetacellsByGroups groups excluded min_cells. Assay Metacell seurat object now assay supplied MetacellsByGroups, instead default “RNA”. ModuleEigengenes takes assay argument, clears issues RunHarmony. ModuleEigengenes doesn’t require “counts” slot present given assay, now throws error normalized data slot missing.","code":""},{"path":[]},{"path":"https://smorabit.github.io/hdWGCNA/news/index.html","id":"added-0-1-1-9006","dir":"Changelog","previous_headings":"","what":"Added","title":"hdWGCNA 0.1.1.9006 (2022-07-14)","text":"None","code":""},{"path":"https://smorabit.github.io/hdWGCNA/news/index.html","id":"changes-0-1-1-9006","dir":"Changelog","previous_headings":"","what":"Changes","title":"hdWGCNA 0.1.1.9006 (2022-07-14)","text":"ConstructNetwork now checks TOM file already exists, whether user wants overwrite existing TOM.","code":""},{"path":[]},{"path":"https://smorabit.github.io/hdWGCNA/news/index.html","id":"added-0-1-1-9005","dir":"Changelog","previous_headings":"","what":"Added","title":"hdWGCNA 0.1.1.9005 (2022-06-17)","text":"None","code":""},{"path":"https://smorabit.github.io/hdWGCNA/news/index.html","id":"changes-0-1-1-9005","dir":"Changelog","previous_headings":"","what":"Changes","title":"hdWGCNA 0.1.1.9005 (2022-06-17)","text":"Added new arguments MetacellsByGroups ConstructMetacells exclude small groups (min_cells), reach target number metacells (target_metacells), exclude metacells much overlap (max_shared).","code":""},{"path":[]},{"path":"https://smorabit.github.io/hdWGCNA/news/index.html","id":"added-0-1-1-9004","dir":"Changelog","previous_headings":"","what":"Added","title":"hdWGCNA 0.1.1.9004 (2022-6-13)","text":"None","code":""},{"path":"https://smorabit.github.io/hdWGCNA/news/index.html","id":"changes-0-1-1-9004","dir":"Changelog","previous_headings":"","what":"Changes","title":"hdWGCNA 0.1.1.9004 (2022-6-13)","text":"Bug fix ModuleTraitCorrelation can run single trait.","code":""},{"path":[]},{"path":"https://smorabit.github.io/hdWGCNA/news/index.html","id":"added-0-1-1-9003","dir":"Changelog","previous_headings":"","what":"Added","title":"hdWGCNA 0.1.1.9003 (2022-6-11)","text":"GetHubGenes function extract top hub genes module assignment table.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/news/index.html","id":"changes-0-1-1-9003","dir":"Changelog","previous_headings":"","what":"Changes","title":"hdWGCNA 0.1.1.9003 (2022-6-11)","text":"ConstructMetacells stores run statistics table, new option exclude metacells overlap .","code":""},{"path":[]},{"path":"https://smorabit.github.io/hdWGCNA/news/index.html","id":"added-0-1-1-9002","dir":"Changelog","previous_headings":"","what":"Added","title":"hdWGCNA 0.1.1.9002 (2022-5-24)","text":"ModuleEigengenes checks make sure data scaled.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/news/index.html","id":"changes-0-1-1-9002","dir":"Changelog","previous_headings":"","what":"Changes","title":"hdWGCNA 0.1.1.9002 (2022-5-24)","text":"None","code":""},{"path":[]},{"path":"https://smorabit.github.io/hdWGCNA/news/index.html","id":"added-0-1-1-9001","dir":"Changelog","previous_headings":"","what":"Added","title":"hdWGCNA 0.1.1.9001 (2022-05-09)","text":"Wrote docstring PlotKMEs actually included package.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/news/index.html","id":"changes-0-1-1-9001","dir":"Changelog","previous_headings":"","what":"Changes","title":"hdWGCNA 0.1.1.9001 (2022-05-09)","text":"None","code":""},{"path":[]},{"path":"https://smorabit.github.io/hdWGCNA/news/index.html","id":"added-0-1-1-9000","dir":"Changelog","previous_headings":"","what":"Added","title":"hdWGCNA 0.1.1.9000 (2022-05-05)","text":"PlotKMEs function visualize genes module ranked kME.","code":""},{"path":"https://smorabit.github.io/hdWGCNA/news/index.html","id":"changes-0-1-1-9000","dir":"Changelog","previous_headings":"","what":"Changes","title":"hdWGCNA 0.1.1.9000 (2022-05-05)","text":"Changed name package scWGCNA hdWGCNA, since plan accommodate data types beyond single cell alone. Updated tutorial recommend computing kMEs specific cell population.","code":""}]
